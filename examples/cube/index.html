<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="image" content="https://docs.cubixdev.org/BANNER.png">
        <meta name="author" content="Cubix Entertainment">
        <link rel="canonical" href="https://docs.cubixdev.org/examples/cube/">
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Cube - Infinite Developer Docs</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/fontawesome.min.css" rel="stylesheet">
        <link href="../../css/brands.min.css" rel="stylesheet">
        <link href="../../css/solid.min.css" rel="stylesheet">
        <link href="../../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/tokyo-night-dark.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">Libfinite</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                                <li class="nav-item">
                                    <a href="../.." class="nav-link">Home</a>
                                </li>
                                <li class="nav-item">
                                    <a href="../../getting_started/" class="nav-link">Getting Started</a>
                                </li>
                                <li class="nav-item dropdown">
                                    <a href="#" class="nav-link dropdown-toggle active" aria-current="page" role="button" data-bs-toggle="dropdown"  aria-expanded="false">Examples</a>
                                    <ul class="dropdown-menu">
                                        
<li>
    <a href="../audio/" class="dropdown-item">Audio</a>
</li>
                                        
<li>
    <a href="./" class="dropdown-item active" aria-current="page">Cube</a>
</li>
                                        
<li>
    <a href="../draw/" class="dropdown-item">Draw</a>
</li>
                                        
<li>
    <a href="../render/" class="dropdown-item">Render</a>
</li>
                                    </ul>
                                </li>
                                <li class="nav-item dropdown">
                                    <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">Reference</a>
                                    <ul class="dropdown-menu">
                                        
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Enums</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../reference/enums/FiniteDirectionType/" class="dropdown-item">FiniteDirectionType</a>
</li>
            
<li>
    <a href="../../reference/enums/FiniteKey/" class="dropdown-item">FiniteKey</a>
</li>
            
<li>
    <a href="../../reference/enums/FiniteShaderType/" class="dropdown-item">FiniteShaderType</a>
</li>
    </ul>
  </li>
                                        
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Functions</a>
    <ul class="dropdown-menu">
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Audio</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../reference/functions/audio/finite_audio_cleanup/" class="dropdown-item">finite_audio_cleanup</a>
</li>
            
<li>
    <a href="../../reference/functions/audio/finite_audio_device_init/" class="dropdown-item">finite_audio_device_init</a>
</li>
            
<li>
    <a href="../../reference/functions/audio/finite_audio_get_audio_duration/" class="dropdown-item">finite_audio_get_audio_duration</a>
</li>
            
<li>
    <a href="../../reference/functions/audio/finite_audio_get_audio_params/" class="dropdown-item">finite_audio_get_audio_params</a>
</li>
            
<li>
    <a href="../../reference/functions/audio/finite_audio_init_audio/" class="dropdown-item">finite_audio_init_audio</a>
</li>
            
<li>
    <a href="../../reference/functions/audio/finite_audio_pause/" class="dropdown-item">finite_audio_pause</a>
</li>
            
<li>
    <a href="../../reference/functions/audio/finite_audio_play/" class="dropdown-item">finite_audio_play</a>
</li>
            
<li>
    <a href="../../reference/functions/audio/finite_audio_stop/" class="dropdown-item">finite_audio_stop</a>
</li>
            
<li>
    <a href="../../reference/functions/audio/finite_audio_unpause/" class="dropdown-item">finite_audio_unpause</a>
</li>
    </ul>
  </li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Draw</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../reference/functions/draw/finite_draw_cleanup/" class="dropdown-item">finite_draw_cleanup</a>
</li>
            
<li>
    <a href="../../reference/functions/draw/finite_draw_create_snapshot/" class="dropdown-item">finite_draw_create_snapshot</a>
</li>
            
<li>
    <a href="../../reference/functions/draw/finite_draw_finish/" class="dropdown-item">finite_draw_finish</a>
</li>
            
<li>
    <a href="../../reference/functions/draw/finite_draw_get_font_extents/" class="dropdown-item">finite_draw_get_font_extents</a>
</li>
            
<li>
    <a href="../../reference/functions/draw/finite_draw_get_text_extents/" class="dropdown-item">finite_draw_get_text_extents</a>
</li>
            
<li>
    <a href="../../reference/functions/draw/finite_draw_load_snapshot/" class="dropdown-item">finite_draw_load_snapshot</a>
</li>
            
<li>
    <a href="../../reference/functions/draw/finite_draw_pattern_linear/" class="dropdown-item">finite_draw_text_group</a>
</li>
            
<li>
    <a href="../../reference/functions/draw/finite_draw_png/" class="dropdown-item">finite_draw_png</a>
</li>
            
<li>
    <a href="../../reference/functions/draw/finite_draw_rect/" class="dropdown-item">finite_draw_rect</a>
</li>
            
<li>
    <a href="../../reference/functions/draw/finite_draw_rounded_rect/" class="dropdown-item">finite_draw_rounded_rect</a>
</li>
            
<li>
    <a href="../../reference/functions/draw/finite_draw_set_draw_position/" class="dropdown-item">finite_draw_set_draw_position</a>
</li>
            
<li>
    <a href="../../reference/functions/draw/finite_draw_set_font/" class="dropdown-item">finite_draw_set_font</a>
</li>
            
<li>
    <a href="../../reference/functions/draw/finite_draw_set_offset/" class="dropdown-item">finite_draw_set_offset</a>
</li>
            
<li>
    <a href="../../reference/functions/draw/finite_draw_set_text/" class="dropdown-item">finite_draw_set_text</a>
</li>
            
<li>
    <a href="../../reference/functions/draw/finite_draw_stroke/" class="dropdown-item">finite_draw_stroke</a>
</li>
            
<li>
    <a href="../../reference/functions/draw/finite_draw_text_group/" class="dropdown-item">finite_draw_text_group</a>
</li>
            
<li>
    <a href="../../reference/functions/draw/finite_overlay_init/" class="dropdown-item">finite_overlay_init</a>
</li>
            
<li>
    <a href="../../reference/functions/draw/finite_shell_init/" class="dropdown-item">finite_shell_init</a>
</li>
            
<li>
    <a href="../../reference/functions/draw/finite_window_init/" class="dropdown-item">finite_window_init</a>
</li>
            
<li>
    <a href="../../reference/functions/draw/finite_window_size_set/" class="dropdown-item">finite_window_size_set</a>
</li>
    </ul>
  </li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Input</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../reference/functions/input/finite_input_keyboard_init/" class="dropdown-item">finite_input_keyboard_init</a>
</li>
            
<li>
    <a href="../../reference/functions/input/finite_input_poll_keys/" class="dropdown-item">finite_input_poll_keys</a>
</li>
            
<li>
    <a href="../../reference/functions/input/finite_key_down/" class="dropdown-item">finite_key_down</a>
</li>
            
<li>
    <a href="../../reference/functions/input/finite_key_from_string/" class="dropdown-item">finite_key_from_string</a>
</li>
            
<li>
    <a href="../../reference/functions/input/finite_key_pressed/" class="dropdown-item">finite_key_pressed</a>
</li>
            
<li>
    <a href="../../reference/functions/input/finite_key_string_from_key/" class="dropdown-item">finite_key_string_from_key</a>
</li>
            
<li>
    <a href="../../reference/functions/input/finite_key_up/" class="dropdown-item">finite_key_up</a>
</li>
            
<li>
    <a href="../../reference/functions/input/finite_key_valid/" class="dropdown-item">finite_key_valid</a>
</li>
            
<li>
    <a href="../../reference/functions/input/finite_keyboard_destroy/" class="dropdown-item">finite_keyboard_destroy</a>
</li>
    </ul>
  </li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Render</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../reference/functions/render/" class="dropdown-item">Render</a>
</li>
            
<li>
    <a href="../../reference/functions/render/finite_render_create_device/" class="dropdown-item">finite_render_create_device</a>
</li>
            
<li>
    <a href="../../reference/functions/render/finite_render_create_example_render_pass/" class="dropdown-item">finite_render_create_example_render_pass</a>
</li>
            
<li>
    <a href="../../reference/functions/render/finite_render_create_physical_device/" class="dropdown-item">finite_render_create_physical_device</a>
</li>
            
<li>
    <a href="../../reference/functions/render/finite_render_create_swapchain/" class="dropdown-item">finite_render_create_swapchain</a>
</li>
            
<li>
    <a href="../../reference/functions/render/finite_render_create_swapchain_images/" class="dropdown-item">finite_render_create_swapchain_images</a>
</li>
            
<li>
    <a href="../../reference/functions/render/finite_render_get_shader_code/" class="dropdown-item">finite_render_get_shader_code</a>
</li>
            
<li>
    <a href="../../reference/functions/render/finite_render_init/" class="dropdown-item">finite_render_init</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                        
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Types</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../reference/types/FiniteBtn/" class="dropdown-item">FiniteBtn</a>
</li>
            
<li>
    <a href="../../reference/types/FiniteBtnRelationShips/" class="dropdown-item">FiniteBtnRelationShips</a>
</li>
            
<li>
    <a href="../../reference/types/FiniteKeyState/" class="dropdown-item">FiniteKeyState</a>
</li>
            
<li>
    <a href="../../reference/types/FiniteKeyboard/" class="dropdown-item">FiniteKeyboard</a>
</li>
            
<li>
    <a href="../../reference/types/FinitePlaybackDevice/" class="dropdown-item">FinitePlaybackDevice</a>
</li>
            
<li>
    <a href="../../reference/types/FinitePlaybackDuration/" class="dropdown-item">FinitePlaybackDuration</a>
</li>
            
<li>
    <a href="../../reference/types/FiniteShell/" class="dropdown-item">FiniteShell</a>
</li>
            
<li>
    <a href="../../reference/types/FiniteTextGroup/" class="dropdown-item">FiniteTextGroup</a>
</li>
            
<li>
    <a href="../../reference/types/FiniteWindowInfo/" class="dropdown-item">FiniteWindowInfo</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Render</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../reference/types/render/FiniteRender/" class="dropdown-item">FiniteRender</a>
</li>
            
<li>
    <a href="../../reference/types/render/FiniteRenderAttachmentDescriptionInfo/" class="dropdown-item">FiniteRenderAttachmentDescriptionInfo</a>
</li>
            
<li>
    <a href="../../reference/types/render/FiniteRenderAttachmentRefInfo/" class="dropdown-item">FiniteRenderAttachmentRefInfo</a>
</li>
            
<li>
    <a href="../../reference/types/render/FiniteRenderFramebufferInfo/" class="dropdown-item">FiniteRenderFramebufferInfo</a>
</li>
            
<li>
    <a href="../../reference/types/render/FiniteRenderPassInfo/" class="dropdown-item">FiniteRenderRenderPassInfo</a>
</li>
            
<li>
    <a href="../../reference/types/render/FiniteRenderPipelineLayoutInfo/" class="dropdown-item">FiniteRenderPipelineLayoutInfo</a>
</li>
            
<li>
    <a href="../../reference/types/render/FiniteRenderQueueFamily/" class="dropdown-item">FiniteRenderQueueFamilies</a>
</li>
            
<li>
    <a href="../../reference/types/render/FiniteRenderShaderStageInfo/" class="dropdown-item">FiniteRenderShaderStageInfo</a>
</li>
            
<li>
    <a href="../../reference/types/render/FiniteRenderShaderStages/" class="dropdown-item">FiniteRenderShaderStages</a>
</li>
            
<li>
    <a href="../../reference/types/render/FiniteRenderSubpassDependencyInfo/" class="dropdown-item">FiniteRenderSubpassDependencyInfo</a>
</li>
            
<li>
    <a href="../../reference/types/render/FiniteRenderSubpassDescriptionInfo/" class="dropdown-item">FiniteRenderSubpassDescriptionInfo</a>
</li>
            
<li>
    <a href="../../reference/types/render/FiniteRenderSwapchainInfo/" class="dropdown-item">FiniteRenderSwapchainInfo</a>
</li>
            
<li>
    <a href="../../reference/types/render/FiniteRenderVertexInputInfo/" class="dropdown-item">FiniteRenderVertexInputInfo</a>
</li>
            
<li>
    <a href="../../reference/types/render/FiniteRenderViewportState/" class="dropdown-item">FiniteRenderViewportState</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    </ul>
                                </li>
                        </ul>

                    <ul class="nav navbar-nav ml-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                      <li class="nav-item">
                          <a href="https://github.com/Cubix-Dev/infinite-docs" class="nav-link">
                            <i class="fa-brands fa-github"></i> Edit on Github
                          </a>
                      </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#cube" class="nav-link">Cube</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#video-example" class="nav-link">Video Example</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="cube">Cube<a class="headerlink" href="#cube" title="Permanent link">*</a></h1>
<p>The Finite Cube Demo</p>
<div class="alert alert-info part text-info">
This demo was created with libfinite <b>v0.6.0</b>
</div>

<p>This demo shows off (mostly) everything libfinite can do at this time.
<pre class="highlight"><code class="language-c">/*
    Vulkan 3D Drawing with Libfinite SDK example
    Written by Gabriel Thompson &lt;gabriel.thomp@cubixdev.org&gt;
*/

#include &lt;finite/draw.h&gt;
#include &lt;finite/input.h&gt;
#include &lt;finite/render.h&gt;
#include &lt;finite/audio.h&gt;
#include &lt;finite/log.h&gt;
#include &lt;cglm/call.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#define GLM_FORCE_DEPTH_ZERO_TO_ONE


typedef struct Vertex Vertex;
typedef struct UniformBufferObject UniformBufferObject;

struct Vertex {
    vec3 pos;
    vec3 color;
    vec2 textureCoord;
};


/*
    Vulkan expects the data in your structure to be aligned in memory in a specific way, for example:

    Scalars have to be aligned by N (= 4 bytes given 32 bit floats).
    A vec2 must be aligned by 2N (= 8 bytes)
    A vec3 or vec4 must be aligned by 4N (= 16 bytes)
    A nested structure must be aligned by the base alignment of its members rounded up to a multiple of 16.
    A mat4 matrix must have the same alignment as a vec4.

    You can find the full list of alignment requirements in the specification.
    https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-resources-layout
*/
struct UniformBufferObject {
    mat4 model;
    mat4 view;
    mat4 proj;
};

// in this example we've made the vertex data a global which is generally not a good idea.
const Vertex vertices[] = {
    // Front face
    {{-0.5f, -0.5f,  0.5f},  {1.0f, 0.0f, 0.0f}, {0.0f, 0.0f}}, // 0
    {{0.5f, -0.5f,  0.5f},   {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f}}, // 1
    {{0.5f,  0.5f,  0.5f},   {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f}}, // 2
    {{-0.5f,  0.5f,  0.5f},  {1.0f, 1.0f, 1.0f}, {0.0f, 1.0f}}, // 3

    // Back face
    {{0.5f, -0.5f, -0.5f},   {1.0f, 0.0f, 0.0f}, {0.0f, 0.0f}}, // 4
    {{-0.5f, -0.5f, -0.5f},  {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f}}, // 5
    {{-0.5f,  0.5f, -0.5f},  {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f}}, // 6
    {{0.5f,  0.5f, -0.5f},   {1.0f, 1.0f, 1.0f}, {0.0f, 1.0f}}, // 7

    // Left face
    {{-0.5f, -0.5f, -0.5f},  {1.0f, 0.0f, 0.0f}, {0.0f, 0.0f}}, // 8
    {{-0.5f, -0.5f,  0.5f},  {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f}}, // 9
    {{-0.5f,  0.5f,  0.5f},  {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f}}, //10
    {{-0.5f,  0.5f, -0.5f},  {1.0f, 1.0f, 1.0f}, {0.0f, 1.0f}}, //11

    // Right face
    {{0.5f, -0.5f,  0.5f},   {1.0f, 0.0f, 0.0f}, {0.0f, 0.0f}}, //12
    {{0.5f, -0.5f, -0.5f},   {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f}}, //13
    {{0.5f,  0.5f, -0.5f},   {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f}}, //14
    {{0.5f,  0.5f,  0.5f},   {1.0f, 1.0f, 1.0f}, {0.0f, 1.0f}}, //15

    // Top face
    {{-0.5f,  0.5f,  0.5f},  {1.0f, 0.0f, 0.0f}, {0.0f, 0.0f}}, //16
    {{0.5f,  0.5f,  0.5f},   {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f}}, //17
    {{0.5f,  0.5f, -0.5f},   {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f}}, //18
    {{-0.5f,  0.5f, -0.5f},  {1.0f, 1.0f, 1.0f}, {0.0f, 1.0f}}, //19

    // Bottom face
    {{-0.5f, -0.5f, -0.5f},  {1.0f, 0.0f, 0.0f}, {0.0f, 0.0f}}, //20
    {{0.5f, -0.5f, -0.5f},   {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f}}, //21
    {{0.5f, -0.5f,  0.5f},   {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f}}, //22
    {{-0.5f, -0.5f,  0.5f},  {1.0f, 1.0f, 1.0f}, {0.0f, 1.0f}}, //23
};

// ! All indice data must be in uint32 format/
const uint16_t indexData[] = {
    0,1,2,2,3,0,
    4,5,6,6,7,4,
    8,9,10,10,11,8,
    12,13,14,14,15,12,
    16,17,18,18,19,16,
    20,21,22,22,23,20
};

// size of vertices
int _verts = 24;
int _indexes = 36;

bool canSpin = false;

FinitePlaybackDevice *dev;

void *playMusic(void *data) {
    // audio demo for funny
    char *jingle = "/home/ship/Documents/jingle3.wav";
    dev = finite_audio_device_init();

    finite_audio_get_audio_params(jingle, dev);
    // print out the audio duration
    finite_audio_get_audio_duration(dev);

    // use params to init audio
    finite_audio_init_audio(dev, jingle, false);

    // audio is made so now play

    finite_audio_play(dev);
    FINITE_LOG("Done");
    finite_audio_cleanup(dev);
    sleep(1);

    dev = finite_audio_device_init();

    if (!dev) {
        printf("Device: %p is unusable", dev);
        exit(EXIT_FAILURE);
    }

    // reset dev params
    snd_pcm_hw_free(dev-&gt;device);
    dev = finite_audio_device_init();
    char *audio = "/home/ship/Downloads/Announcement - rangerbts.mp3";

    finite_audio_get_audio_params(audio, dev);
    // print out the audio duration
    finite_audio_get_audio_duration(dev);
    FINITE_LOG("Preparing for playback");
    // use params to init audio
    finite_audio_init_audio(dev, audio, false);
    FINITE_LOG("Preparing for playback2");
    canSpin = true;
    finite_audio_play(dev);

    // clean up when finished
    finite_audio_cleanup(dev);
    return (void *) 1;
}

void updateUniformBuffer(FiniteRender *render, uint32_t current) {
    static struct timespec startTime = {0};
    struct timespec currentTime;
    double time;

    if (canSpin) {
        if (startTime.tv_sec == 0 &amp;&amp; startTime.tv_nsec == 0) {
            // First call, initialize startTime
            clock_gettime(CLOCK_MONOTONIC, &amp;startTime);
        }

        clock_gettime(CLOCK_MONOTONIC, &amp;currentTime);

        time = (currentTime.tv_sec - startTime.tv_sec) + (currentTime.tv_nsec - startTime.tv_nsec) / 1e9;
    } else {
        time = 0;
    }

    UniformBufferObject ubo = {0};

    vec3 axis = { 0.0f, 0.0f, 1.0f };

    float angle = glm_rad(-90.0f) * time;

    vec3 eye = {2.0f, 2.0f, 2.0f};
    vec3 center = {0.0f, 0.0f, 0.0f};
    vec3 up = {0.0f, 0.0f, 1.0f};

    float fov = glm_rad(45.0f);
    float aspect = render-&gt;vk_extent.width / (float) render-&gt;vk_extent.height;
    float near = 0.1f;
    float far = 10.0f;

    glm_mat4_identity(ubo.model);
    glm_rotate(ubo.model, angle, axis);

    glm_mat4_identity(ubo.view);
    glm_lookat(eye, center, up, ubo.view);

    glm_mat4_identity(ubo.proj);
    glm_perspective(fov, aspect, near, far, ubo.proj);

    ubo.proj[1][1] *= -1;

    // printf("Adr: %p (%d)\n", render-&gt;uniformData[render-&gt;_currentFrame], render-&gt;_currentFrame);

    // map this to the current buffer
    memcpy(render-&gt;uniformData[render-&gt;_currentFrame], &amp;ubo, sizeof(UniformBufferObject));    
}

int main() {
    finite_log_init(stdout, LOG_LEVEL_DEBUG, true);
    FINITE_LOG("Starting...");

    // Create a window to draw the triangle
    FiniteShell *myShell = finite_shell_init("wayland-0");
    finite_window_init(myShell);

    // ! In order for your game to be Infinite compliant you can not resize the window. Here I resize it to make execution easier
    FiniteWindowInfo *det = myShell-&gt;details;
    int32_t true_width = det-&gt;width;
    int32_t true_height = det-&gt;height;

    finite_window_size_set(myShell, ((true_width * 20) / 100), ((true_height *25) / 100), ((true_width * 60) / 100), ((true_height *50) / 100));

    // initialize the renderer
    // ? Passing NULL does NOT set zero extensions. It just tells libfinite to use the default ones
    FiniteRender *render = finite_render_init(myShell, NULL, NULL, 0, 0);
    render-&gt;withDepth = true; // enable the depth related features

    finite_render_create_physical_device(render);

    // ensure we family queues
    uint32_t uniqueQueueFamilies[2];
    FiniteRenderQueueFamilies fIndex = finite_render_find_queue_families(render-&gt;vk_pDevice, render-&gt;vk_surface);
    // dedup
    if (fIndex.graphicsFamily != fIndex.presentFamily &amp;&amp; fIndex.presentFamily &gt;= 0 ) {
        uniqueQueueFamilies[0] = fIndex.graphicsFamily;
        uniqueQueueFamilies[1] = fIndex.presentFamily;
    } else {
        uniqueQueueFamilies[0] = fIndex.graphicsFamily;
    }

    if (fIndex.graphicsFamily &lt; 0) {
        FINITE_LOG_ERROR("Unable to find graphics queue group."); // with error you have return/exit manually
        return 1;
    }

    // create the device
    // ? Similarlly to finite_render_init NULL extensions will create the default extensions
    finite_render_create_device(render, fIndex, uniqueQueueFamilies, NULL, 0);

    // now get swapchain details
    FiniteRenderSwapchainInfo info = finite_render_get_swapchain_info(render, render-&gt;vk_pDevice);
    finite_render_get_best_format(render, info.forms, info._forms);
    finite_render_get_best_present_mode(render, info.modes, info._modes);
    finite_render_get_best_extent(render, &amp;info.caps, myShell);

    // use those details to make a swapchain
    finite_render_create_swapchain(render, info);

    //create the swapchain images
    finite_render_create_swapchain_images(render);

    // create a render pass
    FiniteRenderAttachmentDescriptionInfo colorInfo = {
        .format = render-&gt;vk_imageForm.format,
        .samples = VK_SAMPLE_COUNT_1_BIT,
        .loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR,
        .storeOp = VK_ATTACHMENT_STORE_OP_STORE,
        .stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
        .stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE,
        .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED,
        .finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR
    };

    FiniteRenderAttachmentDescriptionInfo depthInfo = {
        .format = VK_FORMAT_D32_SFLOAT,
        .samples = VK_SAMPLE_COUNT_1_BIT,
        .loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR,
        .storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE,
        .stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
        .stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE,
        .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED,
        .finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL
    };

    FiniteRenderAttachmentRefInfo colorRefInfo = {
        .type = FINITE_ATTACHMENT_DESCRIPTOR_COLOR,
        ._attachment = 0,
        .layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL
    };

    FiniteRenderAttachmentRefInfo depthRefInfo = {
        .type = FINITE_ATTACHMENT_DESCRIPTOR_DEPTH,
        ._attachment = 1,
        .layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL
    };

    FiniteRenderSubpassDescriptionInfo subpass_desc_info = {
        .pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS,
        ._colorAttachments = 1
    };

    FiniteRenderSubpassDependencyInfo subpass_dep_info = {
        .srcSubpass = VK_SUBPASS_EXTERNAL,
        .destSubpass = 0,
        .srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
        .destStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
        .srcAccessMask = 0,
        .destAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
        .dependencyFlags = 0
    };

    FiniteRenderSubpassDependencyInfo *subpassDep_infos[1] = {&amp;subpass_dep_info};
    FiniteRenderSubpassDescriptionInfo *subpassDesc_infos[1] = {&amp;subpass_desc_info};
    FiniteRenderAttachmentRefInfo *ref_infos[2] = {&amp;colorRefInfo, &amp;depthRefInfo};
    FiniteRenderAttachmentDescriptionInfo *attachment_infos[2] = {&amp;colorInfo, &amp;depthInfo};

    FiniteRenderRenderPassInfo render_pass_info = {
        .flags = 0,
        ._attachments = 2,
        ._deps = 1,
        ._refs = 2,
        ._subpasses = 1
    };

    finite_render_create_render_pass(render, attachment_infos, ref_infos, subpassDesc_infos, subpassDep_infos, &amp;render_pass_info);

    // load shaders
    uint32_t vertSize;
    char *vertCode = finite_render_get_shader_code("vert.spv", &amp;vertSize);
    bool success = finite_render_get_shader_module(render, vertCode, vertSize);

    if (!success) {
        FINITE_LOG_ERROR("Unable to create Vertex Shader Module");
        return -1;
    }

    uint32_t fragSize;
    char *fragCode = finite_render_get_shader_code("frag.spv", &amp;fragSize);
    success = finite_render_get_shader_module(render, fragCode, fragSize);

    if (!success) {
        printf("Unable to create Fragment Shader Module");
        return -1;
    }

    // create descriptor
    FiniteRenderDescriptorSetLayout uniformLayout = {
        .binding = 0,
        ._descriptors = 1,
        .type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
        .flags = VK_SHADER_STAGE_VERTEX_BIT,
        .samplers = NULL
    };

    FiniteRenderDescriptorSetLayout imageLayout = {
        .binding = 1,
        ._descriptors = 1,
        .type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
        .flags = VK_SHADER_STAGE_FRAGMENT_BIT,
        .samplers = NULL
    };

    FiniteRenderDescriptorSetLayout *bindInfos[2] = {&amp;uniformLayout, &amp;imageLayout};

    finite_render_create_descriptor_layout(render, bindInfos, 2);

    FiniteRenderPipelineLayoutInfo pipe_info = {
        .flags = 0,
        ._pushRange = 0 ,
        .pushRange = VK_NULL_HANDLE,
        ._setConsts = 1,
        .setConsts = &amp;render-&gt;vk_descriptorLayout
    };

    finite_render_create_pipeline_layout(render, &amp;pipe_info);

    // add shader modules to render

    FiniteRenderShaderStageInfo vertStage = {
        .flags = 0,
        .stage = FINITE_SHADER_TYPE_VERTEX,
        .shader = render-&gt;modules[0],
        .name = "main",
        .specializationInfo = VK_NULL_HANDLE
    };

    finite_render_add_shader_stage(render, &amp;vertStage);

    FiniteRenderShaderStageInfo fragStage = {
        .flags = 0,
        .stage = FINITE_SHADER_TYPE_FRAGMENT,
        .shader = render-&gt;modules[1],
        .name = "main",
        .specializationInfo = VK_NULL_HANDLE
    };

    finite_render_add_shader_stage(render, &amp;fragStage);

    // now use custom bindings
    VkVertexInputBindingDescription binding = {
        .binding = 0,
        .stride = sizeof(Vertex),
        .inputRate = VK_VERTEX_INPUT_RATE_VERTEX
    };

    VkVertexInputAttributeDescription attribe[] = {
        {
            .binding = 0,
            .location = 0,
            .format = VK_FORMAT_R32G32B32_SFLOAT,
            .offset = offsetof(Vertex, pos)
        },

        {
            .binding = 0,
            .location = 1,
            .format = VK_FORMAT_R32G32B32_SFLOAT,
            .offset = offsetof(Vertex, color)
        },
        {
            .binding = 0,
            .location = 2,
            .format = VK_FORMAT_R32G32_SFLOAT,
            .offset = offsetof(Vertex, textureCoord)
        }
    };

    // create generic vulkan objects
    FiniteRenderVertexInputInfo vertex = {
        .flags = 0,
        ._vertexBindings = 1,
        ._vertexAtributes = 3,
        .vertexAttributeDescriptions = attribe,
        .vertexBindingDescriptions = &amp;binding
    };

    FiniteRenderAssemblyInfo assemble = {
        .flags = 0,
        .topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
        .primitiveRestartEnable = false
    };

    VkViewport viewport = {
        .x = 0,
        .y = 0,
        .width = render-&gt;vk_extent.width,
        .height = render-&gt;vk_extent.height,
        .minDepth = 0.0f,
        .maxDepth = 1.0f
    };

    VkOffset2D off = {
        .x = 0,
        .y = 0
    };

    VkRect2D scissor = {
        .extent = render-&gt;vk_extent,
        .offset = off
    };

    FiniteRenderViewportState port = {
        .flags = 0,
        ._viewports = 1,
        ._scissors = 1,
        .viewports = &amp;viewport,
        .scissors = &amp;scissor,
    };

    FiniteRenderRasterState raster = {
        .depthClampEnable = false,
        .rasterizerDiscardEnable = false,
        .polygonMode = VK_POLYGON_MODE_FILL,
        .cullMode = VK_CULL_MODE_BACK_BIT,
        .frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE,
        .depthBiasEnable = false,
        .depthBiasConstantFactor = 0.0f,
        .depthBiasClamp = 0.0f,
        .depthBiasSlopeFactor = 1.0f,
        .lineWidth = 1.0f
    };

    FiniteRenderMultisampleStateInfo samples = {
        .flags = 0,
        .rasterizationSamples = VK_SAMPLE_COUNT_1_BIT,
        .sampleShadingEnable = false,
        .minSampleShading = 1.0f,
        .sampleMask = VK_NULL_HANDLE,
        .alphaToCoverageEnable = false,
        .alphaToOneEnable = false 
    };

    FiniteRenderColorAttachmentInfo blend_att = {
        .blendEnable = false,
        .srcColorBlendFactor = VK_BLEND_FACTOR_ONE,
        .dstColorBlendFactor = VK_BLEND_FACTOR_ZERO,
        .colorBlendOp = VK_BLEND_OP_ADD,
        .srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE,
        .dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO,
        .alphaBlendOp = VK_BLEND_OP_ADD,
        .colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT
    };

    FiniteRenderColorBlendInfo blend_info = {
        .flags = 0,
        .logicOpEnable = false,
        .logicOp = VK_LOGIC_OP_COPY,
        .blendConstants = {0.0f, 0.0f, 0.0f, 0.0f}
    };

    VkDynamicState dynamicStates[] = {
        VK_DYNAMIC_STATE_VIEWPORT,
        VK_DYNAMIC_STATE_SCISSOR
    };

    VkPipelineDynamicStateCreateInfo dynamicStateInfo = {
        .sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,
        .dynamicStateCount = 2,
        .pDynamicStates = dynamicStates,
    };

    // now create the graphics pipline

    VkPipelineVertexInputStateCreateInfo input_state_info = finite_render_create_vertex_input(render, &amp;vertex);
    VkPipelineInputAssemblyStateCreateInfo assemble_info = finite_render_create_assembly_state(render, &amp;assemble);
    VkPipelineViewportStateCreateInfo viewport_info = finite_render_create_viewport_state(render, &amp;port);
    VkPipelineRasterizationStateCreateInfo raster_info = finite_render_create_raster_info(render, &amp;raster);
    VkPipelineMultisampleStateCreateInfo sample_info = finite_render_create_multisample_info(render, &amp;samples);
    VkPipelineColorBlendAttachmentState blend_att_state_info = finite_render_create_color_blend_attachment(&amp;blend_att);
    VkPipelineColorBlendStateCreateInfo blend_state_info = finite_render_create_color_blend_state(render, &amp;blend_att_state_info, &amp;blend_info);

    finite_render_create_graphics_pipeline(render, 0, &amp;input_state_info, &amp;assemble_info, VK_NULL_HANDLE, &amp;viewport_info, &amp;raster_info, &amp;sample_info, &amp;blend_state_info, &amp;dynamicStateInfo);

    // now create the command buffer and autocreate a pool
    // ? for a custom pool, set autocreate to false
    finite_render_create_command_buffer(render, true, true, 1);

    FiniteRenderImageInfo depthImageInfo = {
        .format = VK_FORMAT_D32_SFLOAT,
        .extent = {
            .width = render-&gt;vk_extent.width,
            .height = render-&gt;vk_extent.height,
            .depth = 1,
        },
        ._mipLevels = 1,
        .tiling = VK_IMAGE_TILING_OPTIMAL,
        .useFlags = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,
        ._samples  = VK_SAMPLE_COUNT_1_BIT,
        .sharing = VK_SHARING_MODE_EXCLUSIVE,
        .imageType = VK_IMAGE_TYPE_2D,
        ._layers = 1,
        .layout = VK_IMAGE_LAYOUT_UNDEFINED
    };

    FiniteRenderMemAllocInfo depth_mem_alloc_info = {
        .flags = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT
    };

    FiniteRenderImage *depthImage = finite_render_create_image(render, &amp;depthImageInfo, &amp;depth_mem_alloc_info);

    FiniteRenderImageViewInfo depth_info = {
        .image = depthImage-&gt;textureImage,
        .type = VK_IMAGE_VIEW_TYPE_2D,
        .format = VK_FORMAT_D32_SFLOAT,
        .subRange = {
            .aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT,
            .baseMipLevel = 0,
            .levelCount = 1,
            .baseArrayLayer = 0,
            .layerCount = 1
        }
    };

    finite_render_create_view(render, depthImage, &amp;depth_info);

        FiniteRenderImageBarrierInfo depth_wall_info = {
        .old = VK_IMAGE_LAYOUT_UNDEFINED,
        .new = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
        .srcfIndex = VK_QUEUE_FAMILY_IGNORED,
        .destfIndex = VK_QUEUE_FAMILY_IGNORED,
        .image = depthImage-&gt;textureImage,
        .subRange = {
            .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
            .baseMipLevel = 0,
            .levelCount = 1,
            .baseArrayLayer = 0,
            .layerCount = 1
        },
        .srcFlags = 0,
        .destFlags = 0
    };

    FiniteRenderPipelineDirections depth_pipeline_directions = {
        .srcFlags = 0,
        .destFlags = 0,
        .depFlags = 0
    };

    finite_render_transition_image_layout(render, &amp;depth_wall_info, VK_FORMAT_D32_SFLOAT, &amp;depth_pipeline_directions);

    VkImageView att_views[2] = {
        VK_NULL_HANDLE, // this is a very odd but passing way to refer to the render.vk_view
        depthImage-&gt;textureImageView
    };

    FiniteRenderFramebufferInfo framebuffer_infos = {
        ._attachments = 2,
        .attachments = att_views,
        .width = render-&gt;vk_extent.width,
        .height = render-&gt;vk_extent.height,
        .layers = 1,
    };

    finite_render_create_framebuffers(render, &amp;framebuffer_infos);

    FiniteRenderTextureInfo texture_info;
    // populate texture_info
    finite_render_create_texture("texture.png", &amp;texture_info, true);
    // create a staging buffer
    FiniteRenderReturnBuffer repoint;

    FiniteRenderBufferInfo texture_buffer_info = {
        .size = texture_info.size,
        .useFlags = VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
        .sharing = VK_SHARING_MODE_EXCLUSIVE
    };

    FiniteRenderMemAllocInfo texture_mem_alloc_info = {
        .flags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT
    };

    // creates a non-replicated buffer (will always write to a FiniteRenderReturnBuffer)
    bool suc = finite_render_create_generic_buffer(render, &amp;texture_buffer_info, &amp;texture_mem_alloc_info, texture_info.size, &amp;repoint);
    if (!suc) {
        exit(EXIT_FAILURE);
    }

    void *image_data;
    vkMapMemory(render-&gt;vk_device, repoint.mem, 0, texture_buffer_info.size, 0, &amp;image_data);
    memcpy(image_data, texture_info.pixels, (size_t) texture_info.size);
    vkUnmapMemory(render-&gt;vk_device, repoint.mem);

    // free the texture pixels
    finite_render_destroy_pixels(&amp;texture_info);

    FiniteRenderImageInfo image_info = {
        .extent = {
            .width = texture_info.width,
            .height = texture_info.height,
            .depth = 1,
        },
        .imageType = VK_IMAGE_TYPE_2D,
        ._mipLevels = 1,
        ._layers = 1,
        .format = VK_FORMAT_R8G8B8A8_SRGB,
        .tiling = VK_IMAGE_TILING_OPTIMAL,
        .layout = VK_IMAGE_LAYOUT_UNDEFINED,
        .useFlags = VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT,
        ._samples = VK_SAMPLE_COUNT_1_BIT,
        .sharing = VK_SHARING_MODE_EXCLUSIVE
    };

    texture_mem_alloc_info.flags = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;

    FiniteRenderImage *image = finite_render_create_image(render, &amp;image_info, &amp;texture_mem_alloc_info);

    FiniteRenderImageBarrierInfo wall_info = {
        .old = VK_IMAGE_LAYOUT_UNDEFINED,
        .new = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
        .srcfIndex = VK_QUEUE_FAMILY_IGNORED,
        .destfIndex = VK_QUEUE_FAMILY_IGNORED,
        .image = image-&gt;textureImage,
        .subRange = {
            .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
            .baseMipLevel = 0,
            .levelCount = 1,
            .baseArrayLayer = 0,
            .layerCount = 1
        },
        .srcFlags = 0,
        .destFlags = 0
    };

    FiniteRenderPipelineDirections pipeline_directions = {
        .srcFlags = 0,
        .destFlags = 0,
        .depFlags = 0
    };

    FiniteRenderImageCopyDirections copy_directions = {
        .offset = 0,
        .rowLength = 0,
        .height = 0,
        .subLayers = {
            .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
            .mipLevel = 0,
            .baseArrayLayer = 0,
            .layerCount = 1
        },
        .imageOffset = {0,0,0},
        .extent = {
            .width = texture_info.width,
            .height = texture_info.height,
            .depth = 1,
        },
        .destLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
        .buffer = repoint.buf,
        .image = image-&gt;textureImage
    };

    finite_render_transition_image_layout(render, &amp;wall_info, VK_FORMAT_R8G8B8A8_SRGB, &amp;pipeline_directions);
    finite_render_copy_buffer_to_image(render, &amp;copy_directions);

    wall_info.old = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
    wall_info.new = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    finite_render_transition_image_layout(render, &amp;wall_info, VK_FORMAT_R8G8B8A8_SRGB, &amp;pipeline_directions);

    FiniteRenderImageViewInfo view_2_info = {
        .image = image-&gt;textureImage,
        .type = VK_IMAGE_VIEW_TYPE_2D,
        .format = VK_FORMAT_R8G8B8A8_SRGB,
        .subRange = {
            .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
            .baseMipLevel = 0,
            .levelCount = 1,
            .baseArrayLayer = 0,
            .layerCount = 1
        }
    };

    FiniteRenderTextureSamplerInfo sampler_info = {
        .magFilter = VK_FILTER_LINEAR,
        .minFilter = VK_FILTER_LINEAR,
        .addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT,
        .addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT,
        .addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT,
        .anisotropyEnable = true,
        .borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK,
        .unnormalizedCoordinates = false,
        .compareEnable = false,
        .compareOp = VK_COMPARE_OP_ALWAYS,
        .mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR,
        .mipLodBias = 0.0f,
        .minLod = 0.0f,
        .maxLod = 0.0f
    };

    finite_render_create_view(render, image, &amp;view_2_info);

    finite_render_create_sampler(render, image, &amp;sampler_info);






    // this is the total amount of NEW SPACE needed to create the buffer
    // ? DO NOT try to calculate the total size of the buffer to create new space as it will result in errors.
    FiniteRenderBufferInfo vertex_buffer_info = {
        .size = (sizeof(Vertex) * _verts) + (sizeof(uint16_t) * _indexes),
        .useFlags = VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
        .sharing = VK_SHARING_MODE_EXCLUSIVE
    };

    FiniteRenderMemAllocInfo mem_alloc_info = {
        .flags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT
    };

    bool prog;
    FiniteRenderReturnBuffer point;
    prog = finite_render_create_vertex_buffer(render, &amp;vertex_buffer_info, &amp;mem_alloc_info, sizeof(Vertex) * _verts, &amp;point);
    if (!prog) {
        exit(EXIT_FAILURE);
    }

    // as a dev you must manually map the vertex buffer when using custom vertex
    void *data;
    vkMapMemory(render-&gt;vk_device, point.mem, 0, vertex_buffer_info.size, 0, &amp;data);
    memcpy(data, vertices, (size_t) (sizeof(Vertex) * _verts));
    // ! Make sure to offset the data so memcpy doesnt overwrite
    void *index = (char *)data + sizeof(Vertex) *_verts;
    memcpy(index, indexData, (size_t) (sizeof(uint16_t) * _indexes));
    vkUnmapMemory(render-&gt;vk_device, point.mem);

    vertex_buffer_info.useFlags = VK_BUFFER_USAGE_TRANSFER_DST_BIT;
    mem_alloc_info.flags = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;

    prog = finite_render_create_vertex_buffer(render, &amp;vertex_buffer_info, &amp;mem_alloc_info, sizeof(Vertex) * _verts, NULL);
    if (!prog) {
        exit(EXIT_FAILURE);
    }

    finite_render_copy_buffer(render, point.buf, render-&gt;vk_vertexBuf, (point.vertexSize + point.indexSize));
    // add count data
    render-&gt;buffers[0]._indices = true;
    render-&gt;buffers[0].indexCount = _indexes;
    render-&gt;buffers[0].vertexCount = _verts;

    FINITE_LOG("Rendering object %p: vtx=%u, idx=%u, vtxOffset=%lu (%lu), idxOffset=%lu (%lu)", render-&gt;buffers, render-&gt;buffers[0].vertexCount, render-&gt;buffers[0].indexCount, render-&gt;buffers[0].vertexOffset,(sizeof(Vertex) * _verts), render-&gt;buffers[0].indexOffset,  (sizeof(uint32_t) * _indexes));

    FiniteRenderBufferInfo uniform_buffer_info = {
        .size = sizeof(UniformBufferObject),
        .sharing = VK_SHARING_MODE_EXCLUSIVE
    };

    FiniteRenderMemAllocInfo uniform_alloc_info = {
        .flags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT
    };

    finite_render_create_uniform_buffer(render, &amp;uniform_buffer_info, &amp;uniform_alloc_info);


    FiniteRenderDescriptorPoolInfo imageDescriptor = {
        .type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
    };


    FiniteRenderDescriptorPoolInfo *desc_pool_infos[2] = {NULL, &amp;imageDescriptor};

    finite_render_create_descriptor_pool(render, desc_pool_infos, true, 2);

    for (int i = 0; i &lt; MAX_FRAMES_IN_FLIGHT; i++) {
        FiniteRenderWriteSetInfo buffer_write_info = {
                .dstSet = render-&gt;vk_descriptor[i],
                .dstBinding = 0,
                .dstArrayElement = 0,
                .descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER
        };

        FiniteRenderWriteSetInfo image_write_info = {
            .dstSet = render-&gt;vk_descriptor[i],
            .dstBinding = 1,
            .dstArrayElement = 0,
            .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
        };

        FiniteRenderWriteSetInfo *write_infos[2] = {&amp;buffer_write_info, &amp;image_write_info};

        FiniteRenderDescriptorInfo desc_info = {
            .type = FINITE_DESCRIPTOR_MULTI,
            .buffer = render-&gt;vk_uniformBuf[i],
            .buffer_offset = 0,
            .buffer_range = sizeof(UniformBufferObject),
            .image_layout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
            .image_view = image-&gt;textureImageView,
            .image_sampler = image-&gt;textureSampler
        };


        finite_render_write_to_descriptor(render, write_infos, &amp;desc_info, 2);
    }

    for (int i = 0; i &lt; MAX_FRAMES_IN_FLIGHT; i++) {
        // create two semaphores and one fence
        finite_render_create_semaphore(render); //images available
        finite_render_create_semaphore(render); // renderFinished
        finite_render_create_fence(render, VK_FENCE_CREATE_SIGNALED_BIT);
    }

    // * use pending state!!!

    int state = wl_display_dispatch_pending(myShell-&gt;display);
    FINITE_LOG("Success! Dispatch state: %d", state);

    // multithread here
    pthread_t id;
    pthread_create(&amp;id, NULL, playMusic, &amp;dev);

    // keyboard demo for additional funny
    // FiniteKeyboard *kbd = finite_input_keyboard_init(myShell-&gt;display);

    // FiniteKey xKey = finite_key_from_string("X");
    // if (!finite_key_valid(xKey)) {
    //     printf("Unable to poll NULL key");
    //     exit(EXIT_FAILURE);
    // }

    // create wayland frame loop
    while (wl_display_dispatch_pending(myShell-&gt;display) != -1) {
        // poll for input
        // finite_input_poll_keys(kbd, myShell);

        // // handle input
        // if (finite_key_pressed(xKey, kbd)) {
        //     printf("Attempting to pause\n");
        //     finite_audio_pause(dev);
        // }

        // with framesInFlight we need to offset where the indexes are. For reference:
        // 0 -&gt; imagesAvailable
        // 1 -&gt; renderFinished
        // so offset is i + (2 * currentFrame) with since its two items.
        render-&gt;_currentFrame = (render-&gt;_currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;


        int currentFence = 0 + (1 * render-&gt;_currentFrame);
        int currentSignal = 0 + (2 * render-&gt;_currentFrame);

        // printf("Current Fence: %d (%p) \nCurrent Signal: %d (%p)\n", currentFence, render-&gt;fences[currentFence], currentSignal, render-&gt;signals[currentSignal]);

        // handle custom rendering here
        vkWaitForFences(render-&gt;vk_device, 1, &amp;render-&gt;fences[currentFence], VK_TRUE, UINT64_MAX);

        vkResetFences(render-&gt;vk_device, 1, &amp;render-&gt;fences[currentFence]);
        // printf("Current Fence %d (%p) was reset.\nCurrent Signal: %d (%p)\n", currentFence, render-&gt;fences[currentFence], currentSignal, render-&gt;signals[currentSignal]);

        uint32_t index;
        vkAcquireNextImageKHR(render-&gt;vk_device, render-&gt;vk_swapchain, UINT64_MAX, render-&gt;signals[currentSignal], VK_NULL_HANDLE, &amp;index);

        vkResetCommandBuffer(render-&gt;vk_buffer[render-&gt;_currentFrame], 0);
        // printf("recording\n");
        finite_render_record_command_buffer(render, index);
        // printf("Attempting to rotate\n");
        updateUniformBuffer(render, index);
        // printf("Rotate finished\n");
        VkPipelineStageFlags waitStage = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;

        FiniteRenderSubmitInfo submit_info = {
            ._waitSemaphores = 1,
            .waitSemaphores = &amp;render-&gt;signals[currentSignal],
            .waitDstStageMask = &amp;waitStage,
            ._commandBuffs = 1,
            .commandBuffs = &amp;render-&gt;vk_buffer[render-&gt;_currentFrame],
            ._signalSemaphores = 1,
            .signalSemaphores = &amp;render-&gt;signals[currentSignal + 1]
        };

        // printf("submitting\n");
        // the safeExit param determines whether we want to have finite_render_submit_frame cleanup and exit on failure
        finite_render_submit_frame(render, &amp;submit_info, currentFence, false);


        VkSwapchainKHR swapchains[] = {render-&gt;vk_swapchain};

        FiniteRenderPresentInfo present_info  = {
            ._waitSemaphores = 1,    
            .waitSemaphores = &amp;render-&gt;signals[currentSignal + 1],
            ._swapchains = 1,
            .swapchains = swapchains,
            .imageIndices = &amp;index,
            .results = NULL
        };

        // printf("presenting\n");
        finite_render_present_frame(render, &amp;present_info, false);
        // render-&gt;_currentFrame = (render-&gt;_currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;
        // printf("Current Frame: %d\n", render-&gt;_currentFrame);
    }
    vkDeviceWaitIdle(render-&gt;vk_device);
    FiniteRenderImage *imgs = {image};
    finite_render_cleanup_textures(render, imgs, 1);
    finite_render_cleanup(render);
}</code></pre></p>
<h2 id="video-example">Video Example<a class="headerlink" href="#video-example" title="Permanent link">*</a></h2>
<video width="480" height="360" controls>
  <source src="../finite_demo.mp4" type="video/mp4">
</video></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>Copyright &copy; 2025 Cubix Entertainment LLC | All rights reserved. <br>Copyright &copy; 2014 <a href="https://twitter.com/_tomchristie">Tom Christie</a>, <a href="http://www.dougalmatthews.com/">Dougal Matthews</a>.</p>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js"></script>
        <script src="../../search/main.js"></script>

        <div class="modal bg-dark-blur" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn border-0" data-bs-dismiss="modal" aria-label="Close">X</button>
            </div>
            <div class="modal-body">
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
