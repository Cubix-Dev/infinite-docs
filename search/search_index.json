{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Infinite SDK * \u2753 Documentation for v0.6.0 Welcome to the Infinite Developer Family! I'm so glad you or your project manager has decided to bring your project to Infinite. This documenation page will provide some information on how to use the Infinite API and how to build an Infinite Compliant game. Project Goals * The objective of Infinite Library is to create an abstractable, simple and lightweight development library for Infinite Game Developers that handles the complexities of interacting with the console behind simple, easy to understand functions while still giving developers freedom of choice to implement their own versions of these functions. As a developer, you can easily mix and match the implementation of features provided by the Infinite SDK and your own implementations to create a virtually seamless transition to the Infinite hardware. Getting Started * \u2753 The Infinite Library is intended to be used on a Linux based system. Prerequisites * \ud83d\udd38 cglm - A C based Graphics Math library \ud83d\udd38 Wayland - The window compositing protocol. \ud83d\udd38 Wayland Protocols - Additional Non Standard features for Wayland. (v1.24 or higher) \ud83d\udd38 Cairo - Graphics Library for drawing data to buffers. \ud83d\udd38 Vulkan - An explicit graphical libary that gives users the full control over the rendering process. \ud83d\udd38 xkbcommon - Keymap library. \ud83d\udd38 libevdev - evdev device library \ud83d\udd38 sndfile - C library for reading and writing audio data \ud83d\udd38 ALSA - The Advanced Linux Sound Architecture \ud83d\udd38 Meson - The Meson Build System \ud83d\udea7 Building * meson setup build --prefix=/usr sudo ninja -C build install Once you're ready to start building your first project head over to the Getting Started documentation to learm some basic tips and tricks on how to start using the Infinite Library. \ud83d\udcd6 License * This project is intended to be open source to members of the Infinite Developer Environment. As a developer for Infinite Hardware you are free to edit, change or otherwise modify this project with the intention of contributing to the improve of the Infinte Developer tools. You may not however redistribute or resell any version of this project without the express written consent of Cubix Entertainment LLC.","title":"Home"},{"location":"#infinite-sdk","text":"\u2753 Documentation for v0.6.0 Welcome to the Infinite Developer Family! I'm so glad you or your project manager has decided to bring your project to Infinite. This documenation page will provide some information on how to use the Infinite API and how to build an Infinite Compliant game.","title":"Infinite SDK"},{"location":"#project-goals","text":"The objective of Infinite Library is to create an abstractable, simple and lightweight development library for Infinite Game Developers that handles the complexities of interacting with the console behind simple, easy to understand functions while still giving developers freedom of choice to implement their own versions of these functions. As a developer, you can easily mix and match the implementation of features provided by the Infinite SDK and your own implementations to create a virtually seamless transition to the Infinite hardware.","title":"Project Goals"},{"location":"#getting-started","text":"\u2753 The Infinite Library is intended to be used on a Linux based system.","title":"Getting Started"},{"location":"#prerequisites","text":"\ud83d\udd38 cglm - A C based Graphics Math library \ud83d\udd38 Wayland - The window compositing protocol. \ud83d\udd38 Wayland Protocols - Additional Non Standard features for Wayland. (v1.24 or higher) \ud83d\udd38 Cairo - Graphics Library for drawing data to buffers. \ud83d\udd38 Vulkan - An explicit graphical libary that gives users the full control over the rendering process. \ud83d\udd38 xkbcommon - Keymap library. \ud83d\udd38 libevdev - evdev device library \ud83d\udd38 sndfile - C library for reading and writing audio data \ud83d\udd38 ALSA - The Advanced Linux Sound Architecture \ud83d\udd38 Meson - The Meson Build System","title":"Prerequisites"},{"location":"#building","text":"meson setup build --prefix=/usr sudo ninja -C build install Once you're ready to start building your first project head over to the Getting Started documentation to learm some basic tips and tricks on how to start using the Infinite Library.","title":"\ud83d\udea7 Building"},{"location":"#license","text":"This project is intended to be open source to members of the Infinite Developer Environment. As a developer for Infinite Hardware you are free to edit, change or otherwise modify this project with the intention of contributing to the improve of the Infinte Developer tools. You may not however redistribute or resell any version of this project without the express written consent of Cubix Entertainment LLC.","title":"\ud83d\udcd6 License"},{"location":"getting_started/","text":"Getting Started * Prerequisites * To get started developing on Libfinite, you'll need these prerequisites \u2753 The Infinite Library is intended to be used on a Linux based system. \ud83d\udd38 cglm - A C based Graphics Math library \ud83d\udd38 Wayland - The window compositing protocol. \ud83d\udd38 Wayland Protocols - Additional Non Standard features for Wayland. (v1.24 or higher) \ud83d\udd38 Cairo - Graphics Library for drawing data to buffers. \ud83d\udd38 Vulkan - An explicit graphical libary that gives users the full control over the rendering process. \ud83d\udd38 xkbcommon - Keymap library. \ud83d\udd38 libevdev - evdev device library \ud83d\udd38 sndfile - C library for reading and writing audio data \ud83d\udd38 ALSA - The Advanced Linux Sound Architecture \ud83d\udd38 Meson - The Meson Build System Also make sure you've built the library from source as sudo meson setup build --prefix=/usr sudo ninja -C build install Libfinite \"Weirdness\" * \u26a0 Libfinite is still in development and the information here is subject to change. Before you start writing code, there are quite a few \"quirks\" about libfinite that you should be familiar with. 1) Functions are wrapped in Macros in C * All this really means is that functions act weird in VSCode. This site is your best friend for providing explainations on how functions work so check here often for information. 2) draw and render are NOT for mixing. * You may have notice there are finite_draw* and finite_render* and thought you could do something like call finite_draw_rect() and then draw your little cube on the same window. That will not work without extra effort and is not the intended behavior of those function groups. If you are using finite_draw (with Cairo) then you should NOT use finite_render (with Vulkan) on the same surface. If you do this anyways, you were warned. 3) Reinvent the wheel as a Power User * If you want extended functionality of any libfinite function, you can always write a local version yourself. libfinite functions don't call on each other (with a few exceptions, such as finite_render_begin_oneshot_command ) so you're free to do what you want (within reason). Other Weird things * _vars are indexing variables. Don't mix these up finite_draw functions render from back to front finite_audio requires multithreading for audio control Required Files * In order to build a libfinite project you'll need these files which we've graciously provided. xdg-shell.xml layer-shell.xml meson.build These files should be in the root of your project. They are required to make libfinite work correctly. A barebones project * Below is an example of a BAREBONES project that does nothing but set up a window and keep it alive. To start drawing to the screen check out the finite_draw or finite_render function families. #include <finite/draw.h> #include <finite/log.h> int main() { // create a new shell FiniteShell *myShell = finite_shell_init(\"wayland-0\"); if (!myShell) { FINITE_LOG_FATAL(\"Unable to init shell\"); } // to draw windows make a window finite_window_init(myShell); if (!myShell) { FINITE_LOG_FATAL(\"Unable to make shell\"); } // do rendering here // now just keep the window alive while (wl_display_dispatch(myShell->display) != -1) { // do per frame events here (such as finite_input_poll_keys()) } // cleanup here wl_display_disconnect(myShell->display); }","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"getting_started/#prerequisites","text":"To get started developing on Libfinite, you'll need these prerequisites \u2753 The Infinite Library is intended to be used on a Linux based system. \ud83d\udd38 cglm - A C based Graphics Math library \ud83d\udd38 Wayland - The window compositing protocol. \ud83d\udd38 Wayland Protocols - Additional Non Standard features for Wayland. (v1.24 or higher) \ud83d\udd38 Cairo - Graphics Library for drawing data to buffers. \ud83d\udd38 Vulkan - An explicit graphical libary that gives users the full control over the rendering process. \ud83d\udd38 xkbcommon - Keymap library. \ud83d\udd38 libevdev - evdev device library \ud83d\udd38 sndfile - C library for reading and writing audio data \ud83d\udd38 ALSA - The Advanced Linux Sound Architecture \ud83d\udd38 Meson - The Meson Build System Also make sure you've built the library from source as sudo meson setup build --prefix=/usr sudo ninja -C build install","title":"Prerequisites"},{"location":"getting_started/#libfinite-weirdness","text":"\u26a0 Libfinite is still in development and the information here is subject to change. Before you start writing code, there are quite a few \"quirks\" about libfinite that you should be familiar with.","title":"Libfinite \"Weirdness\""},{"location":"getting_started/#1-functions-are-wrapped-in-macros-in-c","text":"All this really means is that functions act weird in VSCode. This site is your best friend for providing explainations on how functions work so check here often for information.","title":"1) Functions are wrapped in Macros in C"},{"location":"getting_started/#2-draw-and-render-are-not-for-mixing","text":"You may have notice there are finite_draw* and finite_render* and thought you could do something like call finite_draw_rect() and then draw your little cube on the same window. That will not work without extra effort and is not the intended behavior of those function groups. If you are using finite_draw (with Cairo) then you should NOT use finite_render (with Vulkan) on the same surface. If you do this anyways, you were warned.","title":"2) draw and render are NOT for mixing."},{"location":"getting_started/#3-reinvent-the-wheel-as-a-power-user","text":"If you want extended functionality of any libfinite function, you can always write a local version yourself. libfinite functions don't call on each other (with a few exceptions, such as finite_render_begin_oneshot_command ) so you're free to do what you want (within reason).","title":"3) Reinvent the wheel as a Power User"},{"location":"getting_started/#other-weird-things","text":"_vars are indexing variables. Don't mix these up finite_draw functions render from back to front finite_audio requires multithreading for audio control","title":"Other Weird things"},{"location":"getting_started/#required-files","text":"In order to build a libfinite project you'll need these files which we've graciously provided. xdg-shell.xml layer-shell.xml meson.build These files should be in the root of your project. They are required to make libfinite work correctly.","title":"Required Files"},{"location":"getting_started/#a-barebones-project","text":"Below is an example of a BAREBONES project that does nothing but set up a window and keep it alive. To start drawing to the screen check out the finite_draw or finite_render function families. #include <finite/draw.h> #include <finite/log.h> int main() { // create a new shell FiniteShell *myShell = finite_shell_init(\"wayland-0\"); if (!myShell) { FINITE_LOG_FATAL(\"Unable to init shell\"); } // to draw windows make a window finite_window_init(myShell); if (!myShell) { FINITE_LOG_FATAL(\"Unable to make shell\"); } // do rendering here // now just keep the window alive while (wl_display_dispatch(myShell->display) != -1) { // do per frame events here (such as finite_input_poll_keys()) } // cleanup here wl_display_disconnect(myShell->display); }","title":"A barebones project"},{"location":"examples/audio/","text":"","title":"Audio"},{"location":"examples/cube/","text":"Cube * The Finite Cube Demo This demo was created with libfinite v0.6.0 This demo shows off (mostly) everything libfinite can do at this time. /* Vulkan 3D Drawing with Libfinite SDK example Written by Gabriel Thompson <gabriel.thomp@cubixdev.org> */ #include <finite/draw.h> #include <finite/input.h> #include <finite/render.h> #include <finite/audio.h> #include <finite/log.h> #include <cglm/call.h> #include <pthread.h> #include <stdint.h> #include <stdio.h> #define GLM_FORCE_DEPTH_ZERO_TO_ONE typedef struct Vertex Vertex; typedef struct UniformBufferObject UniformBufferObject; struct Vertex { vec3 pos; vec3 color; vec2 textureCoord; }; /* Vulkan expects the data in your structure to be aligned in memory in a specific way, for example: Scalars have to be aligned by N (= 4 bytes given 32 bit floats). A vec2 must be aligned by 2N (= 8 bytes) A vec3 or vec4 must be aligned by 4N (= 16 bytes) A nested structure must be aligned by the base alignment of its members rounded up to a multiple of 16. A mat4 matrix must have the same alignment as a vec4. You can find the full list of alignment requirements in the specification. https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-resources-layout */ struct UniformBufferObject { mat4 model; mat4 view; mat4 proj; }; // in this example we've made the vertex data a global which is generally not a good idea. const Vertex vertices[] = { // Front face {{-0.5f, -0.5f, 0.5f}, {1.0f, 0.0f, 0.0f}, {0.0f, 0.0f}}, // 0 {{0.5f, -0.5f, 0.5f}, {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f}}, // 1 {{0.5f, 0.5f, 0.5f}, {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f}}, // 2 {{-0.5f, 0.5f, 0.5f}, {1.0f, 1.0f, 1.0f}, {0.0f, 1.0f}}, // 3 // Back face {{0.5f, -0.5f, -0.5f}, {1.0f, 0.0f, 0.0f}, {0.0f, 0.0f}}, // 4 {{-0.5f, -0.5f, -0.5f}, {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f}}, // 5 {{-0.5f, 0.5f, -0.5f}, {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f}}, // 6 {{0.5f, 0.5f, -0.5f}, {1.0f, 1.0f, 1.0f}, {0.0f, 1.0f}}, // 7 // Left face {{-0.5f, -0.5f, -0.5f}, {1.0f, 0.0f, 0.0f}, {0.0f, 0.0f}}, // 8 {{-0.5f, -0.5f, 0.5f}, {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f}}, // 9 {{-0.5f, 0.5f, 0.5f}, {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f}}, //10 {{-0.5f, 0.5f, -0.5f}, {1.0f, 1.0f, 1.0f}, {0.0f, 1.0f}}, //11 // Right face {{0.5f, -0.5f, 0.5f}, {1.0f, 0.0f, 0.0f}, {0.0f, 0.0f}}, //12 {{0.5f, -0.5f, -0.5f}, {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f}}, //13 {{0.5f, 0.5f, -0.5f}, {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f}}, //14 {{0.5f, 0.5f, 0.5f}, {1.0f, 1.0f, 1.0f}, {0.0f, 1.0f}}, //15 // Top face {{-0.5f, 0.5f, 0.5f}, {1.0f, 0.0f, 0.0f}, {0.0f, 0.0f}}, //16 {{0.5f, 0.5f, 0.5f}, {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f}}, //17 {{0.5f, 0.5f, -0.5f}, {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f}}, //18 {{-0.5f, 0.5f, -0.5f}, {1.0f, 1.0f, 1.0f}, {0.0f, 1.0f}}, //19 // Bottom face {{-0.5f, -0.5f, -0.5f}, {1.0f, 0.0f, 0.0f}, {0.0f, 0.0f}}, //20 {{0.5f, -0.5f, -0.5f}, {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f}}, //21 {{0.5f, -0.5f, 0.5f}, {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f}}, //22 {{-0.5f, -0.5f, 0.5f}, {1.0f, 1.0f, 1.0f}, {0.0f, 1.0f}}, //23 }; // ! All indice data must be in uint32 format/ const uint16_t indexData[] = { 0,1,2,2,3,0, 4,5,6,6,7,4, 8,9,10,10,11,8, 12,13,14,14,15,12, 16,17,18,18,19,16, 20,21,22,22,23,20 }; // size of vertices int _verts = 24; int _indexes = 36; bool canSpin = false; FinitePlaybackDevice *dev; void *playMusic(void *data) { // audio demo for funny char *jingle = \"/home/ship/Documents/jingle3.wav\"; dev = finite_audio_device_init(); finite_audio_get_audio_params(jingle, dev); // print out the audio duration finite_audio_get_audio_duration(dev); // use params to init audio finite_audio_init_audio(dev, jingle, false); // audio is made so now play finite_audio_play(dev); FINITE_LOG(\"Done\"); finite_audio_cleanup(dev); sleep(1); dev = finite_audio_device_init(); if (!dev) { printf(\"Device: %p is unusable\", dev); exit(EXIT_FAILURE); } // reset dev params snd_pcm_hw_free(dev->device); dev = finite_audio_device_init(); char *audio = \"/home/ship/Downloads/Announcement - rangerbts.mp3\"; finite_audio_get_audio_params(audio, dev); // print out the audio duration finite_audio_get_audio_duration(dev); FINITE_LOG(\"Preparing for playback\"); // use params to init audio finite_audio_init_audio(dev, audio, false); FINITE_LOG(\"Preparing for playback2\"); canSpin = true; finite_audio_play(dev); // clean up when finished finite_audio_cleanup(dev); return (void *) 1; } void updateUniformBuffer(FiniteRender *render, uint32_t current) { static struct timespec startTime = {0}; struct timespec currentTime; double time; if (canSpin) { if (startTime.tv_sec == 0 && startTime.tv_nsec == 0) { // First call, initialize startTime clock_gettime(CLOCK_MONOTONIC, &startTime); } clock_gettime(CLOCK_MONOTONIC, &currentTime); time = (currentTime.tv_sec - startTime.tv_sec) + (currentTime.tv_nsec - startTime.tv_nsec) / 1e9; } else { time = 0; } UniformBufferObject ubo = {0}; vec3 axis = { 0.0f, 0.0f, 1.0f }; float angle = glm_rad(-90.0f) * time; vec3 eye = {2.0f, 2.0f, 2.0f}; vec3 center = {0.0f, 0.0f, 0.0f}; vec3 up = {0.0f, 0.0f, 1.0f}; float fov = glm_rad(45.0f); float aspect = render->vk_extent.width / (float) render->vk_extent.height; float near = 0.1f; float far = 10.0f; glm_mat4_identity(ubo.model); glm_rotate(ubo.model, angle, axis); glm_mat4_identity(ubo.view); glm_lookat(eye, center, up, ubo.view); glm_mat4_identity(ubo.proj); glm_perspective(fov, aspect, near, far, ubo.proj); ubo.proj[1][1] *= -1; // printf(\"Adr: %p (%d)\\n\", render->uniformData[render->_currentFrame], render->_currentFrame); // map this to the current buffer memcpy(render->uniformData[render->_currentFrame], &ubo, sizeof(UniformBufferObject)); } int main() { finite_log_init(stdout, LOG_LEVEL_DEBUG, true); FINITE_LOG(\"Starting...\"); // Create a window to draw the triangle FiniteShell *myShell = finite_shell_init(\"wayland-0\"); finite_window_init(myShell); // ! In order for your game to be Infinite compliant you can not resize the window. Here I resize it to make execution easier FiniteWindowInfo *det = myShell->details; int32_t true_width = det->width; int32_t true_height = det->height; finite_window_size_set(myShell, ((true_width * 20) / 100), ((true_height *25) / 100), ((true_width * 60) / 100), ((true_height *50) / 100)); // initialize the renderer // ? Passing NULL does NOT set zero extensions. It just tells libfinite to use the default ones FiniteRender *render = finite_render_init(myShell, NULL, NULL, 0, 0); render->withDepth = true; // enable the depth related features finite_render_create_physical_device(render); // ensure we family queues uint32_t uniqueQueueFamilies[2]; FiniteRenderQueueFamilies fIndex = finite_render_find_queue_families(render->vk_pDevice, render->vk_surface); // dedup if (fIndex.graphicsFamily != fIndex.presentFamily && fIndex.presentFamily >= 0 ) { uniqueQueueFamilies[0] = fIndex.graphicsFamily; uniqueQueueFamilies[1] = fIndex.presentFamily; } else { uniqueQueueFamilies[0] = fIndex.graphicsFamily; } if (fIndex.graphicsFamily < 0) { FINITE_LOG_ERROR(\"Unable to find graphics queue group.\"); // with error you have return/exit manually return 1; } // create the device // ? Similarlly to finite_render_init NULL extensions will create the default extensions finite_render_create_device(render, fIndex, uniqueQueueFamilies, NULL, 0); // now get swapchain details FiniteRenderSwapchainInfo info = finite_render_get_swapchain_info(render, render->vk_pDevice); finite_render_get_best_format(render, info.forms, info._forms); finite_render_get_best_present_mode(render, info.modes, info._modes); finite_render_get_best_extent(render, &info.caps, myShell); // use those details to make a swapchain finite_render_create_swapchain(render, info); //create the swapchain images finite_render_create_swapchain_images(render); // create a render pass FiniteRenderAttachmentDescriptionInfo colorInfo = { .format = render->vk_imageForm.format, .samples = VK_SAMPLE_COUNT_1_BIT, .loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR, .storeOp = VK_ATTACHMENT_STORE_OP_STORE, .stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE, .stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE, .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED, .finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR }; FiniteRenderAttachmentDescriptionInfo depthInfo = { .format = VK_FORMAT_D32_SFLOAT, .samples = VK_SAMPLE_COUNT_1_BIT, .loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR, .storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE, .stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE, .stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE, .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED, .finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL }; FiniteRenderAttachmentRefInfo colorRefInfo = { .type = FINITE_ATTACHMENT_DESCRIPTOR_COLOR, ._attachment = 0, .layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL }; FiniteRenderAttachmentRefInfo depthRefInfo = { .type = FINITE_ATTACHMENT_DESCRIPTOR_DEPTH, ._attachment = 1, .layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL }; FiniteRenderSubpassDescriptionInfo subpass_desc_info = { .pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS, ._colorAttachments = 1 }; FiniteRenderSubpassDependencyInfo subpass_dep_info = { .srcSubpass = VK_SUBPASS_EXTERNAL, .destSubpass = 0, .srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT, .destStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT, .srcAccessMask = 0, .destAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT, .dependencyFlags = 0 }; FiniteRenderSubpassDependencyInfo *subpassDep_infos[1] = {&subpass_dep_info}; FiniteRenderSubpassDescriptionInfo *subpassDesc_infos[1] = {&subpass_desc_info}; FiniteRenderAttachmentRefInfo *ref_infos[2] = {&colorRefInfo, &depthRefInfo}; FiniteRenderAttachmentDescriptionInfo *attachment_infos[2] = {&colorInfo, &depthInfo}; FiniteRenderRenderPassInfo render_pass_info = { .flags = 0, ._attachments = 2, ._deps = 1, ._refs = 2, ._subpasses = 1 }; finite_render_create_render_pass(render, attachment_infos, ref_infos, subpassDesc_infos, subpassDep_infos, &render_pass_info); // load shaders uint32_t vertSize; char *vertCode = finite_render_get_shader_code(\"vert.spv\", &vertSize); bool success = finite_render_get_shader_module(render, vertCode, vertSize); if (!success) { FINITE_LOG_ERROR(\"Unable to create Vertex Shader Module\"); return -1; } uint32_t fragSize; char *fragCode = finite_render_get_shader_code(\"frag.spv\", &fragSize); success = finite_render_get_shader_module(render, fragCode, fragSize); if (!success) { printf(\"Unable to create Fragment Shader Module\"); return -1; } // create descriptor FiniteRenderDescriptorSetLayout uniformLayout = { .binding = 0, ._descriptors = 1, .type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, .flags = VK_SHADER_STAGE_VERTEX_BIT, .samplers = NULL }; FiniteRenderDescriptorSetLayout imageLayout = { .binding = 1, ._descriptors = 1, .type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, .flags = VK_SHADER_STAGE_FRAGMENT_BIT, .samplers = NULL }; FiniteRenderDescriptorSetLayout *bindInfos[2] = {&uniformLayout, &imageLayout}; finite_render_create_descriptor_layout(render, bindInfos, 2); FiniteRenderPipelineLayoutInfo pipe_info = { .flags = 0, ._pushRange = 0 , .pushRange = VK_NULL_HANDLE, ._setConsts = 1, .setConsts = &render->vk_descriptorLayout }; finite_render_create_pipeline_layout(render, &pipe_info); // add shader modules to render FiniteRenderShaderStageInfo vertStage = { .flags = 0, .stage = FINITE_SHADER_TYPE_VERTEX, .shader = render->modules[0], .name = \"main\", .specializationInfo = VK_NULL_HANDLE }; finite_render_add_shader_stage(render, &vertStage); FiniteRenderShaderStageInfo fragStage = { .flags = 0, .stage = FINITE_SHADER_TYPE_FRAGMENT, .shader = render->modules[1], .name = \"main\", .specializationInfo = VK_NULL_HANDLE }; finite_render_add_shader_stage(render, &fragStage); // now use custom bindings VkVertexInputBindingDescription binding = { .binding = 0, .stride = sizeof(Vertex), .inputRate = VK_VERTEX_INPUT_RATE_VERTEX }; VkVertexInputAttributeDescription attribe[] = { { .binding = 0, .location = 0, .format = VK_FORMAT_R32G32B32_SFLOAT, .offset = offsetof(Vertex, pos) }, { .binding = 0, .location = 1, .format = VK_FORMAT_R32G32B32_SFLOAT, .offset = offsetof(Vertex, color) }, { .binding = 0, .location = 2, .format = VK_FORMAT_R32G32_SFLOAT, .offset = offsetof(Vertex, textureCoord) } }; // create generic vulkan objects FiniteRenderVertexInputInfo vertex = { .flags = 0, ._vertexBindings = 1, ._vertexAtributes = 3, .vertexAttributeDescriptions = attribe, .vertexBindingDescriptions = &binding }; FiniteRenderAssemblyInfo assemble = { .flags = 0, .topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, .primitiveRestartEnable = false }; VkViewport viewport = { .x = 0, .y = 0, .width = render->vk_extent.width, .height = render->vk_extent.height, .minDepth = 0.0f, .maxDepth = 1.0f }; VkOffset2D off = { .x = 0, .y = 0 }; VkRect2D scissor = { .extent = render->vk_extent, .offset = off }; FiniteRenderViewportState port = { .flags = 0, ._viewports = 1, ._scissors = 1, .viewports = &viewport, .scissors = &scissor, }; FiniteRenderRasterState raster = { .depthClampEnable = false, .rasterizerDiscardEnable = false, .polygonMode = VK_POLYGON_MODE_FILL, .cullMode = VK_CULL_MODE_BACK_BIT, .frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE, .depthBiasEnable = false, .depthBiasConstantFactor = 0.0f, .depthBiasClamp = 0.0f, .depthBiasSlopeFactor = 1.0f, .lineWidth = 1.0f }; FiniteRenderMultisampleStateInfo samples = { .flags = 0, .rasterizationSamples = VK_SAMPLE_COUNT_1_BIT, .sampleShadingEnable = false, .minSampleShading = 1.0f, .sampleMask = VK_NULL_HANDLE, .alphaToCoverageEnable = false, .alphaToOneEnable = false }; FiniteRenderColorAttachmentInfo blend_att = { .blendEnable = false, .srcColorBlendFactor = VK_BLEND_FACTOR_ONE, .dstColorBlendFactor = VK_BLEND_FACTOR_ZERO, .colorBlendOp = VK_BLEND_OP_ADD, .srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE, .dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO, .alphaBlendOp = VK_BLEND_OP_ADD, .colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT }; FiniteRenderColorBlendInfo blend_info = { .flags = 0, .logicOpEnable = false, .logicOp = VK_LOGIC_OP_COPY, .blendConstants = {0.0f, 0.0f, 0.0f, 0.0f} }; VkDynamicState dynamicStates[] = { VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR }; VkPipelineDynamicStateCreateInfo dynamicStateInfo = { .sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO, .dynamicStateCount = 2, .pDynamicStates = dynamicStates, }; // now create the graphics pipline VkPipelineVertexInputStateCreateInfo input_state_info = finite_render_create_vertex_input(render, &vertex); VkPipelineInputAssemblyStateCreateInfo assemble_info = finite_render_create_assembly_state(render, &assemble); VkPipelineViewportStateCreateInfo viewport_info = finite_render_create_viewport_state(render, &port); VkPipelineRasterizationStateCreateInfo raster_info = finite_render_create_raster_info(render, &raster); VkPipelineMultisampleStateCreateInfo sample_info = finite_render_create_multisample_info(render, &samples); VkPipelineColorBlendAttachmentState blend_att_state_info = finite_render_create_color_blend_attachment(&blend_att); VkPipelineColorBlendStateCreateInfo blend_state_info = finite_render_create_color_blend_state(render, &blend_att_state_info, &blend_info); finite_render_create_graphics_pipeline(render, 0, &input_state_info, &assemble_info, VK_NULL_HANDLE, &viewport_info, &raster_info, &sample_info, &blend_state_info, &dynamicStateInfo); // now create the command buffer and autocreate a pool // ? for a custom pool, set autocreate to false finite_render_create_command_buffer(render, true, true, 1); FiniteRenderImageInfo depthImageInfo = { .format = VK_FORMAT_D32_SFLOAT, .extent = { .width = render->vk_extent.width, .height = render->vk_extent.height, .depth = 1, }, ._mipLevels = 1, .tiling = VK_IMAGE_TILING_OPTIMAL, .useFlags = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, ._samples = VK_SAMPLE_COUNT_1_BIT, .sharing = VK_SHARING_MODE_EXCLUSIVE, .imageType = VK_IMAGE_TYPE_2D, ._layers = 1, .layout = VK_IMAGE_LAYOUT_UNDEFINED }; FiniteRenderMemAllocInfo depth_mem_alloc_info = { .flags = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT }; FiniteRenderImage *depthImage = finite_render_create_image(render, &depthImageInfo, &depth_mem_alloc_info); FiniteRenderImageViewInfo depth_info = { .image = depthImage->textureImage, .type = VK_IMAGE_VIEW_TYPE_2D, .format = VK_FORMAT_D32_SFLOAT, .subRange = { .aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT, .baseMipLevel = 0, .levelCount = 1, .baseArrayLayer = 0, .layerCount = 1 } }; finite_render_create_view(render, depthImage, &depth_info); FiniteRenderImageBarrierInfo depth_wall_info = { .old = VK_IMAGE_LAYOUT_UNDEFINED, .new = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, .srcfIndex = VK_QUEUE_FAMILY_IGNORED, .destfIndex = VK_QUEUE_FAMILY_IGNORED, .image = depthImage->textureImage, .subRange = { .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT, .baseMipLevel = 0, .levelCount = 1, .baseArrayLayer = 0, .layerCount = 1 }, .srcFlags = 0, .destFlags = 0 }; FiniteRenderPipelineDirections depth_pipeline_directions = { .srcFlags = 0, .destFlags = 0, .depFlags = 0 }; finite_render_transition_image_layout(render, &depth_wall_info, VK_FORMAT_D32_SFLOAT, &depth_pipeline_directions); VkImageView att_views[2] = { VK_NULL_HANDLE, // this is a very odd but passing way to refer to the render.vk_view depthImage->textureImageView }; FiniteRenderFramebufferInfo framebuffer_infos = { ._attachments = 2, .attachments = att_views, .width = render->vk_extent.width, .height = render->vk_extent.height, .layers = 1, }; finite_render_create_framebuffers(render, &framebuffer_infos); FiniteRenderTextureInfo texture_info; // populate texture_info finite_render_create_texture(\"texture.png\", &texture_info, true); // create a staging buffer FiniteRenderReturnBuffer repoint; FiniteRenderBufferInfo texture_buffer_info = { .size = texture_info.size, .useFlags = VK_BUFFER_USAGE_TRANSFER_SRC_BIT, .sharing = VK_SHARING_MODE_EXCLUSIVE }; FiniteRenderMemAllocInfo texture_mem_alloc_info = { .flags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT }; // creates a non-replicated buffer (will always write to a FiniteRenderReturnBuffer) bool suc = finite_render_create_generic_buffer(render, &texture_buffer_info, &texture_mem_alloc_info, texture_info.size, &repoint); if (!suc) { exit(EXIT_FAILURE); } void *image_data; vkMapMemory(render->vk_device, repoint.mem, 0, texture_buffer_info.size, 0, &image_data); memcpy(image_data, texture_info.pixels, (size_t) texture_info.size); vkUnmapMemory(render->vk_device, repoint.mem); // free the texture pixels finite_render_destroy_pixels(&texture_info); FiniteRenderImageInfo image_info = { .extent = { .width = texture_info.width, .height = texture_info.height, .depth = 1, }, .imageType = VK_IMAGE_TYPE_2D, ._mipLevels = 1, ._layers = 1, .format = VK_FORMAT_R8G8B8A8_SRGB, .tiling = VK_IMAGE_TILING_OPTIMAL, .layout = VK_IMAGE_LAYOUT_UNDEFINED, .useFlags = VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, ._samples = VK_SAMPLE_COUNT_1_BIT, .sharing = VK_SHARING_MODE_EXCLUSIVE }; texture_mem_alloc_info.flags = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT; FiniteRenderImage *image = finite_render_create_image(render, &image_info, &texture_mem_alloc_info); FiniteRenderImageBarrierInfo wall_info = { .old = VK_IMAGE_LAYOUT_UNDEFINED, .new = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, .srcfIndex = VK_QUEUE_FAMILY_IGNORED, .destfIndex = VK_QUEUE_FAMILY_IGNORED, .image = image->textureImage, .subRange = { .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT, .baseMipLevel = 0, .levelCount = 1, .baseArrayLayer = 0, .layerCount = 1 }, .srcFlags = 0, .destFlags = 0 }; FiniteRenderPipelineDirections pipeline_directions = { .srcFlags = 0, .destFlags = 0, .depFlags = 0 }; FiniteRenderImageCopyDirections copy_directions = { .offset = 0, .rowLength = 0, .height = 0, .subLayers = { .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT, .mipLevel = 0, .baseArrayLayer = 0, .layerCount = 1 }, .imageOffset = {0,0,0}, .extent = { .width = texture_info.width, .height = texture_info.height, .depth = 1, }, .destLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, .buffer = repoint.buf, .image = image->textureImage }; finite_render_transition_image_layout(render, &wall_info, VK_FORMAT_R8G8B8A8_SRGB, &pipeline_directions); finite_render_copy_buffer_to_image(render, &copy_directions); wall_info.old = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL; wall_info.new = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL; finite_render_transition_image_layout(render, &wall_info, VK_FORMAT_R8G8B8A8_SRGB, &pipeline_directions); FiniteRenderImageViewInfo view_2_info = { .image = image->textureImage, .type = VK_IMAGE_VIEW_TYPE_2D, .format = VK_FORMAT_R8G8B8A8_SRGB, .subRange = { .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT, .baseMipLevel = 0, .levelCount = 1, .baseArrayLayer = 0, .layerCount = 1 } }; FiniteRenderTextureSamplerInfo sampler_info = { .magFilter = VK_FILTER_LINEAR, .minFilter = VK_FILTER_LINEAR, .addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT, .addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT, .addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT, .anisotropyEnable = true, .borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK, .unnormalizedCoordinates = false, .compareEnable = false, .compareOp = VK_COMPARE_OP_ALWAYS, .mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR, .mipLodBias = 0.0f, .minLod = 0.0f, .maxLod = 0.0f }; finite_render_create_view(render, image, &view_2_info); finite_render_create_sampler(render, image, &sampler_info); // this is the total amount of NEW SPACE needed to create the buffer // ? DO NOT try to calculate the total size of the buffer to create new space as it will result in errors. FiniteRenderBufferInfo vertex_buffer_info = { .size = (sizeof(Vertex) * _verts) + (sizeof(uint16_t) * _indexes), .useFlags = VK_BUFFER_USAGE_TRANSFER_SRC_BIT, .sharing = VK_SHARING_MODE_EXCLUSIVE }; FiniteRenderMemAllocInfo mem_alloc_info = { .flags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT }; bool prog; FiniteRenderReturnBuffer point; prog = finite_render_create_vertex_buffer(render, &vertex_buffer_info, &mem_alloc_info, sizeof(Vertex) * _verts, &point); if (!prog) { exit(EXIT_FAILURE); } // as a dev you must manually map the vertex buffer when using custom vertex void *data; vkMapMemory(render->vk_device, point.mem, 0, vertex_buffer_info.size, 0, &data); memcpy(data, vertices, (size_t) (sizeof(Vertex) * _verts)); // ! Make sure to offset the data so memcpy doesnt overwrite void *index = (char *)data + sizeof(Vertex) *_verts; memcpy(index, indexData, (size_t) (sizeof(uint16_t) * _indexes)); vkUnmapMemory(render->vk_device, point.mem); vertex_buffer_info.useFlags = VK_BUFFER_USAGE_TRANSFER_DST_BIT; mem_alloc_info.flags = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT; prog = finite_render_create_vertex_buffer(render, &vertex_buffer_info, &mem_alloc_info, sizeof(Vertex) * _verts, NULL); if (!prog) { exit(EXIT_FAILURE); } finite_render_copy_buffer(render, point.buf, render->vk_vertexBuf, (point.vertexSize + point.indexSize)); // add count data render->buffers[0]._indices = true; render->buffers[0].indexCount = _indexes; render->buffers[0].vertexCount = _verts; FINITE_LOG(\"Rendering object %p: vtx=%u, idx=%u, vtxOffset=%lu (%lu), idxOffset=%lu (%lu)\", render->buffers, render->buffers[0].vertexCount, render->buffers[0].indexCount, render->buffers[0].vertexOffset,(sizeof(Vertex) * _verts), render->buffers[0].indexOffset, (sizeof(uint32_t) * _indexes)); FiniteRenderBufferInfo uniform_buffer_info = { .size = sizeof(UniformBufferObject), .sharing = VK_SHARING_MODE_EXCLUSIVE }; FiniteRenderMemAllocInfo uniform_alloc_info = { .flags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT }; finite_render_create_uniform_buffer(render, &uniform_buffer_info, &uniform_alloc_info); FiniteRenderDescriptorPoolInfo imageDescriptor = { .type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER }; FiniteRenderDescriptorPoolInfo *desc_pool_infos[2] = {NULL, &imageDescriptor}; finite_render_create_descriptor_pool(render, desc_pool_infos, true, 2); for (int i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) { FiniteRenderWriteSetInfo buffer_write_info = { .dstSet = render->vk_descriptor[i], .dstBinding = 0, .dstArrayElement = 0, .descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER }; FiniteRenderWriteSetInfo image_write_info = { .dstSet = render->vk_descriptor[i], .dstBinding = 1, .dstArrayElement = 0, .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER }; FiniteRenderWriteSetInfo *write_infos[2] = {&buffer_write_info, &image_write_info}; FiniteRenderDescriptorInfo desc_info = { .type = FINITE_DESCRIPTOR_MULTI, .buffer = render->vk_uniformBuf[i], .buffer_offset = 0, .buffer_range = sizeof(UniformBufferObject), .image_layout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, .image_view = image->textureImageView, .image_sampler = image->textureSampler }; finite_render_write_to_descriptor(render, write_infos, &desc_info, 2); } for (int i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) { // create two semaphores and one fence finite_render_create_semaphore(render); //images available finite_render_create_semaphore(render); // renderFinished finite_render_create_fence(render, VK_FENCE_CREATE_SIGNALED_BIT); } // * use pending state!!! int state = wl_display_dispatch_pending(myShell->display); FINITE_LOG(\"Success! Dispatch state: %d\", state); // multithread here pthread_t id; pthread_create(&id, NULL, playMusic, &dev); // keyboard demo for additional funny // FiniteKeyboard *kbd = finite_input_keyboard_init(myShell->display); // FiniteKey xKey = finite_key_from_string(\"X\"); // if (!finite_key_valid(xKey)) { // printf(\"Unable to poll NULL key\"); // exit(EXIT_FAILURE); // } // create wayland frame loop while (wl_display_dispatch_pending(myShell->display) != -1) { // poll for input // finite_input_poll_keys(kbd, myShell); // // handle input // if (finite_key_pressed(xKey, kbd)) { // printf(\"Attempting to pause\\n\"); // finite_audio_pause(dev); // } // with framesInFlight we need to offset where the indexes are. For reference: // 0 -> imagesAvailable // 1 -> renderFinished // so offset is i + (2 * currentFrame) with since its two items. render->_currentFrame = (render->_currentFrame + 1) % MAX_FRAMES_IN_FLIGHT; int currentFence = 0 + (1 * render->_currentFrame); int currentSignal = 0 + (2 * render->_currentFrame); // printf(\"Current Fence: %d (%p) \\nCurrent Signal: %d (%p)\\n\", currentFence, render->fences[currentFence], currentSignal, render->signals[currentSignal]); // handle custom rendering here vkWaitForFences(render->vk_device, 1, &render->fences[currentFence], VK_TRUE, UINT64_MAX); vkResetFences(render->vk_device, 1, &render->fences[currentFence]); // printf(\"Current Fence %d (%p) was reset.\\nCurrent Signal: %d (%p)\\n\", currentFence, render->fences[currentFence], currentSignal, render->signals[currentSignal]); uint32_t index; vkAcquireNextImageKHR(render->vk_device, render->vk_swapchain, UINT64_MAX, render->signals[currentSignal], VK_NULL_HANDLE, &index); vkResetCommandBuffer(render->vk_buffer[render->_currentFrame], 0); // printf(\"recording\\n\"); finite_render_record_command_buffer(render, index); // printf(\"Attempting to rotate\\n\"); updateUniformBuffer(render, index); // printf(\"Rotate finished\\n\"); VkPipelineStageFlags waitStage = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; FiniteRenderSubmitInfo submit_info = { ._waitSemaphores = 1, .waitSemaphores = &render->signals[currentSignal], .waitDstStageMask = &waitStage, ._commandBuffs = 1, .commandBuffs = &render->vk_buffer[render->_currentFrame], ._signalSemaphores = 1, .signalSemaphores = &render->signals[currentSignal + 1] }; // printf(\"submitting\\n\"); // the safeExit param determines whether we want to have finite_render_submit_frame cleanup and exit on failure finite_render_submit_frame(render, &submit_info, currentFence, false); VkSwapchainKHR swapchains[] = {render->vk_swapchain}; FiniteRenderPresentInfo present_info = { ._waitSemaphores = 1, .waitSemaphores = &render->signals[currentSignal + 1], ._swapchains = 1, .swapchains = swapchains, .imageIndices = &index, .results = NULL }; // printf(\"presenting\\n\"); finite_render_present_frame(render, &present_info, false); // render->_currentFrame = (render->_currentFrame + 1) % MAX_FRAMES_IN_FLIGHT; // printf(\"Current Frame: %d\\n\", render->_currentFrame); } vkDeviceWaitIdle(render->vk_device); FiniteRenderImage *imgs = {image}; finite_render_cleanup_textures(render, imgs, 1); finite_render_cleanup(render); } Video Example *","title":"Cube"},{"location":"examples/cube/#cube","text":"The Finite Cube Demo This demo was created with libfinite v0.6.0 This demo shows off (mostly) everything libfinite can do at this time. /* Vulkan 3D Drawing with Libfinite SDK example Written by Gabriel Thompson <gabriel.thomp@cubixdev.org> */ #include <finite/draw.h> #include <finite/input.h> #include <finite/render.h> #include <finite/audio.h> #include <finite/log.h> #include <cglm/call.h> #include <pthread.h> #include <stdint.h> #include <stdio.h> #define GLM_FORCE_DEPTH_ZERO_TO_ONE typedef struct Vertex Vertex; typedef struct UniformBufferObject UniformBufferObject; struct Vertex { vec3 pos; vec3 color; vec2 textureCoord; }; /* Vulkan expects the data in your structure to be aligned in memory in a specific way, for example: Scalars have to be aligned by N (= 4 bytes given 32 bit floats). A vec2 must be aligned by 2N (= 8 bytes) A vec3 or vec4 must be aligned by 4N (= 16 bytes) A nested structure must be aligned by the base alignment of its members rounded up to a multiple of 16. A mat4 matrix must have the same alignment as a vec4. You can find the full list of alignment requirements in the specification. https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-resources-layout */ struct UniformBufferObject { mat4 model; mat4 view; mat4 proj; }; // in this example we've made the vertex data a global which is generally not a good idea. const Vertex vertices[] = { // Front face {{-0.5f, -0.5f, 0.5f}, {1.0f, 0.0f, 0.0f}, {0.0f, 0.0f}}, // 0 {{0.5f, -0.5f, 0.5f}, {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f}}, // 1 {{0.5f, 0.5f, 0.5f}, {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f}}, // 2 {{-0.5f, 0.5f, 0.5f}, {1.0f, 1.0f, 1.0f}, {0.0f, 1.0f}}, // 3 // Back face {{0.5f, -0.5f, -0.5f}, {1.0f, 0.0f, 0.0f}, {0.0f, 0.0f}}, // 4 {{-0.5f, -0.5f, -0.5f}, {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f}}, // 5 {{-0.5f, 0.5f, -0.5f}, {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f}}, // 6 {{0.5f, 0.5f, -0.5f}, {1.0f, 1.0f, 1.0f}, {0.0f, 1.0f}}, // 7 // Left face {{-0.5f, -0.5f, -0.5f}, {1.0f, 0.0f, 0.0f}, {0.0f, 0.0f}}, // 8 {{-0.5f, -0.5f, 0.5f}, {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f}}, // 9 {{-0.5f, 0.5f, 0.5f}, {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f}}, //10 {{-0.5f, 0.5f, -0.5f}, {1.0f, 1.0f, 1.0f}, {0.0f, 1.0f}}, //11 // Right face {{0.5f, -0.5f, 0.5f}, {1.0f, 0.0f, 0.0f}, {0.0f, 0.0f}}, //12 {{0.5f, -0.5f, -0.5f}, {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f}}, //13 {{0.5f, 0.5f, -0.5f}, {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f}}, //14 {{0.5f, 0.5f, 0.5f}, {1.0f, 1.0f, 1.0f}, {0.0f, 1.0f}}, //15 // Top face {{-0.5f, 0.5f, 0.5f}, {1.0f, 0.0f, 0.0f}, {0.0f, 0.0f}}, //16 {{0.5f, 0.5f, 0.5f}, {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f}}, //17 {{0.5f, 0.5f, -0.5f}, {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f}}, //18 {{-0.5f, 0.5f, -0.5f}, {1.0f, 1.0f, 1.0f}, {0.0f, 1.0f}}, //19 // Bottom face {{-0.5f, -0.5f, -0.5f}, {1.0f, 0.0f, 0.0f}, {0.0f, 0.0f}}, //20 {{0.5f, -0.5f, -0.5f}, {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f}}, //21 {{0.5f, -0.5f, 0.5f}, {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f}}, //22 {{-0.5f, -0.5f, 0.5f}, {1.0f, 1.0f, 1.0f}, {0.0f, 1.0f}}, //23 }; // ! All indice data must be in uint32 format/ const uint16_t indexData[] = { 0,1,2,2,3,0, 4,5,6,6,7,4, 8,9,10,10,11,8, 12,13,14,14,15,12, 16,17,18,18,19,16, 20,21,22,22,23,20 }; // size of vertices int _verts = 24; int _indexes = 36; bool canSpin = false; FinitePlaybackDevice *dev; void *playMusic(void *data) { // audio demo for funny char *jingle = \"/home/ship/Documents/jingle3.wav\"; dev = finite_audio_device_init(); finite_audio_get_audio_params(jingle, dev); // print out the audio duration finite_audio_get_audio_duration(dev); // use params to init audio finite_audio_init_audio(dev, jingle, false); // audio is made so now play finite_audio_play(dev); FINITE_LOG(\"Done\"); finite_audio_cleanup(dev); sleep(1); dev = finite_audio_device_init(); if (!dev) { printf(\"Device: %p is unusable\", dev); exit(EXIT_FAILURE); } // reset dev params snd_pcm_hw_free(dev->device); dev = finite_audio_device_init(); char *audio = \"/home/ship/Downloads/Announcement - rangerbts.mp3\"; finite_audio_get_audio_params(audio, dev); // print out the audio duration finite_audio_get_audio_duration(dev); FINITE_LOG(\"Preparing for playback\"); // use params to init audio finite_audio_init_audio(dev, audio, false); FINITE_LOG(\"Preparing for playback2\"); canSpin = true; finite_audio_play(dev); // clean up when finished finite_audio_cleanup(dev); return (void *) 1; } void updateUniformBuffer(FiniteRender *render, uint32_t current) { static struct timespec startTime = {0}; struct timespec currentTime; double time; if (canSpin) { if (startTime.tv_sec == 0 && startTime.tv_nsec == 0) { // First call, initialize startTime clock_gettime(CLOCK_MONOTONIC, &startTime); } clock_gettime(CLOCK_MONOTONIC, &currentTime); time = (currentTime.tv_sec - startTime.tv_sec) + (currentTime.tv_nsec - startTime.tv_nsec) / 1e9; } else { time = 0; } UniformBufferObject ubo = {0}; vec3 axis = { 0.0f, 0.0f, 1.0f }; float angle = glm_rad(-90.0f) * time; vec3 eye = {2.0f, 2.0f, 2.0f}; vec3 center = {0.0f, 0.0f, 0.0f}; vec3 up = {0.0f, 0.0f, 1.0f}; float fov = glm_rad(45.0f); float aspect = render->vk_extent.width / (float) render->vk_extent.height; float near = 0.1f; float far = 10.0f; glm_mat4_identity(ubo.model); glm_rotate(ubo.model, angle, axis); glm_mat4_identity(ubo.view); glm_lookat(eye, center, up, ubo.view); glm_mat4_identity(ubo.proj); glm_perspective(fov, aspect, near, far, ubo.proj); ubo.proj[1][1] *= -1; // printf(\"Adr: %p (%d)\\n\", render->uniformData[render->_currentFrame], render->_currentFrame); // map this to the current buffer memcpy(render->uniformData[render->_currentFrame], &ubo, sizeof(UniformBufferObject)); } int main() { finite_log_init(stdout, LOG_LEVEL_DEBUG, true); FINITE_LOG(\"Starting...\"); // Create a window to draw the triangle FiniteShell *myShell = finite_shell_init(\"wayland-0\"); finite_window_init(myShell); // ! In order for your game to be Infinite compliant you can not resize the window. Here I resize it to make execution easier FiniteWindowInfo *det = myShell->details; int32_t true_width = det->width; int32_t true_height = det->height; finite_window_size_set(myShell, ((true_width * 20) / 100), ((true_height *25) / 100), ((true_width * 60) / 100), ((true_height *50) / 100)); // initialize the renderer // ? Passing NULL does NOT set zero extensions. It just tells libfinite to use the default ones FiniteRender *render = finite_render_init(myShell, NULL, NULL, 0, 0); render->withDepth = true; // enable the depth related features finite_render_create_physical_device(render); // ensure we family queues uint32_t uniqueQueueFamilies[2]; FiniteRenderQueueFamilies fIndex = finite_render_find_queue_families(render->vk_pDevice, render->vk_surface); // dedup if (fIndex.graphicsFamily != fIndex.presentFamily && fIndex.presentFamily >= 0 ) { uniqueQueueFamilies[0] = fIndex.graphicsFamily; uniqueQueueFamilies[1] = fIndex.presentFamily; } else { uniqueQueueFamilies[0] = fIndex.graphicsFamily; } if (fIndex.graphicsFamily < 0) { FINITE_LOG_ERROR(\"Unable to find graphics queue group.\"); // with error you have return/exit manually return 1; } // create the device // ? Similarlly to finite_render_init NULL extensions will create the default extensions finite_render_create_device(render, fIndex, uniqueQueueFamilies, NULL, 0); // now get swapchain details FiniteRenderSwapchainInfo info = finite_render_get_swapchain_info(render, render->vk_pDevice); finite_render_get_best_format(render, info.forms, info._forms); finite_render_get_best_present_mode(render, info.modes, info._modes); finite_render_get_best_extent(render, &info.caps, myShell); // use those details to make a swapchain finite_render_create_swapchain(render, info); //create the swapchain images finite_render_create_swapchain_images(render); // create a render pass FiniteRenderAttachmentDescriptionInfo colorInfo = { .format = render->vk_imageForm.format, .samples = VK_SAMPLE_COUNT_1_BIT, .loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR, .storeOp = VK_ATTACHMENT_STORE_OP_STORE, .stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE, .stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE, .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED, .finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR }; FiniteRenderAttachmentDescriptionInfo depthInfo = { .format = VK_FORMAT_D32_SFLOAT, .samples = VK_SAMPLE_COUNT_1_BIT, .loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR, .storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE, .stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE, .stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE, .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED, .finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL }; FiniteRenderAttachmentRefInfo colorRefInfo = { .type = FINITE_ATTACHMENT_DESCRIPTOR_COLOR, ._attachment = 0, .layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL }; FiniteRenderAttachmentRefInfo depthRefInfo = { .type = FINITE_ATTACHMENT_DESCRIPTOR_DEPTH, ._attachment = 1, .layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL }; FiniteRenderSubpassDescriptionInfo subpass_desc_info = { .pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS, ._colorAttachments = 1 }; FiniteRenderSubpassDependencyInfo subpass_dep_info = { .srcSubpass = VK_SUBPASS_EXTERNAL, .destSubpass = 0, .srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT, .destStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT, .srcAccessMask = 0, .destAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT, .dependencyFlags = 0 }; FiniteRenderSubpassDependencyInfo *subpassDep_infos[1] = {&subpass_dep_info}; FiniteRenderSubpassDescriptionInfo *subpassDesc_infos[1] = {&subpass_desc_info}; FiniteRenderAttachmentRefInfo *ref_infos[2] = {&colorRefInfo, &depthRefInfo}; FiniteRenderAttachmentDescriptionInfo *attachment_infos[2] = {&colorInfo, &depthInfo}; FiniteRenderRenderPassInfo render_pass_info = { .flags = 0, ._attachments = 2, ._deps = 1, ._refs = 2, ._subpasses = 1 }; finite_render_create_render_pass(render, attachment_infos, ref_infos, subpassDesc_infos, subpassDep_infos, &render_pass_info); // load shaders uint32_t vertSize; char *vertCode = finite_render_get_shader_code(\"vert.spv\", &vertSize); bool success = finite_render_get_shader_module(render, vertCode, vertSize); if (!success) { FINITE_LOG_ERROR(\"Unable to create Vertex Shader Module\"); return -1; } uint32_t fragSize; char *fragCode = finite_render_get_shader_code(\"frag.spv\", &fragSize); success = finite_render_get_shader_module(render, fragCode, fragSize); if (!success) { printf(\"Unable to create Fragment Shader Module\"); return -1; } // create descriptor FiniteRenderDescriptorSetLayout uniformLayout = { .binding = 0, ._descriptors = 1, .type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, .flags = VK_SHADER_STAGE_VERTEX_BIT, .samplers = NULL }; FiniteRenderDescriptorSetLayout imageLayout = { .binding = 1, ._descriptors = 1, .type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, .flags = VK_SHADER_STAGE_FRAGMENT_BIT, .samplers = NULL }; FiniteRenderDescriptorSetLayout *bindInfos[2] = {&uniformLayout, &imageLayout}; finite_render_create_descriptor_layout(render, bindInfos, 2); FiniteRenderPipelineLayoutInfo pipe_info = { .flags = 0, ._pushRange = 0 , .pushRange = VK_NULL_HANDLE, ._setConsts = 1, .setConsts = &render->vk_descriptorLayout }; finite_render_create_pipeline_layout(render, &pipe_info); // add shader modules to render FiniteRenderShaderStageInfo vertStage = { .flags = 0, .stage = FINITE_SHADER_TYPE_VERTEX, .shader = render->modules[0], .name = \"main\", .specializationInfo = VK_NULL_HANDLE }; finite_render_add_shader_stage(render, &vertStage); FiniteRenderShaderStageInfo fragStage = { .flags = 0, .stage = FINITE_SHADER_TYPE_FRAGMENT, .shader = render->modules[1], .name = \"main\", .specializationInfo = VK_NULL_HANDLE }; finite_render_add_shader_stage(render, &fragStage); // now use custom bindings VkVertexInputBindingDescription binding = { .binding = 0, .stride = sizeof(Vertex), .inputRate = VK_VERTEX_INPUT_RATE_VERTEX }; VkVertexInputAttributeDescription attribe[] = { { .binding = 0, .location = 0, .format = VK_FORMAT_R32G32B32_SFLOAT, .offset = offsetof(Vertex, pos) }, { .binding = 0, .location = 1, .format = VK_FORMAT_R32G32B32_SFLOAT, .offset = offsetof(Vertex, color) }, { .binding = 0, .location = 2, .format = VK_FORMAT_R32G32_SFLOAT, .offset = offsetof(Vertex, textureCoord) } }; // create generic vulkan objects FiniteRenderVertexInputInfo vertex = { .flags = 0, ._vertexBindings = 1, ._vertexAtributes = 3, .vertexAttributeDescriptions = attribe, .vertexBindingDescriptions = &binding }; FiniteRenderAssemblyInfo assemble = { .flags = 0, .topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, .primitiveRestartEnable = false }; VkViewport viewport = { .x = 0, .y = 0, .width = render->vk_extent.width, .height = render->vk_extent.height, .minDepth = 0.0f, .maxDepth = 1.0f }; VkOffset2D off = { .x = 0, .y = 0 }; VkRect2D scissor = { .extent = render->vk_extent, .offset = off }; FiniteRenderViewportState port = { .flags = 0, ._viewports = 1, ._scissors = 1, .viewports = &viewport, .scissors = &scissor, }; FiniteRenderRasterState raster = { .depthClampEnable = false, .rasterizerDiscardEnable = false, .polygonMode = VK_POLYGON_MODE_FILL, .cullMode = VK_CULL_MODE_BACK_BIT, .frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE, .depthBiasEnable = false, .depthBiasConstantFactor = 0.0f, .depthBiasClamp = 0.0f, .depthBiasSlopeFactor = 1.0f, .lineWidth = 1.0f }; FiniteRenderMultisampleStateInfo samples = { .flags = 0, .rasterizationSamples = VK_SAMPLE_COUNT_1_BIT, .sampleShadingEnable = false, .minSampleShading = 1.0f, .sampleMask = VK_NULL_HANDLE, .alphaToCoverageEnable = false, .alphaToOneEnable = false }; FiniteRenderColorAttachmentInfo blend_att = { .blendEnable = false, .srcColorBlendFactor = VK_BLEND_FACTOR_ONE, .dstColorBlendFactor = VK_BLEND_FACTOR_ZERO, .colorBlendOp = VK_BLEND_OP_ADD, .srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE, .dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO, .alphaBlendOp = VK_BLEND_OP_ADD, .colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT }; FiniteRenderColorBlendInfo blend_info = { .flags = 0, .logicOpEnable = false, .logicOp = VK_LOGIC_OP_COPY, .blendConstants = {0.0f, 0.0f, 0.0f, 0.0f} }; VkDynamicState dynamicStates[] = { VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR }; VkPipelineDynamicStateCreateInfo dynamicStateInfo = { .sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO, .dynamicStateCount = 2, .pDynamicStates = dynamicStates, }; // now create the graphics pipline VkPipelineVertexInputStateCreateInfo input_state_info = finite_render_create_vertex_input(render, &vertex); VkPipelineInputAssemblyStateCreateInfo assemble_info = finite_render_create_assembly_state(render, &assemble); VkPipelineViewportStateCreateInfo viewport_info = finite_render_create_viewport_state(render, &port); VkPipelineRasterizationStateCreateInfo raster_info = finite_render_create_raster_info(render, &raster); VkPipelineMultisampleStateCreateInfo sample_info = finite_render_create_multisample_info(render, &samples); VkPipelineColorBlendAttachmentState blend_att_state_info = finite_render_create_color_blend_attachment(&blend_att); VkPipelineColorBlendStateCreateInfo blend_state_info = finite_render_create_color_blend_state(render, &blend_att_state_info, &blend_info); finite_render_create_graphics_pipeline(render, 0, &input_state_info, &assemble_info, VK_NULL_HANDLE, &viewport_info, &raster_info, &sample_info, &blend_state_info, &dynamicStateInfo); // now create the command buffer and autocreate a pool // ? for a custom pool, set autocreate to false finite_render_create_command_buffer(render, true, true, 1); FiniteRenderImageInfo depthImageInfo = { .format = VK_FORMAT_D32_SFLOAT, .extent = { .width = render->vk_extent.width, .height = render->vk_extent.height, .depth = 1, }, ._mipLevels = 1, .tiling = VK_IMAGE_TILING_OPTIMAL, .useFlags = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, ._samples = VK_SAMPLE_COUNT_1_BIT, .sharing = VK_SHARING_MODE_EXCLUSIVE, .imageType = VK_IMAGE_TYPE_2D, ._layers = 1, .layout = VK_IMAGE_LAYOUT_UNDEFINED }; FiniteRenderMemAllocInfo depth_mem_alloc_info = { .flags = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT }; FiniteRenderImage *depthImage = finite_render_create_image(render, &depthImageInfo, &depth_mem_alloc_info); FiniteRenderImageViewInfo depth_info = { .image = depthImage->textureImage, .type = VK_IMAGE_VIEW_TYPE_2D, .format = VK_FORMAT_D32_SFLOAT, .subRange = { .aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT, .baseMipLevel = 0, .levelCount = 1, .baseArrayLayer = 0, .layerCount = 1 } }; finite_render_create_view(render, depthImage, &depth_info); FiniteRenderImageBarrierInfo depth_wall_info = { .old = VK_IMAGE_LAYOUT_UNDEFINED, .new = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, .srcfIndex = VK_QUEUE_FAMILY_IGNORED, .destfIndex = VK_QUEUE_FAMILY_IGNORED, .image = depthImage->textureImage, .subRange = { .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT, .baseMipLevel = 0, .levelCount = 1, .baseArrayLayer = 0, .layerCount = 1 }, .srcFlags = 0, .destFlags = 0 }; FiniteRenderPipelineDirections depth_pipeline_directions = { .srcFlags = 0, .destFlags = 0, .depFlags = 0 }; finite_render_transition_image_layout(render, &depth_wall_info, VK_FORMAT_D32_SFLOAT, &depth_pipeline_directions); VkImageView att_views[2] = { VK_NULL_HANDLE, // this is a very odd but passing way to refer to the render.vk_view depthImage->textureImageView }; FiniteRenderFramebufferInfo framebuffer_infos = { ._attachments = 2, .attachments = att_views, .width = render->vk_extent.width, .height = render->vk_extent.height, .layers = 1, }; finite_render_create_framebuffers(render, &framebuffer_infos); FiniteRenderTextureInfo texture_info; // populate texture_info finite_render_create_texture(\"texture.png\", &texture_info, true); // create a staging buffer FiniteRenderReturnBuffer repoint; FiniteRenderBufferInfo texture_buffer_info = { .size = texture_info.size, .useFlags = VK_BUFFER_USAGE_TRANSFER_SRC_BIT, .sharing = VK_SHARING_MODE_EXCLUSIVE }; FiniteRenderMemAllocInfo texture_mem_alloc_info = { .flags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT }; // creates a non-replicated buffer (will always write to a FiniteRenderReturnBuffer) bool suc = finite_render_create_generic_buffer(render, &texture_buffer_info, &texture_mem_alloc_info, texture_info.size, &repoint); if (!suc) { exit(EXIT_FAILURE); } void *image_data; vkMapMemory(render->vk_device, repoint.mem, 0, texture_buffer_info.size, 0, &image_data); memcpy(image_data, texture_info.pixels, (size_t) texture_info.size); vkUnmapMemory(render->vk_device, repoint.mem); // free the texture pixels finite_render_destroy_pixels(&texture_info); FiniteRenderImageInfo image_info = { .extent = { .width = texture_info.width, .height = texture_info.height, .depth = 1, }, .imageType = VK_IMAGE_TYPE_2D, ._mipLevels = 1, ._layers = 1, .format = VK_FORMAT_R8G8B8A8_SRGB, .tiling = VK_IMAGE_TILING_OPTIMAL, .layout = VK_IMAGE_LAYOUT_UNDEFINED, .useFlags = VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, ._samples = VK_SAMPLE_COUNT_1_BIT, .sharing = VK_SHARING_MODE_EXCLUSIVE }; texture_mem_alloc_info.flags = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT; FiniteRenderImage *image = finite_render_create_image(render, &image_info, &texture_mem_alloc_info); FiniteRenderImageBarrierInfo wall_info = { .old = VK_IMAGE_LAYOUT_UNDEFINED, .new = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, .srcfIndex = VK_QUEUE_FAMILY_IGNORED, .destfIndex = VK_QUEUE_FAMILY_IGNORED, .image = image->textureImage, .subRange = { .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT, .baseMipLevel = 0, .levelCount = 1, .baseArrayLayer = 0, .layerCount = 1 }, .srcFlags = 0, .destFlags = 0 }; FiniteRenderPipelineDirections pipeline_directions = { .srcFlags = 0, .destFlags = 0, .depFlags = 0 }; FiniteRenderImageCopyDirections copy_directions = { .offset = 0, .rowLength = 0, .height = 0, .subLayers = { .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT, .mipLevel = 0, .baseArrayLayer = 0, .layerCount = 1 }, .imageOffset = {0,0,0}, .extent = { .width = texture_info.width, .height = texture_info.height, .depth = 1, }, .destLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, .buffer = repoint.buf, .image = image->textureImage }; finite_render_transition_image_layout(render, &wall_info, VK_FORMAT_R8G8B8A8_SRGB, &pipeline_directions); finite_render_copy_buffer_to_image(render, &copy_directions); wall_info.old = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL; wall_info.new = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL; finite_render_transition_image_layout(render, &wall_info, VK_FORMAT_R8G8B8A8_SRGB, &pipeline_directions); FiniteRenderImageViewInfo view_2_info = { .image = image->textureImage, .type = VK_IMAGE_VIEW_TYPE_2D, .format = VK_FORMAT_R8G8B8A8_SRGB, .subRange = { .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT, .baseMipLevel = 0, .levelCount = 1, .baseArrayLayer = 0, .layerCount = 1 } }; FiniteRenderTextureSamplerInfo sampler_info = { .magFilter = VK_FILTER_LINEAR, .minFilter = VK_FILTER_LINEAR, .addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT, .addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT, .addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT, .anisotropyEnable = true, .borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK, .unnormalizedCoordinates = false, .compareEnable = false, .compareOp = VK_COMPARE_OP_ALWAYS, .mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR, .mipLodBias = 0.0f, .minLod = 0.0f, .maxLod = 0.0f }; finite_render_create_view(render, image, &view_2_info); finite_render_create_sampler(render, image, &sampler_info); // this is the total amount of NEW SPACE needed to create the buffer // ? DO NOT try to calculate the total size of the buffer to create new space as it will result in errors. FiniteRenderBufferInfo vertex_buffer_info = { .size = (sizeof(Vertex) * _verts) + (sizeof(uint16_t) * _indexes), .useFlags = VK_BUFFER_USAGE_TRANSFER_SRC_BIT, .sharing = VK_SHARING_MODE_EXCLUSIVE }; FiniteRenderMemAllocInfo mem_alloc_info = { .flags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT }; bool prog; FiniteRenderReturnBuffer point; prog = finite_render_create_vertex_buffer(render, &vertex_buffer_info, &mem_alloc_info, sizeof(Vertex) * _verts, &point); if (!prog) { exit(EXIT_FAILURE); } // as a dev you must manually map the vertex buffer when using custom vertex void *data; vkMapMemory(render->vk_device, point.mem, 0, vertex_buffer_info.size, 0, &data); memcpy(data, vertices, (size_t) (sizeof(Vertex) * _verts)); // ! Make sure to offset the data so memcpy doesnt overwrite void *index = (char *)data + sizeof(Vertex) *_verts; memcpy(index, indexData, (size_t) (sizeof(uint16_t) * _indexes)); vkUnmapMemory(render->vk_device, point.mem); vertex_buffer_info.useFlags = VK_BUFFER_USAGE_TRANSFER_DST_BIT; mem_alloc_info.flags = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT; prog = finite_render_create_vertex_buffer(render, &vertex_buffer_info, &mem_alloc_info, sizeof(Vertex) * _verts, NULL); if (!prog) { exit(EXIT_FAILURE); } finite_render_copy_buffer(render, point.buf, render->vk_vertexBuf, (point.vertexSize + point.indexSize)); // add count data render->buffers[0]._indices = true; render->buffers[0].indexCount = _indexes; render->buffers[0].vertexCount = _verts; FINITE_LOG(\"Rendering object %p: vtx=%u, idx=%u, vtxOffset=%lu (%lu), idxOffset=%lu (%lu)\", render->buffers, render->buffers[0].vertexCount, render->buffers[0].indexCount, render->buffers[0].vertexOffset,(sizeof(Vertex) * _verts), render->buffers[0].indexOffset, (sizeof(uint32_t) * _indexes)); FiniteRenderBufferInfo uniform_buffer_info = { .size = sizeof(UniformBufferObject), .sharing = VK_SHARING_MODE_EXCLUSIVE }; FiniteRenderMemAllocInfo uniform_alloc_info = { .flags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT }; finite_render_create_uniform_buffer(render, &uniform_buffer_info, &uniform_alloc_info); FiniteRenderDescriptorPoolInfo imageDescriptor = { .type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER }; FiniteRenderDescriptorPoolInfo *desc_pool_infos[2] = {NULL, &imageDescriptor}; finite_render_create_descriptor_pool(render, desc_pool_infos, true, 2); for (int i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) { FiniteRenderWriteSetInfo buffer_write_info = { .dstSet = render->vk_descriptor[i], .dstBinding = 0, .dstArrayElement = 0, .descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER }; FiniteRenderWriteSetInfo image_write_info = { .dstSet = render->vk_descriptor[i], .dstBinding = 1, .dstArrayElement = 0, .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER }; FiniteRenderWriteSetInfo *write_infos[2] = {&buffer_write_info, &image_write_info}; FiniteRenderDescriptorInfo desc_info = { .type = FINITE_DESCRIPTOR_MULTI, .buffer = render->vk_uniformBuf[i], .buffer_offset = 0, .buffer_range = sizeof(UniformBufferObject), .image_layout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, .image_view = image->textureImageView, .image_sampler = image->textureSampler }; finite_render_write_to_descriptor(render, write_infos, &desc_info, 2); } for (int i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) { // create two semaphores and one fence finite_render_create_semaphore(render); //images available finite_render_create_semaphore(render); // renderFinished finite_render_create_fence(render, VK_FENCE_CREATE_SIGNALED_BIT); } // * use pending state!!! int state = wl_display_dispatch_pending(myShell->display); FINITE_LOG(\"Success! Dispatch state: %d\", state); // multithread here pthread_t id; pthread_create(&id, NULL, playMusic, &dev); // keyboard demo for additional funny // FiniteKeyboard *kbd = finite_input_keyboard_init(myShell->display); // FiniteKey xKey = finite_key_from_string(\"X\"); // if (!finite_key_valid(xKey)) { // printf(\"Unable to poll NULL key\"); // exit(EXIT_FAILURE); // } // create wayland frame loop while (wl_display_dispatch_pending(myShell->display) != -1) { // poll for input // finite_input_poll_keys(kbd, myShell); // // handle input // if (finite_key_pressed(xKey, kbd)) { // printf(\"Attempting to pause\\n\"); // finite_audio_pause(dev); // } // with framesInFlight we need to offset where the indexes are. For reference: // 0 -> imagesAvailable // 1 -> renderFinished // so offset is i + (2 * currentFrame) with since its two items. render->_currentFrame = (render->_currentFrame + 1) % MAX_FRAMES_IN_FLIGHT; int currentFence = 0 + (1 * render->_currentFrame); int currentSignal = 0 + (2 * render->_currentFrame); // printf(\"Current Fence: %d (%p) \\nCurrent Signal: %d (%p)\\n\", currentFence, render->fences[currentFence], currentSignal, render->signals[currentSignal]); // handle custom rendering here vkWaitForFences(render->vk_device, 1, &render->fences[currentFence], VK_TRUE, UINT64_MAX); vkResetFences(render->vk_device, 1, &render->fences[currentFence]); // printf(\"Current Fence %d (%p) was reset.\\nCurrent Signal: %d (%p)\\n\", currentFence, render->fences[currentFence], currentSignal, render->signals[currentSignal]); uint32_t index; vkAcquireNextImageKHR(render->vk_device, render->vk_swapchain, UINT64_MAX, render->signals[currentSignal], VK_NULL_HANDLE, &index); vkResetCommandBuffer(render->vk_buffer[render->_currentFrame], 0); // printf(\"recording\\n\"); finite_render_record_command_buffer(render, index); // printf(\"Attempting to rotate\\n\"); updateUniformBuffer(render, index); // printf(\"Rotate finished\\n\"); VkPipelineStageFlags waitStage = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; FiniteRenderSubmitInfo submit_info = { ._waitSemaphores = 1, .waitSemaphores = &render->signals[currentSignal], .waitDstStageMask = &waitStage, ._commandBuffs = 1, .commandBuffs = &render->vk_buffer[render->_currentFrame], ._signalSemaphores = 1, .signalSemaphores = &render->signals[currentSignal + 1] }; // printf(\"submitting\\n\"); // the safeExit param determines whether we want to have finite_render_submit_frame cleanup and exit on failure finite_render_submit_frame(render, &submit_info, currentFence, false); VkSwapchainKHR swapchains[] = {render->vk_swapchain}; FiniteRenderPresentInfo present_info = { ._waitSemaphores = 1, .waitSemaphores = &render->signals[currentSignal + 1], ._swapchains = 1, .swapchains = swapchains, .imageIndices = &index, .results = NULL }; // printf(\"presenting\\n\"); finite_render_present_frame(render, &present_info, false); // render->_currentFrame = (render->_currentFrame + 1) % MAX_FRAMES_IN_FLIGHT; // printf(\"Current Frame: %d\\n\", render->_currentFrame); } vkDeviceWaitIdle(render->vk_device); FiniteRenderImage *imgs = {image}; finite_render_cleanup_textures(render, imgs, 1); finite_render_cleanup(render); }","title":"Cube"},{"location":"examples/cube/#video-example","text":"","title":"Video Example"},{"location":"examples/draw/","text":"","title":"Draw"},{"location":"examples/render/","text":"","title":"Render"},{"location":"reference/enums/FiniteDirectionType/","text":"FiniteDirectionType * \u2754 FiniteDirectionType was last modified in 0.4.0 typedef enum { FINITE_DIRECTION_UP, FINITE_DIRECTION_DOWN, FINITE_DIRECTION_LEFT, FINITE_DIRECTION_RIGHT, FINITE_DIRECTION_LEFT_UP, FINITE_DIRECTION_LEFT_DOWN, FINITE_DIRECTION_RIGHT_UP, FINITE_DIRECTION_RIGHT_DOWN } FiniteDirectionType; The FiniteDirectionType enum describes FiniteBtn directions Standard Usage * When creating a FiniteBtn this enum is expected as a parameter for finite_button_create_relation() Related Docs * finite_button_create_relation","title":"FiniteDirectionType"},{"location":"reference/enums/FiniteDirectionType/#finitedirectiontype","text":"\u2754 FiniteDirectionType was last modified in 0.4.0 typedef enum { FINITE_DIRECTION_UP, FINITE_DIRECTION_DOWN, FINITE_DIRECTION_LEFT, FINITE_DIRECTION_RIGHT, FINITE_DIRECTION_LEFT_UP, FINITE_DIRECTION_LEFT_DOWN, FINITE_DIRECTION_RIGHT_UP, FINITE_DIRECTION_RIGHT_DOWN } FiniteDirectionType; The FiniteDirectionType enum describes FiniteBtn directions","title":"FiniteDirectionType"},{"location":"reference/enums/FiniteDirectionType/#standard-usage","text":"When creating a FiniteBtn this enum is expected as a parameter for finite_button_create_relation()","title":"Standard Usage"},{"location":"reference/enums/FiniteDirectionType/#related-docs","text":"finite_button_create_relation","title":"Related Docs"},{"location":"reference/enums/FiniteKey/","text":"FiniteKey * Below are all valid Finite_Key types typedef enum { // Letters FINITE_KEY_A, FINITE_KEY_B, FINITE_KEY_C, FINITE_KEY_D, FINITE_KEY_E, FINITE_KEY_F, FINITE_KEY_G, FINITE_KEY_H, FINITE_KEY_I, FINITE_KEY_J, FINITE_KEY_K, FINITE_KEY_L, FINITE_KEY_M, FINITE_KEY_N, FINITE_KEY_O, FINITE_KEY_P, FINITE_KEY_Q, FINITE_KEY_R, FINITE_KEY_S, FINITE_KEY_T, FINITE_KEY_U, FINITE_KEY_V, FINITE_KEY_W, FINITE_KEY_X, FINITE_KEY_Y, FINITE_KEY_Z, // Numbers FINITE_KEY_0, FINITE_KEY_1, FINITE_KEY_2, FINITE_KEY_3, FINITE_KEY_4, FINITE_KEY_5, FINITE_KEY_6, FINITE_KEY_7, FINITE_KEY_8, FINITE_KEY_9, // Modifiers FINITE_KEY_LEFT_SHIFT, FINITE_KEY_RIGHT_SHIFT, FINITE_KEY_LEFT_CTRL, FINITE_KEY_RIGHT_CTRL, FINITE_KEY_LEFT_ALT, FINITE_KEY_RIGHT_ALT, FINITE_KEY_LEFT_META, FINITE_KEY_RIGHT_META, // Function Keys FINITE_KEY_F1, FINITE_KEY_F2, FINITE_KEY_F3, FINITE_KEY_F4, FINITE_KEY_F5, FINITE_KEY_F6, FINITE_KEY_F7, FINITE_KEY_F8, FINITE_KEY_F9, FINITE_KEY_F10, FINITE_KEY_F11, FINITE_KEY_F12, // Arrows FINITE_KEY_UP, FINITE_KEY_DOWN, FINITE_KEY_LEFT, FINITE_KEY_RIGHT, // Other Keys FINITE_KEY_SPACE, FINITE_KEY_ENTER, FINITE_KEY_ESCAPE, FINITE_KEY_TAB, FINITE_KEY_BACKSPACE, FINITE_KEY_CAPS_LOCK, // Symbols and Punctuation FINITE_KEY_MINUS, FINITE_KEY_EQUALS, FINITE_KEY_LEFT_BRACKET, FINITE_KEY_RIGHT_BRACKET, FINITE_KEY_BACKSLASH, FINITE_KEY_SEMICOLON, FINITE_KEY_APOSTROPHE, FINITE_KEY_GRAVE, FINITE_KEY_COMMA, FINITE_KEY_PERIOD, FINITE_KEY_SLASH, // Meta FINITE_KEY_PRINT_SCREEN, FINITE_KEY_SCROLL_LOCK, FINITE_KEY_PAUSE, FINITE_KEY_INSERT, FINITE_KEY_DELETE, FINITE_KEY_HOME, FINITE_KEY_END, FINITE_KEY_PAGE_UP, FINITE_KEY_PAGE_DOWN, // NumPad FINITE_KEY_NUM_LOCK, FINITE_KEY_KP_DIVIDE, FINITE_KEY_KP_MULTIPLY, FINITE_KEY_KP_MINUS, FINITE_KEY_KP_PLUS, FINITE_KEY_KP_ENTER, FINITE_KEY_KP_0, FINITE_KEY_KP_1, FINITE_KEY_KP_2, FINITE_KEY_KP_3, FINITE_KEY_KP_4, FINITE_KEY_KP_5, FINITE_KEY_KP_6, FINITE_KEY_KP_7, FINITE_KEY_KP_8, FINITE_KEY_KP_9, FINITE_KEY_KP_PERIOD, // Sentinel FINITE_KEY_INVALID, FINITE_KEY_COUNT } FiniteKey;","title":"FiniteKey"},{"location":"reference/enums/FiniteKey/#finitekey","text":"Below are all valid Finite_Key types typedef enum { // Letters FINITE_KEY_A, FINITE_KEY_B, FINITE_KEY_C, FINITE_KEY_D, FINITE_KEY_E, FINITE_KEY_F, FINITE_KEY_G, FINITE_KEY_H, FINITE_KEY_I, FINITE_KEY_J, FINITE_KEY_K, FINITE_KEY_L, FINITE_KEY_M, FINITE_KEY_N, FINITE_KEY_O, FINITE_KEY_P, FINITE_KEY_Q, FINITE_KEY_R, FINITE_KEY_S, FINITE_KEY_T, FINITE_KEY_U, FINITE_KEY_V, FINITE_KEY_W, FINITE_KEY_X, FINITE_KEY_Y, FINITE_KEY_Z, // Numbers FINITE_KEY_0, FINITE_KEY_1, FINITE_KEY_2, FINITE_KEY_3, FINITE_KEY_4, FINITE_KEY_5, FINITE_KEY_6, FINITE_KEY_7, FINITE_KEY_8, FINITE_KEY_9, // Modifiers FINITE_KEY_LEFT_SHIFT, FINITE_KEY_RIGHT_SHIFT, FINITE_KEY_LEFT_CTRL, FINITE_KEY_RIGHT_CTRL, FINITE_KEY_LEFT_ALT, FINITE_KEY_RIGHT_ALT, FINITE_KEY_LEFT_META, FINITE_KEY_RIGHT_META, // Function Keys FINITE_KEY_F1, FINITE_KEY_F2, FINITE_KEY_F3, FINITE_KEY_F4, FINITE_KEY_F5, FINITE_KEY_F6, FINITE_KEY_F7, FINITE_KEY_F8, FINITE_KEY_F9, FINITE_KEY_F10, FINITE_KEY_F11, FINITE_KEY_F12, // Arrows FINITE_KEY_UP, FINITE_KEY_DOWN, FINITE_KEY_LEFT, FINITE_KEY_RIGHT, // Other Keys FINITE_KEY_SPACE, FINITE_KEY_ENTER, FINITE_KEY_ESCAPE, FINITE_KEY_TAB, FINITE_KEY_BACKSPACE, FINITE_KEY_CAPS_LOCK, // Symbols and Punctuation FINITE_KEY_MINUS, FINITE_KEY_EQUALS, FINITE_KEY_LEFT_BRACKET, FINITE_KEY_RIGHT_BRACKET, FINITE_KEY_BACKSLASH, FINITE_KEY_SEMICOLON, FINITE_KEY_APOSTROPHE, FINITE_KEY_GRAVE, FINITE_KEY_COMMA, FINITE_KEY_PERIOD, FINITE_KEY_SLASH, // Meta FINITE_KEY_PRINT_SCREEN, FINITE_KEY_SCROLL_LOCK, FINITE_KEY_PAUSE, FINITE_KEY_INSERT, FINITE_KEY_DELETE, FINITE_KEY_HOME, FINITE_KEY_END, FINITE_KEY_PAGE_UP, FINITE_KEY_PAGE_DOWN, // NumPad FINITE_KEY_NUM_LOCK, FINITE_KEY_KP_DIVIDE, FINITE_KEY_KP_MULTIPLY, FINITE_KEY_KP_MINUS, FINITE_KEY_KP_PLUS, FINITE_KEY_KP_ENTER, FINITE_KEY_KP_0, FINITE_KEY_KP_1, FINITE_KEY_KP_2, FINITE_KEY_KP_3, FINITE_KEY_KP_4, FINITE_KEY_KP_5, FINITE_KEY_KP_6, FINITE_KEY_KP_7, FINITE_KEY_KP_8, FINITE_KEY_KP_9, FINITE_KEY_KP_PERIOD, // Sentinel FINITE_KEY_INVALID, FINITE_KEY_COUNT } FiniteKey;","title":"FiniteKey"},{"location":"reference/enums/FiniteShaderType/","text":"FiniteShaderType * \u2754 FiniteShaderType was last modified in 0.4.0 typedef enum FiniteShaderType FiniteShaderType; enum FiniteShaderType { FINITE_SHADER_TYPE_VERTEX, FINITE_SHADER_TYPE_FRAGMENT }; The FiniteShaderType enum describes a type of shader to be used in FiniteRenderShaderStageInfo Standard Usage * When creating a FiniteRenderShaderStageInfo this enum is expected as a parameter. Related Docs * FiniteRenderShaderStageInfo","title":"FiniteShaderType"},{"location":"reference/enums/FiniteShaderType/#finiteshadertype","text":"\u2754 FiniteShaderType was last modified in 0.4.0 typedef enum FiniteShaderType FiniteShaderType; enum FiniteShaderType { FINITE_SHADER_TYPE_VERTEX, FINITE_SHADER_TYPE_FRAGMENT }; The FiniteShaderType enum describes a type of shader to be used in FiniteRenderShaderStageInfo","title":"FiniteShaderType"},{"location":"reference/enums/FiniteShaderType/#standard-usage","text":"When creating a FiniteRenderShaderStageInfo this enum is expected as a parameter.","title":"Standard Usage"},{"location":"reference/enums/FiniteShaderType/#related-docs","text":"FiniteRenderShaderStageInfo","title":"Related Docs"},{"location":"reference/functions/audio/finite_audio_cleanup/","text":"finite_audio_cleanup * \u2754 finite_audio_cleanup was last modified in v0.6.0 . void finite_audio_cleanup(FinitePlaybackDevice *dev) The finite_audio_pause attempts to pause or unpause an audio file from a FinitePlaybackDevice . Parameters * Type Decription FinitePlaybackDevice *dev The FinitePlaybackDevice to destroy. Code Example * #include <finite/audio.h> #include <finite/log.h> FinitePlaybackDevice *dev = finite_audio_device_init(); char *jingle = \"jingle2.mp3\"; finite_audio_get_audio_params(jingle, dev); // print out the audio duration finite_audio_get_audio_duration(dev); // use params to init audio finite_audio_init_audio(dev, jingle, false); // audio is made so now play finite_audio_play(dev); FINITE_LOG(\"Done\\n\"); // clean up when finished finite_audio_cleanup(dev); Standard Usage * This function requires a valid FinitePlaybackDevice . Related Docs * finite_audio_play FinitePlaybackDevice","title":"finite_audio_cleanup"},{"location":"reference/functions/audio/finite_audio_cleanup/#finite_audio_cleanup","text":"\u2754 finite_audio_cleanup was last modified in v0.6.0 . void finite_audio_cleanup(FinitePlaybackDevice *dev) The finite_audio_pause attempts to pause or unpause an audio file from a FinitePlaybackDevice .","title":"finite_audio_cleanup"},{"location":"reference/functions/audio/finite_audio_cleanup/#parameters","text":"Type Decription FinitePlaybackDevice *dev The FinitePlaybackDevice to destroy.","title":"Parameters"},{"location":"reference/functions/audio/finite_audio_cleanup/#code-example","text":"#include <finite/audio.h> #include <finite/log.h> FinitePlaybackDevice *dev = finite_audio_device_init(); char *jingle = \"jingle2.mp3\"; finite_audio_get_audio_params(jingle, dev); // print out the audio duration finite_audio_get_audio_duration(dev); // use params to init audio finite_audio_init_audio(dev, jingle, false); // audio is made so now play finite_audio_play(dev); FINITE_LOG(\"Done\\n\"); // clean up when finished finite_audio_cleanup(dev);","title":"Code Example"},{"location":"reference/functions/audio/finite_audio_cleanup/#standard-usage","text":"This function requires a valid FinitePlaybackDevice .","title":"Standard Usage"},{"location":"reference/functions/audio/finite_audio_cleanup/#related-docs","text":"finite_audio_play FinitePlaybackDevice","title":"Related Docs"},{"location":"reference/functions/audio/finite_audio_device_init/","text":"finite_audio_device_init * bool finite_audio_device_init() The finite_audio_device_init attempts to create a new FinitePlaybackDevice Code Example * #include <finite/audio.h> #include <finite/log.h> FinitePlaybackDevice *dev = finite_audio_device_init(); char *jingle = \"jingle2.mp3\"; finite_audio_get_audio_params(jingle, dev); // print out the audio duration finite_audio_get_audio_duration(dev); // use params to init audio finite_audio_init_audio(dev, jingle, false); // audio is made so now play finite_audio_play(dev); FINITE_LOG(\"Done\\n\"); // clean up when finished finite_audio_cleanup(dev); Notes * As of v0.6.0 FinitePlaybackDevice is not attached to a window. That is subject to change. Standard Usage * This function should be created once for a single audio. Do not reuse FinitePlaybackDevices . Related Docs * FinitePlaybackDevice","title":"finite_audio_device_init"},{"location":"reference/functions/audio/finite_audio_device_init/#finite_audio_device_init","text":"bool finite_audio_device_init() The finite_audio_device_init attempts to create a new FinitePlaybackDevice","title":"finite_audio_device_init"},{"location":"reference/functions/audio/finite_audio_device_init/#code-example","text":"#include <finite/audio.h> #include <finite/log.h> FinitePlaybackDevice *dev = finite_audio_device_init(); char *jingle = \"jingle2.mp3\"; finite_audio_get_audio_params(jingle, dev); // print out the audio duration finite_audio_get_audio_duration(dev); // use params to init audio finite_audio_init_audio(dev, jingle, false); // audio is made so now play finite_audio_play(dev); FINITE_LOG(\"Done\\n\"); // clean up when finished finite_audio_cleanup(dev);","title":"Code Example"},{"location":"reference/functions/audio/finite_audio_device_init/#notes","text":"As of v0.6.0 FinitePlaybackDevice is not attached to a window. That is subject to change.","title":"Notes"},{"location":"reference/functions/audio/finite_audio_device_init/#standard-usage","text":"This function should be created once for a single audio. Do not reuse FinitePlaybackDevices .","title":"Standard Usage"},{"location":"reference/functions/audio/finite_audio_device_init/#related-docs","text":"FinitePlaybackDevice","title":"Related Docs"},{"location":"reference/functions/audio/finite_audio_get_audio_duration/","text":"finite_audio_get_audio_duration * \u2754 finite_audio_get_audio_duration was last modified in v0.6.0 . FinitePlaybackDuration finite_audio_get_audio_duration(FinitePlaybackDevice *dev) The finite_audio_get_audio_duration grabs a FinitePlaybackDuration of a given a FinitePlaybackDevice Parameters * Type Decription FinitePlaybackDevice *dev The FinitePlaybackDevice to get the audio duration from. Code Example * #include <finite/audio.h> #include <finite/log.h> FinitePlaybackDevice *dev = finite_audio_device_init(); char *jingle = \"jingle2.mp3\"; finite_audio_get_audio_params(jingle, dev); // print out the audio duration finite_audio_get_audio_duration(dev); // use params to init audio finite_audio_init_audio(dev, jingle, false); // audio is made so now play finite_audio_play(dev); FINITE_LOG(\"Done\\n\"); // clean up when finished finite_audio_cleanup(dev); Standard Usage * This function requires a valid FinitePlaybackDevice . Related Docs * FinitePlaybackDevice FinitePlaybackDuration","title":"finite_audio_get_audio_duration"},{"location":"reference/functions/audio/finite_audio_get_audio_duration/#finite_audio_get_audio_duration","text":"\u2754 finite_audio_get_audio_duration was last modified in v0.6.0 . FinitePlaybackDuration finite_audio_get_audio_duration(FinitePlaybackDevice *dev) The finite_audio_get_audio_duration grabs a FinitePlaybackDuration of a given a FinitePlaybackDevice","title":"finite_audio_get_audio_duration"},{"location":"reference/functions/audio/finite_audio_get_audio_duration/#parameters","text":"Type Decription FinitePlaybackDevice *dev The FinitePlaybackDevice to get the audio duration from.","title":"Parameters"},{"location":"reference/functions/audio/finite_audio_get_audio_duration/#code-example","text":"#include <finite/audio.h> #include <finite/log.h> FinitePlaybackDevice *dev = finite_audio_device_init(); char *jingle = \"jingle2.mp3\"; finite_audio_get_audio_params(jingle, dev); // print out the audio duration finite_audio_get_audio_duration(dev); // use params to init audio finite_audio_init_audio(dev, jingle, false); // audio is made so now play finite_audio_play(dev); FINITE_LOG(\"Done\\n\"); // clean up when finished finite_audio_cleanup(dev);","title":"Code Example"},{"location":"reference/functions/audio/finite_audio_get_audio_duration/#standard-usage","text":"This function requires a valid FinitePlaybackDevice .","title":"Standard Usage"},{"location":"reference/functions/audio/finite_audio_get_audio_duration/#related-docs","text":"FinitePlaybackDevice FinitePlaybackDuration","title":"Related Docs"},{"location":"reference/functions/audio/finite_audio_get_audio_params/","text":"finite_audio_get_audio_params * \u2754 finite_audio_get_audio_params was last modified in v0.6.0 . bool finite_audio_get_audio_params(FinitePlaybackDevice *dev, char* audio) The finite_audio_get_audio_params gives the required audio hardware params for a given a audio file to a FinitePlaybackDevice Parameters * Type Decription FinitePlaybackDevice *dev The FinitePlaybackDevice to get the audio params for. char* audio The path to the audio file Code Example * #include <finite/audio.h> #include <finite/log.h> FinitePlaybackDevice *dev = finite_audio_device_init(); char *jingle = \"jingle2.mp3\"; finite_audio_get_audio_params(jingle, dev); // print out the audio duration finite_audio_get_audio_duration(dev); // use params to init audio finite_audio_init_audio(dev, jingle, false); // audio is made so now play finite_audio_play(dev); FINITE_LOG(\"Done\\n\"); // clean up when finished finite_audio_cleanup(dev); Notes * This function should only be call once per FinitePlaybackDevice . Standard Usage * This function requires a valid FinitePlaybackDevice . Related Docs * FinitePlaybackDevice","title":"finite_audio_get_audio_params"},{"location":"reference/functions/audio/finite_audio_get_audio_params/#finite_audio_get_audio_params","text":"\u2754 finite_audio_get_audio_params was last modified in v0.6.0 . bool finite_audio_get_audio_params(FinitePlaybackDevice *dev, char* audio) The finite_audio_get_audio_params gives the required audio hardware params for a given a audio file to a FinitePlaybackDevice","title":"finite_audio_get_audio_params"},{"location":"reference/functions/audio/finite_audio_get_audio_params/#parameters","text":"Type Decription FinitePlaybackDevice *dev The FinitePlaybackDevice to get the audio params for. char* audio The path to the audio file","title":"Parameters"},{"location":"reference/functions/audio/finite_audio_get_audio_params/#code-example","text":"#include <finite/audio.h> #include <finite/log.h> FinitePlaybackDevice *dev = finite_audio_device_init(); char *jingle = \"jingle2.mp3\"; finite_audio_get_audio_params(jingle, dev); // print out the audio duration finite_audio_get_audio_duration(dev); // use params to init audio finite_audio_init_audio(dev, jingle, false); // audio is made so now play finite_audio_play(dev); FINITE_LOG(\"Done\\n\"); // clean up when finished finite_audio_cleanup(dev);","title":"Code Example"},{"location":"reference/functions/audio/finite_audio_get_audio_params/#notes","text":"This function should only be call once per FinitePlaybackDevice .","title":"Notes"},{"location":"reference/functions/audio/finite_audio_get_audio_params/#standard-usage","text":"This function requires a valid FinitePlaybackDevice .","title":"Standard Usage"},{"location":"reference/functions/audio/finite_audio_get_audio_params/#related-docs","text":"FinitePlaybackDevice","title":"Related Docs"},{"location":"reference/functions/audio/finite_audio_init_audio/","text":"finite_audio_init_audio * \u2754 finite_audio_init_audio was last modified in v0.6.0 . bool finite_audio_init_audio(FinitePlaybackDevice *dev, char* audio, bool autoCreate) The finite_audio_init_audio attempts to attach an audio file to a FinitePlaybackDevice Parameters * Type Decription FinitePlaybackDevice *dev The FinitePlaybackDevice to attach the audio to. char* audio The path to the audio file `bool autocreate Determines if this function should attempt to grab the hardware params for the audio before attaching it. Code Example * #include <finite/audio.h> #include <finite/log.h> FinitePlaybackDevice *dev = finite_audio_device_init(); char *jingle = \"jingle2.mp3\"; finite_audio_get_audio_params(jingle, dev); // print out the audio duration finite_audio_get_audio_duration(dev); // use params to init audio finite_audio_init_audio(dev, jingle, false); // audio is made so now play finite_audio_play(dev); FINITE_LOG(\"Done\\n\"); // clean up when finished finite_audio_cleanup(dev); Notes * The autocreate param determines if the audio params should be grabbed automatically. If you previously called finite_audio_get_audio_params you MUST set this to false. Standard Usage * This function requires a valid FinitePlaybackDevice . The path to the audio is relative to the package. As such you should bundle your audio into your project with meson. Related Docs * finite_audio_get_audio_params FinitePlaybackDevice","title":"finite_audio_init_audio"},{"location":"reference/functions/audio/finite_audio_init_audio/#finite_audio_init_audio","text":"\u2754 finite_audio_init_audio was last modified in v0.6.0 . bool finite_audio_init_audio(FinitePlaybackDevice *dev, char* audio, bool autoCreate) The finite_audio_init_audio attempts to attach an audio file to a FinitePlaybackDevice","title":"finite_audio_init_audio"},{"location":"reference/functions/audio/finite_audio_init_audio/#parameters","text":"Type Decription FinitePlaybackDevice *dev The FinitePlaybackDevice to attach the audio to. char* audio The path to the audio file `bool autocreate Determines if this function should attempt to grab the hardware params for the audio before attaching it.","title":"Parameters"},{"location":"reference/functions/audio/finite_audio_init_audio/#code-example","text":"#include <finite/audio.h> #include <finite/log.h> FinitePlaybackDevice *dev = finite_audio_device_init(); char *jingle = \"jingle2.mp3\"; finite_audio_get_audio_params(jingle, dev); // print out the audio duration finite_audio_get_audio_duration(dev); // use params to init audio finite_audio_init_audio(dev, jingle, false); // audio is made so now play finite_audio_play(dev); FINITE_LOG(\"Done\\n\"); // clean up when finished finite_audio_cleanup(dev);","title":"Code Example"},{"location":"reference/functions/audio/finite_audio_init_audio/#notes","text":"The autocreate param determines if the audio params should be grabbed automatically. If you previously called finite_audio_get_audio_params you MUST set this to false.","title":"Notes"},{"location":"reference/functions/audio/finite_audio_init_audio/#standard-usage","text":"This function requires a valid FinitePlaybackDevice . The path to the audio is relative to the package. As such you should bundle your audio into your project with meson.","title":"Standard Usage"},{"location":"reference/functions/audio/finite_audio_init_audio/#related-docs","text":"finite_audio_get_audio_params FinitePlaybackDevice","title":"Related Docs"},{"location":"reference/functions/audio/finite_audio_pause/","text":"finite_audio_pause * \u2754 finite_audio_pause was last modified in v0.6.0 . bool finite_audio_pause(FinitePlaybackDevice *dev) The finite_audio_pause attempts to pause or unpause an audio file from a FinitePlaybackDevice . Parameters * Type Decription FinitePlaybackDevice *dev The FinitePlaybackDevice to get the audio to pause from. Notes * This function only works in a multi-threaded environment. Calling this function in the same thread as finite_audio_play makes this function a NOP. This function can both pause and unpause functions, while the now depricated finite_audio_unpause function can only unpause paused audio. Use this function instead. Standard Usage * This function requires a valid FinitePlaybackDevice . Related Docs * finite_audio_play finite_audio_unpause FinitePlaybackDevice","title":"finite_audio_pause"},{"location":"reference/functions/audio/finite_audio_pause/#finite_audio_pause","text":"\u2754 finite_audio_pause was last modified in v0.6.0 . bool finite_audio_pause(FinitePlaybackDevice *dev) The finite_audio_pause attempts to pause or unpause an audio file from a FinitePlaybackDevice .","title":"finite_audio_pause"},{"location":"reference/functions/audio/finite_audio_pause/#parameters","text":"Type Decription FinitePlaybackDevice *dev The FinitePlaybackDevice to get the audio to pause from.","title":"Parameters"},{"location":"reference/functions/audio/finite_audio_pause/#notes","text":"This function only works in a multi-threaded environment. Calling this function in the same thread as finite_audio_play makes this function a NOP. This function can both pause and unpause functions, while the now depricated finite_audio_unpause function can only unpause paused audio. Use this function instead.","title":"Notes"},{"location":"reference/functions/audio/finite_audio_pause/#standard-usage","text":"This function requires a valid FinitePlaybackDevice .","title":"Standard Usage"},{"location":"reference/functions/audio/finite_audio_pause/#related-docs","text":"finite_audio_play finite_audio_unpause FinitePlaybackDevice","title":"Related Docs"},{"location":"reference/functions/audio/finite_audio_play/","text":"finite_audio_play * \u2754 finite_audio_play was last modified in v0.6.0 . void finite_audio_play(FinitePlaybackDevice *dev) The finite_audio_play attempts to play an audio file from a FinitePlaybackDevice Parameters * Type Decription FinitePlaybackDevice *dev The FinitePlaybackDevice to get the audio to play from. Code Example * #include <finite/audio.h> #include <finite/log.h> FinitePlaybackDevice *dev = finite_audio_device_init(); char *jingle = \"jingle2.mp3\"; finite_audio_get_audio_params(jingle, dev); // print out the audio duration finite_audio_get_audio_duration(dev); // use params to init audio finite_audio_init_audio(dev, jingle, false); // audio is made so now play finite_audio_play(dev); FINITE_LOG(\"Done\\n\"); // clean up when finished finite_audio_cleanup(dev); Standard Usage * This function requires a valid FinitePlaybackDevice . Playing audio is a halting function. For the best performance, handle audio in a seperate thread. Related Docs * finite_audio_get_audio_params FinitePlaybackDevice","title":"finite_audio_play"},{"location":"reference/functions/audio/finite_audio_play/#finite_audio_play","text":"\u2754 finite_audio_play was last modified in v0.6.0 . void finite_audio_play(FinitePlaybackDevice *dev) The finite_audio_play attempts to play an audio file from a FinitePlaybackDevice","title":"finite_audio_play"},{"location":"reference/functions/audio/finite_audio_play/#parameters","text":"Type Decription FinitePlaybackDevice *dev The FinitePlaybackDevice to get the audio to play from.","title":"Parameters"},{"location":"reference/functions/audio/finite_audio_play/#code-example","text":"#include <finite/audio.h> #include <finite/log.h> FinitePlaybackDevice *dev = finite_audio_device_init(); char *jingle = \"jingle2.mp3\"; finite_audio_get_audio_params(jingle, dev); // print out the audio duration finite_audio_get_audio_duration(dev); // use params to init audio finite_audio_init_audio(dev, jingle, false); // audio is made so now play finite_audio_play(dev); FINITE_LOG(\"Done\\n\"); // clean up when finished finite_audio_cleanup(dev);","title":"Code Example"},{"location":"reference/functions/audio/finite_audio_play/#standard-usage","text":"This function requires a valid FinitePlaybackDevice . Playing audio is a halting function. For the best performance, handle audio in a seperate thread.","title":"Standard Usage"},{"location":"reference/functions/audio/finite_audio_play/#related-docs","text":"finite_audio_get_audio_params FinitePlaybackDevice","title":"Related Docs"},{"location":"reference/functions/audio/finite_audio_stop/","text":"finite_audio_stop * \u2754 finite_audio_stop was last modified in v0.6.0 . bool finite_audio_stop(FinitePlaybackDevice *dev) The finite_audio_stop attempts to stop an audio file from a FinitePlaybackDevice Parameters * Type Decription FinitePlaybackDevice *dev The FinitePlaybackDevice to get the audio to stop from. Notes * This function only works in a multi-threaded environment. Calling this function in the same thread as finite_audio_play makes this function a NOP. Standard Usage * This function requires a valid FinitePlaybackDevice . Related Docs * finite_audio_play FinitePlaybackDevice","title":"finite_audio_stop"},{"location":"reference/functions/audio/finite_audio_stop/#finite_audio_stop","text":"\u2754 finite_audio_stop was last modified in v0.6.0 . bool finite_audio_stop(FinitePlaybackDevice *dev) The finite_audio_stop attempts to stop an audio file from a FinitePlaybackDevice","title":"finite_audio_stop"},{"location":"reference/functions/audio/finite_audio_stop/#parameters","text":"Type Decription FinitePlaybackDevice *dev The FinitePlaybackDevice to get the audio to stop from.","title":"Parameters"},{"location":"reference/functions/audio/finite_audio_stop/#notes","text":"This function only works in a multi-threaded environment. Calling this function in the same thread as finite_audio_play makes this function a NOP.","title":"Notes"},{"location":"reference/functions/audio/finite_audio_stop/#standard-usage","text":"This function requires a valid FinitePlaybackDevice .","title":"Standard Usage"},{"location":"reference/functions/audio/finite_audio_stop/#related-docs","text":"finite_audio_play FinitePlaybackDevice","title":"Related Docs"},{"location":"reference/functions/audio/finite_audio_unpause/","text":"finite_audio_unpause * \u2754 finite_audio_unpause was last modified in v0.6.0 . \u26a0 finite_audio_unpause is depricated as of v0.6.0 and may be removed in future. Check the Notes section for more information. bool finite_audio_unpause(FinitePlaybackDevice *dev) The finite_audio_unpause attempts to unpause an audio file from a FinitePlaybackDevice . Parameters * Type Decription FinitePlaybackDevice *dev The FinitePlaybackDevice to get the audio to unpause from. Notes * This function only works in a multi-threaded environment. Calling this function in the same thread as finite_audio_play makes this function a NOP. This function can only unpause audio, while the newer finite_audio_pause function can both pause and unpause audio. Use this finite_audio_pause instead. Standard Usage * This function requires a valid FinitePlaybackDevice . Related Docs * finite_audio_play finite_audio_pause FinitePlaybackDevice","title":"finite_audio_unpause"},{"location":"reference/functions/audio/finite_audio_unpause/#finite_audio_unpause","text":"\u2754 finite_audio_unpause was last modified in v0.6.0 . \u26a0 finite_audio_unpause is depricated as of v0.6.0 and may be removed in future. Check the Notes section for more information. bool finite_audio_unpause(FinitePlaybackDevice *dev) The finite_audio_unpause attempts to unpause an audio file from a FinitePlaybackDevice .","title":"finite_audio_unpause"},{"location":"reference/functions/audio/finite_audio_unpause/#parameters","text":"Type Decription FinitePlaybackDevice *dev The FinitePlaybackDevice to get the audio to unpause from.","title":"Parameters"},{"location":"reference/functions/audio/finite_audio_unpause/#notes","text":"This function only works in a multi-threaded environment. Calling this function in the same thread as finite_audio_play makes this function a NOP. This function can only unpause audio, while the newer finite_audio_pause function can both pause and unpause audio. Use this finite_audio_pause instead.","title":"Notes"},{"location":"reference/functions/audio/finite_audio_unpause/#standard-usage","text":"This function requires a valid FinitePlaybackDevice .","title":"Standard Usage"},{"location":"reference/functions/audio/finite_audio_unpause/#related-docs","text":"finite_audio_play finite_audio_pause FinitePlaybackDevice","title":"Related Docs"},{"location":"reference/functions/draw/finite_draw_cleanup/","text":"finite_draw_cleanup * \u2754 finite_draw_cleanup was last modified in v0.6.0 . bool finite_draw_cleanup(FiniteShell *shell) The finite_draw_cleanup function attempts to clean up and destroy the window. Parameters * Type Decription FiniteShell *shell The FiniteShell where the window is. Code Example * #include <finite/draw.h> FiniteGradientPoint points[2] = { {0, 0.325, 0.325, 0.325, alpha}, {0.5, 0.207, 0.207, 0.207, alpha} }; cairo_pattern_t *pat = finite_draw_pattern_linear(0,0, (double)shell->details->width, (double)shell->details->height, points, 2); finite_draw_rect(shell, 0,0, shell->details->width, shell->details->height, NULL, pat); cairo_pattern_destroy(pat); finite_draw_finish(shell, shell->details->width, shell->details->height, shell->stride, true); while (wl_display_dispatch(shell->display) != -1) { FINITE_LOG(\"Window is open.\"); } finite_draw_cleanup(shell); Standard Usage * This function must have a valid FiniteShell This function uses Cairo which requires a valid cairo_surface_t in FiniteShell implementation (shell.cairo_surface) beforehand. This function destroys and cleans up. It must be called at the end of an application that uses Cairo. Related Docs * FiniteShell finite_draw_finish","title":"finite_draw_cleanup"},{"location":"reference/functions/draw/finite_draw_cleanup/#finite_draw_cleanup","text":"\u2754 finite_draw_cleanup was last modified in v0.6.0 . bool finite_draw_cleanup(FiniteShell *shell) The finite_draw_cleanup function attempts to clean up and destroy the window.","title":"finite_draw_cleanup"},{"location":"reference/functions/draw/finite_draw_cleanup/#parameters","text":"Type Decription FiniteShell *shell The FiniteShell where the window is.","title":"Parameters"},{"location":"reference/functions/draw/finite_draw_cleanup/#code-example","text":"#include <finite/draw.h> FiniteGradientPoint points[2] = { {0, 0.325, 0.325, 0.325, alpha}, {0.5, 0.207, 0.207, 0.207, alpha} }; cairo_pattern_t *pat = finite_draw_pattern_linear(0,0, (double)shell->details->width, (double)shell->details->height, points, 2); finite_draw_rect(shell, 0,0, shell->details->width, shell->details->height, NULL, pat); cairo_pattern_destroy(pat); finite_draw_finish(shell, shell->details->width, shell->details->height, shell->stride, true); while (wl_display_dispatch(shell->display) != -1) { FINITE_LOG(\"Window is open.\"); } finite_draw_cleanup(shell);","title":"Code Example"},{"location":"reference/functions/draw/finite_draw_cleanup/#standard-usage","text":"This function must have a valid FiniteShell This function uses Cairo which requires a valid cairo_surface_t in FiniteShell implementation (shell.cairo_surface) beforehand. This function destroys and cleans up. It must be called at the end of an application that uses Cairo.","title":"Standard Usage"},{"location":"reference/functions/draw/finite_draw_cleanup/#related-docs","text":"FiniteShell finite_draw_finish","title":"Related Docs"},{"location":"reference/functions/draw/finite_draw_create_snapshot/","text":"finite_draw_create_snapshot * \u2755 finite_draw_create_snapshot was last modified in v0.6.0 . It is incomplete and thus subject to change. void finite_draw_create_snapshot(FiniteShell *shell) The finite_draw_create_snapshot function attempts to create a restore point of a cairo surface. This function is still in testing. Parameters * Type Decription FiniteShell *shell The FiniteShell where the window is. Code Example * #include <finite/draw.h> finite_shm_alloc(shell, true); finite_draw_create_snapshot(myShell); Standard Usage * This function must have a valid FiniteShell This function uses Cairo which requires a valid cairo_surface_t in FiniteShell implementation (shell.cairo_surface) beforehand. This function copys all current data on screen and stores it in shell.snapshot in FiniteShell At some point finite_draw_finish should be called to apply the changes made by the snapshot visually. Related Docs * FiniteShell finite_draw_load_snapshot","title":"finite_draw_create_snapshot"},{"location":"reference/functions/draw/finite_draw_create_snapshot/#finite_draw_create_snapshot","text":"\u2755 finite_draw_create_snapshot was last modified in v0.6.0 . It is incomplete and thus subject to change. void finite_draw_create_snapshot(FiniteShell *shell) The finite_draw_create_snapshot function attempts to create a restore point of a cairo surface. This function is still in testing.","title":"finite_draw_create_snapshot"},{"location":"reference/functions/draw/finite_draw_create_snapshot/#parameters","text":"Type Decription FiniteShell *shell The FiniteShell where the window is.","title":"Parameters"},{"location":"reference/functions/draw/finite_draw_create_snapshot/#code-example","text":"#include <finite/draw.h> finite_shm_alloc(shell, true); finite_draw_create_snapshot(myShell);","title":"Code Example"},{"location":"reference/functions/draw/finite_draw_create_snapshot/#standard-usage","text":"This function must have a valid FiniteShell This function uses Cairo which requires a valid cairo_surface_t in FiniteShell implementation (shell.cairo_surface) beforehand. This function copys all current data on screen and stores it in shell.snapshot in FiniteShell At some point finite_draw_finish should be called to apply the changes made by the snapshot visually.","title":"Standard Usage"},{"location":"reference/functions/draw/finite_draw_create_snapshot/#related-docs","text":"FiniteShell finite_draw_load_snapshot","title":"Related Docs"},{"location":"reference/functions/draw/finite_draw_finish/","text":"finite_draw_finish * \u2754 finite_draw_finish was last modified in v0.6.0 . bool finite_draw_finish(FiniteShell *shell, int width, int height, int stride, bool withAlpha) The finite_draw_finish function attempts to clean up the cairo objects and commit the data to the window. Parameters * Type Decription FiniteShell *shell The FiniteShell where the window is. int width The width of the area to redraw. int height The height of the area to redraw. stride The stride of the window. bool withAlpha Whether or not the window supports Alpha Channels. Code Example * #include <finite/draw.h> FiniteGradientPoint points[2] = { {0, 0.325, 0.325, 0.325, alpha}, {0.5, 0.207, 0.207, 0.207, alpha} }; cairo_pattern_t *pat = finite_draw_pattern_linear(0,0, (double)shell->details->width, (double)shell->details->height, points, 2); finite_draw_rect(shell, 0,0, shell->details->width, shell->details->height, NULL, pat); cairo_pattern_destroy(pat); finite_draw_finish(shell, shell->details->width, shell->details->height, shell->stride, true); Standard Usage * This function must have a valid FiniteShell This function uses Cairo which requires a valid cairo_surface_t in FiniteShell implementation (shell.cairo_surface) beforehand. This function destroys the cairo draw object within a given FiniteShell . The cairo_surface_t however is not destroyed. At some point (likely after the render loop) you should call finite_draw_cleanup Related Docs * FiniteShell finite_draw_cleanup","title":"finite_draw_finish"},{"location":"reference/functions/draw/finite_draw_finish/#finite_draw_finish","text":"\u2754 finite_draw_finish was last modified in v0.6.0 . bool finite_draw_finish(FiniteShell *shell, int width, int height, int stride, bool withAlpha) The finite_draw_finish function attempts to clean up the cairo objects and commit the data to the window.","title":"finite_draw_finish"},{"location":"reference/functions/draw/finite_draw_finish/#parameters","text":"Type Decription FiniteShell *shell The FiniteShell where the window is. int width The width of the area to redraw. int height The height of the area to redraw. stride The stride of the window. bool withAlpha Whether or not the window supports Alpha Channels.","title":"Parameters"},{"location":"reference/functions/draw/finite_draw_finish/#code-example","text":"#include <finite/draw.h> FiniteGradientPoint points[2] = { {0, 0.325, 0.325, 0.325, alpha}, {0.5, 0.207, 0.207, 0.207, alpha} }; cairo_pattern_t *pat = finite_draw_pattern_linear(0,0, (double)shell->details->width, (double)shell->details->height, points, 2); finite_draw_rect(shell, 0,0, shell->details->width, shell->details->height, NULL, pat); cairo_pattern_destroy(pat); finite_draw_finish(shell, shell->details->width, shell->details->height, shell->stride, true);","title":"Code Example"},{"location":"reference/functions/draw/finite_draw_finish/#standard-usage","text":"This function must have a valid FiniteShell This function uses Cairo which requires a valid cairo_surface_t in FiniteShell implementation (shell.cairo_surface) beforehand. This function destroys the cairo draw object within a given FiniteShell . The cairo_surface_t however is not destroyed. At some point (likely after the render loop) you should call finite_draw_cleanup","title":"Standard Usage"},{"location":"reference/functions/draw/finite_draw_finish/#related-docs","text":"FiniteShell finite_draw_cleanup","title":"Related Docs"},{"location":"reference/functions/draw/finite_draw_get_font_extents/","text":"finite_draw_get_font_extents * \u2754 finite_draw_get_font_extents was last modified in v0.6.0 cairo_font_extents_t finite_draw_get_font_extents(FiniteShell *shell); The finite_draw_get_font_extents function attempts to get the extents of the current font Parameters * Type Decription FiniteShell *shell The FiniteShell where the window is. Code Example * #include <finite/draw.h> finite_draw_set_font(shell, \"Kumbh Sans\", false, true, 52); cairo_text_extents_t ext; FiniteTextGroup parts[3] = { {1,1,1,1,\"Welcome to the \"}, {0.964, 0.674, 0.192,1,\"Infinite \"}, {1,1,1,1,\"Level\"} }; cairo_font_extents_t fext = finite_draw_get_font_extents(shell); printf(\"Font height: %f\\n\", fext.height); finite_draw_text_group(shell, parts, (shell->details->width * 0.03), (shell->details->height * 0.1), 3); Standard Usage * A font must be set prior to calling this function with finite_draw_set_font . Failure to do so will throw an error. This function must have a valid cairo_t inside the FiniteShell ( shell.cr ). This function must have a valid FiniteShell This function uses Cairo which requires a valid cairo_surface_t in FiniteShell implementation (shell.cairo_surface) beforehand. Related Docs * finite_draw_set_text finite_draw_set_font FiniteTextGroup FiniteColorGroup","title":"finite_draw_get_font_extents"},{"location":"reference/functions/draw/finite_draw_get_font_extents/#finite_draw_get_font_extents","text":"\u2754 finite_draw_get_font_extents was last modified in v0.6.0 cairo_font_extents_t finite_draw_get_font_extents(FiniteShell *shell); The finite_draw_get_font_extents function attempts to get the extents of the current font","title":"finite_draw_get_font_extents"},{"location":"reference/functions/draw/finite_draw_get_font_extents/#parameters","text":"Type Decription FiniteShell *shell The FiniteShell where the window is.","title":"Parameters"},{"location":"reference/functions/draw/finite_draw_get_font_extents/#code-example","text":"#include <finite/draw.h> finite_draw_set_font(shell, \"Kumbh Sans\", false, true, 52); cairo_text_extents_t ext; FiniteTextGroup parts[3] = { {1,1,1,1,\"Welcome to the \"}, {0.964, 0.674, 0.192,1,\"Infinite \"}, {1,1,1,1,\"Level\"} }; cairo_font_extents_t fext = finite_draw_get_font_extents(shell); printf(\"Font height: %f\\n\", fext.height); finite_draw_text_group(shell, parts, (shell->details->width * 0.03), (shell->details->height * 0.1), 3);","title":"Code Example"},{"location":"reference/functions/draw/finite_draw_get_font_extents/#standard-usage","text":"A font must be set prior to calling this function with finite_draw_set_font . Failure to do so will throw an error. This function must have a valid cairo_t inside the FiniteShell ( shell.cr ). This function must have a valid FiniteShell This function uses Cairo which requires a valid cairo_surface_t in FiniteShell implementation (shell.cairo_surface) beforehand.","title":"Standard Usage"},{"location":"reference/functions/draw/finite_draw_get_font_extents/#related-docs","text":"finite_draw_set_text finite_draw_set_font FiniteTextGroup FiniteColorGroup","title":"Related Docs"},{"location":"reference/functions/draw/finite_draw_get_text_extents/","text":"finite_draw_get_text_extents * \u2754 finite_draw_get_text_extents was last modified in v0.6.0 cairo_text_extents_t finite_draw_get_text_extents(FiniteShell *shell, char *str) The finite_draw_get_text_extents function attempts to draw a set of FiniteTextGroups to the screen. Parameters * Type Decription FiniteShell *shell The FiniteShell where the window is. char *str The text to get the extents from. Code Example * #include <finite/draw.h> FiniteWindowInfo *det = shell->details; int32_t width = det->width; int32_t height = det->height; finite_draw_set_font(shell, \"KumbhSans\", false, false, 24); double xW = 338, yH = 68; double nW = (double)(width - 400), nY = (double)(height - 100); ext = finite_draw_get_text_extents(shell, \"Let's go!\"); double text_x = nW + (xW - ext.width) / 2 - ext.x_bearing; double text_y = nY + (yH - ext.height) / 2 - ext.y_bearing; finite_draw_set_draw_position(shell, text_x, text_y); finite_draw_set_text(shell, \"Let's go!\", &white); Standard Usage * This function should only be called after finite_draw_set_font has been called. Text extents must have a valid reference font. This function must have a valid cairo_t inside the FiniteShell ( shell.cr ). This function must have a valid FiniteShell This function uses Cairo which requires a valid cairo_surface_t in FiniteShell implementation (shell.cairo_surface) beforehand. Related Docs * finite_draw_set_text finite_draw_set_font FiniteTextGroup FiniteColorGroup","title":"finite_draw_get_text_extents"},{"location":"reference/functions/draw/finite_draw_get_text_extents/#finite_draw_get_text_extents","text":"\u2754 finite_draw_get_text_extents was last modified in v0.6.0 cairo_text_extents_t finite_draw_get_text_extents(FiniteShell *shell, char *str) The finite_draw_get_text_extents function attempts to draw a set of FiniteTextGroups to the screen.","title":"finite_draw_get_text_extents"},{"location":"reference/functions/draw/finite_draw_get_text_extents/#parameters","text":"Type Decription FiniteShell *shell The FiniteShell where the window is. char *str The text to get the extents from.","title":"Parameters"},{"location":"reference/functions/draw/finite_draw_get_text_extents/#code-example","text":"#include <finite/draw.h> FiniteWindowInfo *det = shell->details; int32_t width = det->width; int32_t height = det->height; finite_draw_set_font(shell, \"KumbhSans\", false, false, 24); double xW = 338, yH = 68; double nW = (double)(width - 400), nY = (double)(height - 100); ext = finite_draw_get_text_extents(shell, \"Let's go!\"); double text_x = nW + (xW - ext.width) / 2 - ext.x_bearing; double text_y = nY + (yH - ext.height) / 2 - ext.y_bearing; finite_draw_set_draw_position(shell, text_x, text_y); finite_draw_set_text(shell, \"Let's go!\", &white);","title":"Code Example"},{"location":"reference/functions/draw/finite_draw_get_text_extents/#standard-usage","text":"This function should only be called after finite_draw_set_font has been called. Text extents must have a valid reference font. This function must have a valid cairo_t inside the FiniteShell ( shell.cr ). This function must have a valid FiniteShell This function uses Cairo which requires a valid cairo_surface_t in FiniteShell implementation (shell.cairo_surface) beforehand.","title":"Standard Usage"},{"location":"reference/functions/draw/finite_draw_get_text_extents/#related-docs","text":"finite_draw_set_text finite_draw_set_font FiniteTextGroup FiniteColorGroup","title":"Related Docs"},{"location":"reference/functions/draw/finite_draw_load_snapshot/","text":"finite_draw_load_snapshot * \u2755 finite_draw_load_snapshot was last modified in v0.6.0 . It is incomplete and thus subject to change. void finite_draw_load_snapshot(FiniteShell *shell) The finite_draw_load_snapshot function attempts to restore a cairo surface from a restore point. This function is still in testing. Parameters * Type Decription FiniteShell *shell The FiniteShell where the window is. Code Example * #include <finite/draw.h> finite_draw_load_snapshot(myShell); finite_draw_finish(myShell); Standard Usage * In order to load a snapshot, one must be created with finite_draw_create_snapshot at the point you'd like to restore to. This function destroys all current data on screen and replaces it with the data in shell.snapshot in FiniteShell At some point finite_draw_finish should be called to apply the changes made by the snapshot visually. Related Docs * FiniteShell finite_draw_create_snapshot","title":"finite_draw_load_snapshot"},{"location":"reference/functions/draw/finite_draw_load_snapshot/#finite_draw_load_snapshot","text":"\u2755 finite_draw_load_snapshot was last modified in v0.6.0 . It is incomplete and thus subject to change. void finite_draw_load_snapshot(FiniteShell *shell) The finite_draw_load_snapshot function attempts to restore a cairo surface from a restore point. This function is still in testing.","title":"finite_draw_load_snapshot"},{"location":"reference/functions/draw/finite_draw_load_snapshot/#parameters","text":"Type Decription FiniteShell *shell The FiniteShell where the window is.","title":"Parameters"},{"location":"reference/functions/draw/finite_draw_load_snapshot/#code-example","text":"#include <finite/draw.h> finite_draw_load_snapshot(myShell); finite_draw_finish(myShell);","title":"Code Example"},{"location":"reference/functions/draw/finite_draw_load_snapshot/#standard-usage","text":"In order to load a snapshot, one must be created with finite_draw_create_snapshot at the point you'd like to restore to. This function destroys all current data on screen and replaces it with the data in shell.snapshot in FiniteShell At some point finite_draw_finish should be called to apply the changes made by the snapshot visually.","title":"Standard Usage"},{"location":"reference/functions/draw/finite_draw_load_snapshot/#related-docs","text":"FiniteShell finite_draw_create_snapshot","title":"Related Docs"},{"location":"reference/functions/draw/finite_draw_pattern_linear/","text":"finite_draw_text_group * \u2754 finite_draw_text_group was last modified in v0.6.0 cairo_pattern_t *finite_draw_pattern_linear(double startX, double startY, double endX, double endY, FiniteGradientPoint *points, size_t n) The finite_draw_text_group function attempts to create a cairo pattern as a linear gradient. Parameters * Type Decription double startX The starting X position of the gradient double starty The starting Y position of the gradient double endX The ending X position of the gradient double endY The ending y position of the gradient FiniteGradientPoint *points An array of FiniteGradientPoints size_t n The number of items in the points array. Code Example * #include <finite/draw.h> double xW = 338, yH = 68; double nW = (double)(width - 400), nY = (double)(height - 100); finite_draw_rounded_rect(shell, nW, nY, xW, yH, 20, &color, NULL, true); FiniteGradientPoint new_points[2] = { {0, 1, 0.325, 0.325}, {1, 1, 0.474, 0.098} }; cairo_pattern_t *pat = finite_draw_pattern_linear(nW, nY, (double)(width), (double)(height), new_points, 2); finite_draw_stroke(shell, NULL, pat, 14); cairo_pattern_destroy(pat); Standard Usage * This function creates a cairo_pattern_t that at some point must be destroyed with cairo_pattern_destroy Related Docs * finite_draw_set_text finite_draw_set_font FiniteTextGroup FiniteColorGroup","title":"finite_draw_text_group"},{"location":"reference/functions/draw/finite_draw_pattern_linear/#finite_draw_text_group","text":"\u2754 finite_draw_text_group was last modified in v0.6.0 cairo_pattern_t *finite_draw_pattern_linear(double startX, double startY, double endX, double endY, FiniteGradientPoint *points, size_t n) The finite_draw_text_group function attempts to create a cairo pattern as a linear gradient.","title":"finite_draw_text_group"},{"location":"reference/functions/draw/finite_draw_pattern_linear/#parameters","text":"Type Decription double startX The starting X position of the gradient double starty The starting Y position of the gradient double endX The ending X position of the gradient double endY The ending y position of the gradient FiniteGradientPoint *points An array of FiniteGradientPoints size_t n The number of items in the points array.","title":"Parameters"},{"location":"reference/functions/draw/finite_draw_pattern_linear/#code-example","text":"#include <finite/draw.h> double xW = 338, yH = 68; double nW = (double)(width - 400), nY = (double)(height - 100); finite_draw_rounded_rect(shell, nW, nY, xW, yH, 20, &color, NULL, true); FiniteGradientPoint new_points[2] = { {0, 1, 0.325, 0.325}, {1, 1, 0.474, 0.098} }; cairo_pattern_t *pat = finite_draw_pattern_linear(nW, nY, (double)(width), (double)(height), new_points, 2); finite_draw_stroke(shell, NULL, pat, 14); cairo_pattern_destroy(pat);","title":"Code Example"},{"location":"reference/functions/draw/finite_draw_pattern_linear/#standard-usage","text":"This function creates a cairo_pattern_t that at some point must be destroyed with cairo_pattern_destroy","title":"Standard Usage"},{"location":"reference/functions/draw/finite_draw_pattern_linear/#related-docs","text":"finite_draw_set_text finite_draw_set_font FiniteTextGroup FiniteColorGroup","title":"Related Docs"},{"location":"reference/functions/draw/finite_draw_png/","text":"finite_draw_png * \u2754 finite_draw_png was last modified in v0.6.0 . void finite_draw_png(FiniteShell *shell, const char *path, double x, double y); The finite_draw_png function attempts to clean up and destroy the window. Parameters * Type Decription FiniteShell *shell The FiniteShell where the window is. const char *path The path to the png image. double x The X position of the png. double y The Y position of the png. Code Example * #include <finite/draw.h> finite_draw_png(shell, \"/home/cubix/Documents/Islands/setup/src/wifi-bad.png\",0,0) Notes * This function only supports pngs. Additionally scaling png images requires some extra work not yet supported by libfinite natively. Standard Usage * This function must have a valid FiniteShell This function uses Cairo which requires a valid cairo_surface_t in FiniteShell implementation (shell.cairo_surface) beforehand. Related Docs * FiniteShell finite_draw_finish","title":"finite_draw_png"},{"location":"reference/functions/draw/finite_draw_png/#finite_draw_png","text":"\u2754 finite_draw_png was last modified in v0.6.0 . void finite_draw_png(FiniteShell *shell, const char *path, double x, double y); The finite_draw_png function attempts to clean up and destroy the window.","title":"finite_draw_png"},{"location":"reference/functions/draw/finite_draw_png/#parameters","text":"Type Decription FiniteShell *shell The FiniteShell where the window is. const char *path The path to the png image. double x The X position of the png. double y The Y position of the png.","title":"Parameters"},{"location":"reference/functions/draw/finite_draw_png/#code-example","text":"#include <finite/draw.h> finite_draw_png(shell, \"/home/cubix/Documents/Islands/setup/src/wifi-bad.png\",0,0)","title":"Code Example"},{"location":"reference/functions/draw/finite_draw_png/#notes","text":"This function only supports pngs. Additionally scaling png images requires some extra work not yet supported by libfinite natively.","title":"Notes"},{"location":"reference/functions/draw/finite_draw_png/#standard-usage","text":"This function must have a valid FiniteShell This function uses Cairo which requires a valid cairo_surface_t in FiniteShell implementation (shell.cairo_surface) beforehand.","title":"Standard Usage"},{"location":"reference/functions/draw/finite_draw_png/#related-docs","text":"FiniteShell finite_draw_finish","title":"Related Docs"},{"location":"reference/functions/draw/finite_draw_rect/","text":"finite_draw_rect * \u2754 finite_draw_rect was last modified in v0.6.0 void finite_draw_rect(FiniteShell *shell, double x, double y, double width, double height, FiniteColorGroup *color, cairo_pattern_t *pat) The finite_draw_rect function attempts to draw a regular rectangle onto a window with Cairo. Parameters * Type Decription FiniteShell *shell The FiniteShell where the window is. double x The x position to draw the rectangle at. double y The y position to draw the rectangle at. double width The width of the rectangle. double height The height of the rectangle FiniteColorGroup *color A single FiniteColorGroup cairo_pattern_t *pat A single Cairo Pattern. Code Example * #include <finite/draw.h> FiniteColorGroup myColor = { .r = 211.0/255.0, .g = 63.0/255.0, .b = 73.0/255.0 }; finite_draw_rect(myShell, 0,0, 100, 100, &myColor, NULL); Notes * finite_draw_rect supports both solid colors with FiniteColorGroup and gradients with cairo_pattern_t but you CANNOT have both values set. One of the last two params MUST be NULL. Having two color values set will throw an error. This function doesn't use information from finite_draw_set_draw_position as of v0.6.0 If shell.cr is undefined, this function will create a new Cairo draw tool and set it to shell.cr Standard Usage * This function must have a valid FiniteShell . This function uses Cairo which requires a valid cairo_surface_t in FiniteShell implementation beforehand. Related Docs * finite_draw_rounded_rect FiniteColorGroup","title":"finite_draw_rect"},{"location":"reference/functions/draw/finite_draw_rect/#finite_draw_rect","text":"\u2754 finite_draw_rect was last modified in v0.6.0 void finite_draw_rect(FiniteShell *shell, double x, double y, double width, double height, FiniteColorGroup *color, cairo_pattern_t *pat) The finite_draw_rect function attempts to draw a regular rectangle onto a window with Cairo.","title":"finite_draw_rect"},{"location":"reference/functions/draw/finite_draw_rect/#parameters","text":"Type Decription FiniteShell *shell The FiniteShell where the window is. double x The x position to draw the rectangle at. double y The y position to draw the rectangle at. double width The width of the rectangle. double height The height of the rectangle FiniteColorGroup *color A single FiniteColorGroup cairo_pattern_t *pat A single Cairo Pattern.","title":"Parameters"},{"location":"reference/functions/draw/finite_draw_rect/#code-example","text":"#include <finite/draw.h> FiniteColorGroup myColor = { .r = 211.0/255.0, .g = 63.0/255.0, .b = 73.0/255.0 }; finite_draw_rect(myShell, 0,0, 100, 100, &myColor, NULL);","title":"Code Example"},{"location":"reference/functions/draw/finite_draw_rect/#notes","text":"finite_draw_rect supports both solid colors with FiniteColorGroup and gradients with cairo_pattern_t but you CANNOT have both values set. One of the last two params MUST be NULL. Having two color values set will throw an error. This function doesn't use information from finite_draw_set_draw_position as of v0.6.0 If shell.cr is undefined, this function will create a new Cairo draw tool and set it to shell.cr","title":"Notes"},{"location":"reference/functions/draw/finite_draw_rect/#standard-usage","text":"This function must have a valid FiniteShell . This function uses Cairo which requires a valid cairo_surface_t in FiniteShell implementation beforehand.","title":"Standard Usage"},{"location":"reference/functions/draw/finite_draw_rect/#related-docs","text":"finite_draw_rounded_rect FiniteColorGroup","title":"Related Docs"},{"location":"reference/functions/draw/finite_draw_rounded_rect/","text":"finite_draw_rounded_rect * \u2754 finite_draw_rounded_rect was last modified in v0.6.0 void finite_draw_rounded_rect(FiniteShell *shell, double x, double y, double width, double height, double radius, FiniteColorGroup *color, cairo_pattern_t *pat, bool withPreserve) The finite_draw_rounded_rect function attempts to draw a rounded rectangle onto a window with Cairo. Parameters * Type Decription FiniteShell *shell The FiniteShell to resize. double x The x position to draw the rectangle at. double y The y position to draw the rectangle at. double width The width of the rectangle. double height The height of the rectangle double radius The Radoius of the rounded edges of the rectangle. FiniteColorGroup *color A single FiniteColorGroup cairo_pattern_t *pat A single Cairo Pattern. bool withPreserve Determines whether to 'preserve' the data for things like stroke. Code Example * #include <finite/draw.h> FiniteColorGroup myColor = { .r = 211.0/255.0, .g = 63.0/255.0, .b = 73.0/255.0 }; finite_draw_rounded_rect(myShell, 0,0, 100, 100, 15, &myColor, NULL, false); Notes * finite_draw_rounded_rect supports both solid colors with FiniteColorGroup and gradients with cairo_pattern_t but you CANNOT have both values set. One of the last two params MUST be NULL. Having two color values set will throw an error. If shell.cr is undefined, this function will create a new Cairo draw tool and set it to shell.cr Standard Usage * This function must have a valid FiniteShell . This function uses Cairo which requires a valid cairo_surface_t in FiniteShell implementation beforehand. Related Docs * finite_draw_rect FiniteColorGroup","title":"finite_draw_rounded_rect"},{"location":"reference/functions/draw/finite_draw_rounded_rect/#finite_draw_rounded_rect","text":"\u2754 finite_draw_rounded_rect was last modified in v0.6.0 void finite_draw_rounded_rect(FiniteShell *shell, double x, double y, double width, double height, double radius, FiniteColorGroup *color, cairo_pattern_t *pat, bool withPreserve) The finite_draw_rounded_rect function attempts to draw a rounded rectangle onto a window with Cairo.","title":"finite_draw_rounded_rect"},{"location":"reference/functions/draw/finite_draw_rounded_rect/#parameters","text":"Type Decription FiniteShell *shell The FiniteShell to resize. double x The x position to draw the rectangle at. double y The y position to draw the rectangle at. double width The width of the rectangle. double height The height of the rectangle double radius The Radoius of the rounded edges of the rectangle. FiniteColorGroup *color A single FiniteColorGroup cairo_pattern_t *pat A single Cairo Pattern. bool withPreserve Determines whether to 'preserve' the data for things like stroke.","title":"Parameters"},{"location":"reference/functions/draw/finite_draw_rounded_rect/#code-example","text":"#include <finite/draw.h> FiniteColorGroup myColor = { .r = 211.0/255.0, .g = 63.0/255.0, .b = 73.0/255.0 }; finite_draw_rounded_rect(myShell, 0,0, 100, 100, 15, &myColor, NULL, false);","title":"Code Example"},{"location":"reference/functions/draw/finite_draw_rounded_rect/#notes","text":"finite_draw_rounded_rect supports both solid colors with FiniteColorGroup and gradients with cairo_pattern_t but you CANNOT have both values set. One of the last two params MUST be NULL. Having two color values set will throw an error. If shell.cr is undefined, this function will create a new Cairo draw tool and set it to shell.cr","title":"Notes"},{"location":"reference/functions/draw/finite_draw_rounded_rect/#standard-usage","text":"This function must have a valid FiniteShell . This function uses Cairo which requires a valid cairo_surface_t in FiniteShell implementation beforehand.","title":"Standard Usage"},{"location":"reference/functions/draw/finite_draw_rounded_rect/#related-docs","text":"finite_draw_rect FiniteColorGroup","title":"Related Docs"},{"location":"reference/functions/draw/finite_draw_set_draw_position/","text":"finite_draw_set_draw_position * \u2754 finite_draw_set_draw_position was last modified in v0.6.0 void finite_draw_set_draw_position(FiniteShell *shell, double x, double y) The finite_draw_set_draw_position function attempts to set the draw position relative to screen. Parameters * Type Decription FiniteShell *shell The FiniteShell where the window is. double x The x position to set the draw position to. double y The y position to set the draw position to. Code Example * #include <finite/draw.h> finite_draw_set_font(myShell, \"KunbhSans\", false, false, 24); FiniteColorGroup white = { .r = 0, .g = 0, .b = 0 }; finite_draw_set_draw_position(myShell, 30, 20); finite_draw_set_text(myShell, \"Hello there!\", &white); Standard Usage * The x and y values of this function should take into account any offset made with finite_draw_set_offset . This function must have a valid FiniteShell If shell.cr is undefined, this function will create a new Cairo draw tool and set it to shell.cr This function uses Cairo which requires a valid cairo_surface_t in FiniteShell implementation (shell.cairo_surface) beforehand. Related Docs * finite_draw_set_text finite_draw_set_font finite_draw_text_group FiniteColorGroup","title":"finite_draw_set_draw_position"},{"location":"reference/functions/draw/finite_draw_set_draw_position/#finite_draw_set_draw_position","text":"\u2754 finite_draw_set_draw_position was last modified in v0.6.0 void finite_draw_set_draw_position(FiniteShell *shell, double x, double y) The finite_draw_set_draw_position function attempts to set the draw position relative to screen.","title":"finite_draw_set_draw_position"},{"location":"reference/functions/draw/finite_draw_set_draw_position/#parameters","text":"Type Decription FiniteShell *shell The FiniteShell where the window is. double x The x position to set the draw position to. double y The y position to set the draw position to.","title":"Parameters"},{"location":"reference/functions/draw/finite_draw_set_draw_position/#code-example","text":"#include <finite/draw.h> finite_draw_set_font(myShell, \"KunbhSans\", false, false, 24); FiniteColorGroup white = { .r = 0, .g = 0, .b = 0 }; finite_draw_set_draw_position(myShell, 30, 20); finite_draw_set_text(myShell, \"Hello there!\", &white);","title":"Code Example"},{"location":"reference/functions/draw/finite_draw_set_draw_position/#standard-usage","text":"The x and y values of this function should take into account any offset made with finite_draw_set_offset . This function must have a valid FiniteShell If shell.cr is undefined, this function will create a new Cairo draw tool and set it to shell.cr This function uses Cairo which requires a valid cairo_surface_t in FiniteShell implementation (shell.cairo_surface) beforehand.","title":"Standard Usage"},{"location":"reference/functions/draw/finite_draw_set_draw_position/#related-docs","text":"finite_draw_set_text finite_draw_set_font finite_draw_text_group FiniteColorGroup","title":"Related Docs"},{"location":"reference/functions/draw/finite_draw_set_font/","text":"finite_draw_set_font * \u2754 finite_draw_set_font was last modified in v0.6.0 void finite_draw_set_font(FiniteShell *shell, char *font_name, bool isItalics, bool isBold, int size) The finite_draw_set_font function attempts to set the font of future text. Parameters * Type Decription FiniteShell *shell The FiniteShell where the window is. char *font_name The name of the font. bool isItalics Toggles text italics. bool isBold Toggles text boldness. int size The size of the text. Code Example * #include <finite/draw.h> finite_draw_set_font(myShell, \"KunbhSans\", false, false, 24); FiniteColorGroup white = { .r = 0, .g = 0, .b = 0 }; finite_draw_set_draw_position(myShell, 30, 20); finite_draw_set_text(myShell, \"Hello there!\", &white); Standard Usage * When using this function to setup text loading, you must use a valid libfinite function. Currently, the Cubix Infinite supports these fonts: KumbhSans LiberationSans OpenSans Montserrat NotoSans This function should be called whenever you're planning on changing the size or style of text. It will only impact text drawn after it's been called. This function must have a valid FiniteShell If shell.cr is undefined, this function will create a new Cairo draw tool and set it to shell.cr This function uses Cairo which requires a valid cairo_surface_t in FiniteShell implementation (shell.cairo_surface) beforehand. Related Docs * finite_draw_set_draw_position finite_draw_set_text finite_draw_text_group FiniteColorGroup","title":"finite_draw_set_font"},{"location":"reference/functions/draw/finite_draw_set_font/#finite_draw_set_font","text":"\u2754 finite_draw_set_font was last modified in v0.6.0 void finite_draw_set_font(FiniteShell *shell, char *font_name, bool isItalics, bool isBold, int size) The finite_draw_set_font function attempts to set the font of future text.","title":"finite_draw_set_font"},{"location":"reference/functions/draw/finite_draw_set_font/#parameters","text":"Type Decription FiniteShell *shell The FiniteShell where the window is. char *font_name The name of the font. bool isItalics Toggles text italics. bool isBold Toggles text boldness. int size The size of the text.","title":"Parameters"},{"location":"reference/functions/draw/finite_draw_set_font/#code-example","text":"#include <finite/draw.h> finite_draw_set_font(myShell, \"KunbhSans\", false, false, 24); FiniteColorGroup white = { .r = 0, .g = 0, .b = 0 }; finite_draw_set_draw_position(myShell, 30, 20); finite_draw_set_text(myShell, \"Hello there!\", &white);","title":"Code Example"},{"location":"reference/functions/draw/finite_draw_set_font/#standard-usage","text":"When using this function to setup text loading, you must use a valid libfinite function. Currently, the Cubix Infinite supports these fonts: KumbhSans LiberationSans OpenSans Montserrat NotoSans This function should be called whenever you're planning on changing the size or style of text. It will only impact text drawn after it's been called. This function must have a valid FiniteShell If shell.cr is undefined, this function will create a new Cairo draw tool and set it to shell.cr This function uses Cairo which requires a valid cairo_surface_t in FiniteShell implementation (shell.cairo_surface) beforehand.","title":"Standard Usage"},{"location":"reference/functions/draw/finite_draw_set_font/#related-docs","text":"finite_draw_set_draw_position finite_draw_set_text finite_draw_text_group FiniteColorGroup","title":"Related Docs"},{"location":"reference/functions/draw/finite_draw_set_offset/","text":"finite_draw_set_offset * \u2754 finite_draw_set_offset was last modified in v0.6.0 void finite_draw_set_offset(FiniteShell *shell, double x, double y) The finite_draw_set_offset function attempts to set an offset for future drawing. Parameters * Type Decription FiniteShell *shell The FiniteShell where the window is. double x The X offset. double y The Y offset. Code Example * #include <finite/draw.h> // create a color for later FiniteColorGroup grayGlass = { .r = 0.152, .g = 0.152, .b = 0.152, .a = 1 }; double miniWindow[4] = { ((shell->details->width * 40) / 100), // x ((shell->details->height * 20) / 100), // y ((shell->details->width * 55) / 100), // width ((shell->details->height * 60) / 100) // hieght }; finite_draw_set_offset(shell, miniWindow[0], miniWindow[1]); finite_draw_rounded_rect(shell, miniWindow[0], miniWindow[1], miniWindow[2], miniWindow[3], 35, &grayGlass, NULL, true); FiniteColorGroup outline = { .r = 0.788, .g = 0.788, .b = 0.788, .a = 0.4 }; finite_draw_stroke(shell, &outline, NULL, 6); Notes * This function is used to offset the drawing position of all draw functions. Even though some functions may manually take in x and y positions, they are universally affected by this function. Standard Usage * Offsets apply to everything drawn after it's been set as long as it's using the same shell.cr . You should at some point call the inverse of this function ( finite_draw_set_offset(-x, -y) ) to reset the offset back to 0,0. If shell.cr is undefined, this function will create a new Cairo draw tool and set it to shell.cr This function must have a valid FiniteShell This function uses Cairo which requires a valid cairo_surface_t in FiniteShell implementation (shell.cairo_surface) beforehand. Related Docs * finite_draw_rect FiniteColorGroup","title":"finite_draw_set_offset"},{"location":"reference/functions/draw/finite_draw_set_offset/#finite_draw_set_offset","text":"\u2754 finite_draw_set_offset was last modified in v0.6.0 void finite_draw_set_offset(FiniteShell *shell, double x, double y) The finite_draw_set_offset function attempts to set an offset for future drawing.","title":"finite_draw_set_offset"},{"location":"reference/functions/draw/finite_draw_set_offset/#parameters","text":"Type Decription FiniteShell *shell The FiniteShell where the window is. double x The X offset. double y The Y offset.","title":"Parameters"},{"location":"reference/functions/draw/finite_draw_set_offset/#code-example","text":"#include <finite/draw.h> // create a color for later FiniteColorGroup grayGlass = { .r = 0.152, .g = 0.152, .b = 0.152, .a = 1 }; double miniWindow[4] = { ((shell->details->width * 40) / 100), // x ((shell->details->height * 20) / 100), // y ((shell->details->width * 55) / 100), // width ((shell->details->height * 60) / 100) // hieght }; finite_draw_set_offset(shell, miniWindow[0], miniWindow[1]); finite_draw_rounded_rect(shell, miniWindow[0], miniWindow[1], miniWindow[2], miniWindow[3], 35, &grayGlass, NULL, true); FiniteColorGroup outline = { .r = 0.788, .g = 0.788, .b = 0.788, .a = 0.4 }; finite_draw_stroke(shell, &outline, NULL, 6);","title":"Code Example"},{"location":"reference/functions/draw/finite_draw_set_offset/#notes","text":"This function is used to offset the drawing position of all draw functions. Even though some functions may manually take in x and y positions, they are universally affected by this function.","title":"Notes"},{"location":"reference/functions/draw/finite_draw_set_offset/#standard-usage","text":"Offsets apply to everything drawn after it's been set as long as it's using the same shell.cr . You should at some point call the inverse of this function ( finite_draw_set_offset(-x, -y) ) to reset the offset back to 0,0. If shell.cr is undefined, this function will create a new Cairo draw tool and set it to shell.cr This function must have a valid FiniteShell This function uses Cairo which requires a valid cairo_surface_t in FiniteShell implementation (shell.cairo_surface) beforehand.","title":"Standard Usage"},{"location":"reference/functions/draw/finite_draw_set_offset/#related-docs","text":"finite_draw_rect FiniteColorGroup","title":"Related Docs"},{"location":"reference/functions/draw/finite_draw_set_text/","text":"finite_draw_set_text * \u2754 finite_draw_set_text was last modified in v0.6.0 void finite_draw_set_text(FiniteShell *shell, char *text, FiniteColorGroup *color) The finite_draw_set_text function attempts to draw text to the screen. Parameters * Type Decription FiniteShell *shell The FiniteShell where the window is. char *text The text the screen. FiniteColorGroup *color The color of the text to draw. Code Example * #include <finite/draw.h> finite_draw_set_font(myShell, \"KunbhSans\", false, false, 24); FiniteColorGroup white = { .r = 0, .g = 0, .b = 0 }; finite_draw_set_draw_position(myShell, 30, 20); finite_draw_set_text(myShell, \"Hello there!\", &white); Standard Usage * This function is intended to be used to draw colored text to screen. However it does not take in a position. As such, you should call finite_draw_set_draw_position directly before each finite_draw_set_text call to ensure that things are rendered at the correctly. If shell.cr is undefined, this function will create a new Cairo draw tool and set it to shell.cr This function must have a valid FiniteShell This function uses Cairo which requires a valid cairo_surface_t in FiniteShell implementation (shell.cairo_surface) beforehand. Related Docs * finite_draw_set_draw_position finite_draw_set_font finite_draw_text_group FiniteColorGroup","title":"finite_draw_set_text"},{"location":"reference/functions/draw/finite_draw_set_text/#finite_draw_set_text","text":"\u2754 finite_draw_set_text was last modified in v0.6.0 void finite_draw_set_text(FiniteShell *shell, char *text, FiniteColorGroup *color) The finite_draw_set_text function attempts to draw text to the screen.","title":"finite_draw_set_text"},{"location":"reference/functions/draw/finite_draw_set_text/#parameters","text":"Type Decription FiniteShell *shell The FiniteShell where the window is. char *text The text the screen. FiniteColorGroup *color The color of the text to draw.","title":"Parameters"},{"location":"reference/functions/draw/finite_draw_set_text/#code-example","text":"#include <finite/draw.h> finite_draw_set_font(myShell, \"KunbhSans\", false, false, 24); FiniteColorGroup white = { .r = 0, .g = 0, .b = 0 }; finite_draw_set_draw_position(myShell, 30, 20); finite_draw_set_text(myShell, \"Hello there!\", &white);","title":"Code Example"},{"location":"reference/functions/draw/finite_draw_set_text/#standard-usage","text":"This function is intended to be used to draw colored text to screen. However it does not take in a position. As such, you should call finite_draw_set_draw_position directly before each finite_draw_set_text call to ensure that things are rendered at the correctly. If shell.cr is undefined, this function will create a new Cairo draw tool and set it to shell.cr This function must have a valid FiniteShell This function uses Cairo which requires a valid cairo_surface_t in FiniteShell implementation (shell.cairo_surface) beforehand.","title":"Standard Usage"},{"location":"reference/functions/draw/finite_draw_set_text/#related-docs","text":"finite_draw_set_draw_position finite_draw_set_font finite_draw_text_group FiniteColorGroup","title":"Related Docs"},{"location":"reference/functions/draw/finite_draw_stroke/","text":"finite_draw_stroke * \u2754 finite_draw_stroke was last modified in v0.6.0 void finite_draw_stroke(FiniteShell *shell, FiniteColorGroup *color, cairo_pattern_t *pat, int width) The finite_draw_stroke function attempts to draw a stroke around the latest rectangle. Parameters * Type Decription FiniteShell *shell The FiniteShell where the window is. FiniteColorGroup *color A single FiniteColorGroup cairo_pattern_t *pat A single Cairo Pattern. int width The thickness of the stroke. Code Example * #include <finite/draw.h> FiniteColorGroup myColor = { .r = 211.0/255.0, .g = 63.0/255.0, .b = 73.0/255.0 }; FiniteColorGroup myStroke = { .r = 254.0/255.0, .g = 96.0/255.0 .b = 6.0/255.0 }; finite_draw_rect(myShell, 0,0, width, height, &myColor, NULL); finite_draw_stroke(myShell, myStroke, NULL, 5); Notes * This function doesn't use information from finite_draw_set_draw_position as of v0.6.0 If shell.cr is undefined, this function will NOT create a new Cairo draw tool as it expects a rectangle (and as a result a cairo draw tool) to exist prior to drawing. Standard Usage * This function, you must have a valid cairo_t inside the FiniteShell ( shell.cr ). Strokes may only be applied onto a surface that has already been initialized. This function must have a valid FiniteShell This function uses Cairo which requires a valid cairo_surface_t in FiniteShell implementation (shell.cairo_surface) beforehand. Related Docs * finite_draw_rect FiniteColorGroup","title":"finite_draw_stroke"},{"location":"reference/functions/draw/finite_draw_stroke/#finite_draw_stroke","text":"\u2754 finite_draw_stroke was last modified in v0.6.0 void finite_draw_stroke(FiniteShell *shell, FiniteColorGroup *color, cairo_pattern_t *pat, int width) The finite_draw_stroke function attempts to draw a stroke around the latest rectangle.","title":"finite_draw_stroke"},{"location":"reference/functions/draw/finite_draw_stroke/#parameters","text":"Type Decription FiniteShell *shell The FiniteShell where the window is. FiniteColorGroup *color A single FiniteColorGroup cairo_pattern_t *pat A single Cairo Pattern. int width The thickness of the stroke.","title":"Parameters"},{"location":"reference/functions/draw/finite_draw_stroke/#code-example","text":"#include <finite/draw.h> FiniteColorGroup myColor = { .r = 211.0/255.0, .g = 63.0/255.0, .b = 73.0/255.0 }; FiniteColorGroup myStroke = { .r = 254.0/255.0, .g = 96.0/255.0 .b = 6.0/255.0 }; finite_draw_rect(myShell, 0,0, width, height, &myColor, NULL); finite_draw_stroke(myShell, myStroke, NULL, 5);","title":"Code Example"},{"location":"reference/functions/draw/finite_draw_stroke/#notes","text":"This function doesn't use information from finite_draw_set_draw_position as of v0.6.0 If shell.cr is undefined, this function will NOT create a new Cairo draw tool as it expects a rectangle (and as a result a cairo draw tool) to exist prior to drawing.","title":"Notes"},{"location":"reference/functions/draw/finite_draw_stroke/#standard-usage","text":"This function, you must have a valid cairo_t inside the FiniteShell ( shell.cr ). Strokes may only be applied onto a surface that has already been initialized. This function must have a valid FiniteShell This function uses Cairo which requires a valid cairo_surface_t in FiniteShell implementation (shell.cairo_surface) beforehand.","title":"Standard Usage"},{"location":"reference/functions/draw/finite_draw_stroke/#related-docs","text":"finite_draw_rect FiniteColorGroup","title":"Related Docs"},{"location":"reference/functions/draw/finite_draw_text_group/","text":"finite_draw_text_group * \u2754 finite_draw_text_group was last modified in v0.6.0 void finite_draw_text_group(FiniteShell *shell, FiniteTextGroup *groups, double x, double y, size_t n) The finite_draw_text_group function attempts to draw a set of FiniteTextGroups to the screen. Parameters * Type Decription FiniteShell *shell The FiniteShell where the window is. FiniteTextGroup *groups An array of FiniteTextGroups . double x The x position to set the draw position to. double y The y position to set the draw position to. size_t n The number of FiniteTextGroups in groups Code Example * #include <finite/draw.h> finite_draw_set_font(shell, \"Kumbh Sans\", false, true, 52); cairo_text_extents_t ext; FiniteTextGroup parts[3] = { {1,1,1,1,\"Welcome to the \"}, {0.964, 0.674, 0.192,1,\"Infinite \"}, {1,1,1,1,\"Level\"} }; cairo_font_extents_t fext = finite_draw_get_font_extents(shell); printf(\"Font height: %f\\n\", fext.height); finite_draw_text_group(shell, parts, (shell->details->width * 0.03), (shell->details->height * 0.1), 3); Standard Usage * This function should have an array of atleast two FiniteTextGroups . Having less than 2 is both pointless and unnessary. If shell.cr is undefined, this function will create a new Cairo draw tool and set it to shell.cr This function must have a valid FiniteShell This function uses Cairo which requires a valid cairo_surface_t in FiniteShell implementation (shell.cairo_surface) beforehand. Related Docs * finite_draw_set_text finite_draw_set_font FiniteTextGroup FiniteColorGroup","title":"finite_draw_text_group"},{"location":"reference/functions/draw/finite_draw_text_group/#finite_draw_text_group","text":"\u2754 finite_draw_text_group was last modified in v0.6.0 void finite_draw_text_group(FiniteShell *shell, FiniteTextGroup *groups, double x, double y, size_t n) The finite_draw_text_group function attempts to draw a set of FiniteTextGroups to the screen.","title":"finite_draw_text_group"},{"location":"reference/functions/draw/finite_draw_text_group/#parameters","text":"Type Decription FiniteShell *shell The FiniteShell where the window is. FiniteTextGroup *groups An array of FiniteTextGroups . double x The x position to set the draw position to. double y The y position to set the draw position to. size_t n The number of FiniteTextGroups in groups","title":"Parameters"},{"location":"reference/functions/draw/finite_draw_text_group/#code-example","text":"#include <finite/draw.h> finite_draw_set_font(shell, \"Kumbh Sans\", false, true, 52); cairo_text_extents_t ext; FiniteTextGroup parts[3] = { {1,1,1,1,\"Welcome to the \"}, {0.964, 0.674, 0.192,1,\"Infinite \"}, {1,1,1,1,\"Level\"} }; cairo_font_extents_t fext = finite_draw_get_font_extents(shell); printf(\"Font height: %f\\n\", fext.height); finite_draw_text_group(shell, parts, (shell->details->width * 0.03), (shell->details->height * 0.1), 3);","title":"Code Example"},{"location":"reference/functions/draw/finite_draw_text_group/#standard-usage","text":"This function should have an array of atleast two FiniteTextGroups . Having less than 2 is both pointless and unnessary. If shell.cr is undefined, this function will create a new Cairo draw tool and set it to shell.cr This function must have a valid FiniteShell This function uses Cairo which requires a valid cairo_surface_t in FiniteShell implementation (shell.cairo_surface) beforehand.","title":"Standard Usage"},{"location":"reference/functions/draw/finite_draw_text_group/#related-docs","text":"finite_draw_set_text finite_draw_set_font FiniteTextGroup FiniteColorGroup","title":"Related Docs"},{"location":"reference/functions/draw/finite_overlay_init/","text":"finite_overlay_init * \u2754 finite_overlay_init was last modified in v0.6.0 void finite_overlay_init(FiniteShell *shell, int layer, char *name) The finite_overlay_init function creates a new layer shell window with a given FiniteShell . Parameters * Type Decription FiniteShell *shell The FiniteShell to create a overlay for. int layer The layer of the overlay char *name The name of the layer. Code Example * #include <finite/draw.h> finite_overlay_init(myShell); if (!myShell) { FINITE_LOG_FATAL(\"Unable to make shell\"); } Standard Usage * When creating a new popup (NOT APPLICATION), you must call this function. Although libfinite support custom implementations of some function, all libfinite functions that interact with the window expect a FiniteShell . Related Docs * FiniteShell finite_window_init","title":"finite_overlay_init"},{"location":"reference/functions/draw/finite_overlay_init/#finite_overlay_init","text":"\u2754 finite_overlay_init was last modified in v0.6.0 void finite_overlay_init(FiniteShell *shell, int layer, char *name) The finite_overlay_init function creates a new layer shell window with a given FiniteShell .","title":"finite_overlay_init"},{"location":"reference/functions/draw/finite_overlay_init/#parameters","text":"Type Decription FiniteShell *shell The FiniteShell to create a overlay for. int layer The layer of the overlay char *name The name of the layer.","title":"Parameters"},{"location":"reference/functions/draw/finite_overlay_init/#code-example","text":"#include <finite/draw.h> finite_overlay_init(myShell); if (!myShell) { FINITE_LOG_FATAL(\"Unable to make shell\"); }","title":"Code Example"},{"location":"reference/functions/draw/finite_overlay_init/#standard-usage","text":"When creating a new popup (NOT APPLICATION), you must call this function. Although libfinite support custom implementations of some function, all libfinite functions that interact with the window expect a FiniteShell .","title":"Standard Usage"},{"location":"reference/functions/draw/finite_overlay_init/#related-docs","text":"FiniteShell finite_window_init","title":"Related Docs"},{"location":"reference/functions/draw/finite_shell_init/","text":"finite_shell_init * \u2754 finite_shell_init was last modified in v0.6.0 FiniteShell *finite_shell_init(char *device) The finite_shell_init function creates a new FiniteShell . Parameters * Type Decription char *device The Wayland device to conenct to. Defaults to \"wayland-0\". Code Example * #include <finite/draw.h> FiniteShell *myShell = finite_shell_init(\"wayland-0\"); if (!myShell) { FINITE_LOG_FATAL(\"Unable to init shell\"); } Standard Usage * When creating a new application, you must call this function. Although libfinite support custom implementations of some function, all libfinite functions that interact with the window expect a FiniteShell . In production, you should use \"wayland-0\" as the Wayland Device. Related Docs * FiniteShell finite_window_init","title":"finite_shell_init"},{"location":"reference/functions/draw/finite_shell_init/#finite_shell_init","text":"\u2754 finite_shell_init was last modified in v0.6.0 FiniteShell *finite_shell_init(char *device) The finite_shell_init function creates a new FiniteShell .","title":"finite_shell_init"},{"location":"reference/functions/draw/finite_shell_init/#parameters","text":"Type Decription char *device The Wayland device to conenct to. Defaults to \"wayland-0\".","title":"Parameters"},{"location":"reference/functions/draw/finite_shell_init/#code-example","text":"#include <finite/draw.h> FiniteShell *myShell = finite_shell_init(\"wayland-0\"); if (!myShell) { FINITE_LOG_FATAL(\"Unable to init shell\"); }","title":"Code Example"},{"location":"reference/functions/draw/finite_shell_init/#standard-usage","text":"When creating a new application, you must call this function. Although libfinite support custom implementations of some function, all libfinite functions that interact with the window expect a FiniteShell . In production, you should use \"wayland-0\" as the Wayland Device.","title":"Standard Usage"},{"location":"reference/functions/draw/finite_shell_init/#related-docs","text":"FiniteShell finite_window_init","title":"Related Docs"},{"location":"reference/functions/draw/finite_window_init/","text":"finite_window_init * \u2754 finite_window_init was last modified in v0.6.0 void finite_window_init(FiniteShell *shell) The finite_window_init function creates a new window with a given FiniteShell . Parameters * Type Decription FiniteShell *shell The FiniteShell to create a window for. Code Example * finite_window_init(myShell); if (!myShell) { FINITE_LOG_FATAL(\"Unable to make shell\"); } Standard Usage * When creating a new application (NOT A POPUP), you must call this function. Although libfinite support custom implementations of some function, all libfinite functions that interact with the window expect a FiniteShell . Related Docs * FiniteShell FiniteWindowInfo","title":"finite_window_init"},{"location":"reference/functions/draw/finite_window_init/#finite_window_init","text":"\u2754 finite_window_init was last modified in v0.6.0 void finite_window_init(FiniteShell *shell) The finite_window_init function creates a new window with a given FiniteShell .","title":"finite_window_init"},{"location":"reference/functions/draw/finite_window_init/#parameters","text":"Type Decription FiniteShell *shell The FiniteShell to create a window for.","title":"Parameters"},{"location":"reference/functions/draw/finite_window_init/#code-example","text":"finite_window_init(myShell); if (!myShell) { FINITE_LOG_FATAL(\"Unable to make shell\"); }","title":"Code Example"},{"location":"reference/functions/draw/finite_window_init/#standard-usage","text":"When creating a new application (NOT A POPUP), you must call this function. Although libfinite support custom implementations of some function, all libfinite functions that interact with the window expect a FiniteShell .","title":"Standard Usage"},{"location":"reference/functions/draw/finite_window_init/#related-docs","text":"FiniteShell FiniteWindowInfo","title":"Related Docs"},{"location":"reference/functions/draw/finite_window_size_set/","text":"finite_window_size_set * \u2754 finite_window_size_set was last modified in v0.6.0 void finite_window_size_set(FiniteShell *shell, int xPos, int yPos, int width, int height) The finite_window_size_set function attempts to resize a window with a given FiniteShell . Parameters * Type Decription FiniteShell *shell The FiniteShell to resize. int xPos The new x position. int yPos The new y position. int width The new width. int height The new height Code Example * FiniteWindowInfo *det = myShell->details; int32_t true_width = det->width; int32_t true_height = det->height; finite_window_size_set(myShell, ((true_width * 20) / 100), ((true_height *25) / 100), ((true_width * 60) / 100), ((true_height *50) / 100)); Standard Usage * In order to call this function you must call finite_window_init or finite_overlay_init beforehand in order to get a valid wl_output This function is meant to be used to resize windows but in production, all Infinite applications must be the full size of the screen which they are by default. Related Docs * FiniteShell finite_window_init finite_overlay_init","title":"finite_window_size_set"},{"location":"reference/functions/draw/finite_window_size_set/#finite_window_size_set","text":"\u2754 finite_window_size_set was last modified in v0.6.0 void finite_window_size_set(FiniteShell *shell, int xPos, int yPos, int width, int height) The finite_window_size_set function attempts to resize a window with a given FiniteShell .","title":"finite_window_size_set"},{"location":"reference/functions/draw/finite_window_size_set/#parameters","text":"Type Decription FiniteShell *shell The FiniteShell to resize. int xPos The new x position. int yPos The new y position. int width The new width. int height The new height","title":"Parameters"},{"location":"reference/functions/draw/finite_window_size_set/#code-example","text":"FiniteWindowInfo *det = myShell->details; int32_t true_width = det->width; int32_t true_height = det->height; finite_window_size_set(myShell, ((true_width * 20) / 100), ((true_height *25) / 100), ((true_width * 60) / 100), ((true_height *50) / 100));","title":"Code Example"},{"location":"reference/functions/draw/finite_window_size_set/#standard-usage","text":"In order to call this function you must call finite_window_init or finite_overlay_init beforehand in order to get a valid wl_output This function is meant to be used to resize windows but in production, all Infinite applications must be the full size of the screen which they are by default.","title":"Standard Usage"},{"location":"reference/functions/draw/finite_window_size_set/#related-docs","text":"FiniteShell finite_window_init finite_overlay_init","title":"Related Docs"},{"location":"reference/functions/input/finite_input_keyboard_init/","text":"finite_input_keyboard_init * \u2754 finite_input_keyboard_init was last modified in v0.6.0 . FiniteKeyboard *finite_input_keyboard_init(struct wl_display *device) The finite_input_keyboard_init attempts to create a new FiniteKeyboard . Type Decription struct wl_display *device The Wayland Display to get keyboard events from. Code Example * #include <finite/input.h> #include <finite/log.h> FiniteKeyboard *kbd = finite_input_keyboard_init(myShell->display); FiniteKey xKey = finite_key_from_string(\"X\"); if (!finite_key_valid(xKey)) { FINITE_LOG_FATAL(\"Unable to poll NULL key\"); } // create wayland frame loop while (wl_display_dispatch_pending(myShell->display) != -1) { // poll for input finite_input_poll_keys(kbd, myShell); // handle input if (finite_key_pressed(xKey, kbd)) { FINITE_LOG(\"X Pressed\\n\"); } } Standard Usage * This function must have a valid FiniteShell The display parameter should be derived from the FiniteShell that is currently displaying data. Related Docs * FiniteShell finite_key_valid","title":"finite_input_keyboard_init"},{"location":"reference/functions/input/finite_input_keyboard_init/#finite_input_keyboard_init","text":"\u2754 finite_input_keyboard_init was last modified in v0.6.0 . FiniteKeyboard *finite_input_keyboard_init(struct wl_display *device) The finite_input_keyboard_init attempts to create a new FiniteKeyboard . Type Decription struct wl_display *device The Wayland Display to get keyboard events from.","title":"finite_input_keyboard_init"},{"location":"reference/functions/input/finite_input_keyboard_init/#code-example","text":"#include <finite/input.h> #include <finite/log.h> FiniteKeyboard *kbd = finite_input_keyboard_init(myShell->display); FiniteKey xKey = finite_key_from_string(\"X\"); if (!finite_key_valid(xKey)) { FINITE_LOG_FATAL(\"Unable to poll NULL key\"); } // create wayland frame loop while (wl_display_dispatch_pending(myShell->display) != -1) { // poll for input finite_input_poll_keys(kbd, myShell); // handle input if (finite_key_pressed(xKey, kbd)) { FINITE_LOG(\"X Pressed\\n\"); } }","title":"Code Example"},{"location":"reference/functions/input/finite_input_keyboard_init/#standard-usage","text":"This function must have a valid FiniteShell The display parameter should be derived from the FiniteShell that is currently displaying data.","title":"Standard Usage"},{"location":"reference/functions/input/finite_input_keyboard_init/#related-docs","text":"FiniteShell finite_key_valid","title":"Related Docs"},{"location":"reference/functions/input/finite_input_poll_keys/","text":"finite_input_poll_keys * \u2754 finite_input_poll_keys was last modified in v0.6.0 . bool finite_input_poll_keys(FiniteKey key, FiniteShell *shell) The finite_input_poll_keys checks for any and all key events. Type Decription FiniteKeyboard *board The FiniteKeyboard to check for key events from. FiniteShell *shell` The FiniteShell that has the window to poll for key events Code Example * #include <finite/input.h> #include <finite/log.h> FiniteKeyboard *kbd = finite_input_keyboard_init(myShell->display); FiniteKey xKey = finite_key_from_string(\"X\"); if (!finite_key_valid(xKey)) { FINITE_LOG_FATAL(\"Unable to poll NULL key\"); } // create wayland frame loop while (wl_display_dispatch_pending(myShell->display) != -1) { // poll for input finite_input_poll_keys(kbd, myShell); // handle input if (finite_key_up(xKey, kbd)) { FINITE_LOG(\"X not Pressed\\n\"); } } Standard Usage * This function checks for all key events. It should be called prior to checking for key events to ensure the data is up to date. For best results, place this function in a wl_display_dispatch call. Related Docs * finite_key_up finite_key_up FiniteKeyboard","title":"finite_input_poll_keys"},{"location":"reference/functions/input/finite_input_poll_keys/#finite_input_poll_keys","text":"\u2754 finite_input_poll_keys was last modified in v0.6.0 . bool finite_input_poll_keys(FiniteKey key, FiniteShell *shell) The finite_input_poll_keys checks for any and all key events. Type Decription FiniteKeyboard *board The FiniteKeyboard to check for key events from. FiniteShell *shell` The FiniteShell that has the window to poll for key events","title":"finite_input_poll_keys"},{"location":"reference/functions/input/finite_input_poll_keys/#code-example","text":"#include <finite/input.h> #include <finite/log.h> FiniteKeyboard *kbd = finite_input_keyboard_init(myShell->display); FiniteKey xKey = finite_key_from_string(\"X\"); if (!finite_key_valid(xKey)) { FINITE_LOG_FATAL(\"Unable to poll NULL key\"); } // create wayland frame loop while (wl_display_dispatch_pending(myShell->display) != -1) { // poll for input finite_input_poll_keys(kbd, myShell); // handle input if (finite_key_up(xKey, kbd)) { FINITE_LOG(\"X not Pressed\\n\"); } }","title":"Code Example"},{"location":"reference/functions/input/finite_input_poll_keys/#standard-usage","text":"This function checks for all key events. It should be called prior to checking for key events to ensure the data is up to date. For best results, place this function in a wl_display_dispatch call.","title":"Standard Usage"},{"location":"reference/functions/input/finite_input_poll_keys/#related-docs","text":"finite_key_up finite_key_up FiniteKeyboard","title":"Related Docs"},{"location":"reference/functions/input/finite_key_down/","text":"finite_key_down * \u2754 finite_key_down was last modified in v0.6.0 . bool finite_key_down(FiniteKey key, FiniteKeyboard *board) The finite_key_down checks if a given FiniteKey is currently held down. Type Decription FiniteKey key The FiniteKey to check FiniteKeyboard *board The FiniteKeyboard to check for key events from. Code Example * #include <finite/input.h> #include <finite/log.h> FiniteKeyboard *kbd = finite_input_keyboard_init(myShell->display); FiniteKey xKey = finite_key_from_string(\"X\"); if (!finite_key_valid(xKey)) { FINITE_LOG_FATAL(\"Unable to poll NULL key\"); } // create wayland frame loop while (wl_display_dispatch_pending(myShell->display) != -1) { // poll for input finite_input_poll_keys(kbd, myShell); // handle input if (finite_key_down(xKey, kbd)) { FINITE_LOG(\"X Pressed\\n\"); } } Standard Usage * This function should be used for key held events. For Key pressed events use a function like finite_key_pressed . Related Docs * finite_key_up finite_key_pressed FiniteKeyboard","title":"finite_key_down"},{"location":"reference/functions/input/finite_key_down/#finite_key_down","text":"\u2754 finite_key_down was last modified in v0.6.0 . bool finite_key_down(FiniteKey key, FiniteKeyboard *board) The finite_key_down checks if a given FiniteKey is currently held down. Type Decription FiniteKey key The FiniteKey to check FiniteKeyboard *board The FiniteKeyboard to check for key events from.","title":"finite_key_down"},{"location":"reference/functions/input/finite_key_down/#code-example","text":"#include <finite/input.h> #include <finite/log.h> FiniteKeyboard *kbd = finite_input_keyboard_init(myShell->display); FiniteKey xKey = finite_key_from_string(\"X\"); if (!finite_key_valid(xKey)) { FINITE_LOG_FATAL(\"Unable to poll NULL key\"); } // create wayland frame loop while (wl_display_dispatch_pending(myShell->display) != -1) { // poll for input finite_input_poll_keys(kbd, myShell); // handle input if (finite_key_down(xKey, kbd)) { FINITE_LOG(\"X Pressed\\n\"); } }","title":"Code Example"},{"location":"reference/functions/input/finite_key_down/#standard-usage","text":"This function should be used for key held events. For Key pressed events use a function like finite_key_pressed .","title":"Standard Usage"},{"location":"reference/functions/input/finite_key_down/#related-docs","text":"finite_key_up finite_key_pressed FiniteKeyboard","title":"Related Docs"},{"location":"reference/functions/input/finite_key_from_string/","text":"finite_key_from_string * \u2754 finite_key_from_string was last modified in v0.6.0 . FiniteKey finite_key_from_string(const char *name) The finite_key_from_string creates a FiniteKey from a given string Type Decription const char *name The name of the key to create a FiniteKey for. Code Example * #include <finite/input.h> #include <finite/log.h> FiniteKeyboard *kbd = finite_input_keyboard_init(myShell->display); FiniteKey xKey = finite_key_from_string(\"X\"); if (!finite_key_valid(xKey)) { FINITE_LOG_FATAL(\"Unable to poll NULL key\"); } // create wayland frame loop while (wl_display_dispatch_pending(myShell->display) != -1) { // poll for input finite_input_poll_keys(kbd, myShell); // handle input if (finite_key_pressed(xKey, kbd)) { FINITE_LOG(\"X Pressed\\n\"); } } Standard Usage * When calling this function you should ALWAYS call finite_key_valid afterword to avoid unexpected errors, undefined behavior or missed key events. Related Docs * finite_key_valid finite_input_keyboard_init FiniteKeyboard","title":"finite_key_from_string"},{"location":"reference/functions/input/finite_key_from_string/#finite_key_from_string","text":"\u2754 finite_key_from_string was last modified in v0.6.0 . FiniteKey finite_key_from_string(const char *name) The finite_key_from_string creates a FiniteKey from a given string Type Decription const char *name The name of the key to create a FiniteKey for.","title":"finite_key_from_string"},{"location":"reference/functions/input/finite_key_from_string/#code-example","text":"#include <finite/input.h> #include <finite/log.h> FiniteKeyboard *kbd = finite_input_keyboard_init(myShell->display); FiniteKey xKey = finite_key_from_string(\"X\"); if (!finite_key_valid(xKey)) { FINITE_LOG_FATAL(\"Unable to poll NULL key\"); } // create wayland frame loop while (wl_display_dispatch_pending(myShell->display) != -1) { // poll for input finite_input_poll_keys(kbd, myShell); // handle input if (finite_key_pressed(xKey, kbd)) { FINITE_LOG(\"X Pressed\\n\"); } }","title":"Code Example"},{"location":"reference/functions/input/finite_key_from_string/#standard-usage","text":"When calling this function you should ALWAYS call finite_key_valid afterword to avoid unexpected errors, undefined behavior or missed key events.","title":"Standard Usage"},{"location":"reference/functions/input/finite_key_from_string/#related-docs","text":"finite_key_valid finite_input_keyboard_init FiniteKeyboard","title":"Related Docs"},{"location":"reference/functions/input/finite_key_pressed/","text":"finite_key_pressed * \u2754 finite_key_pressed was last modified in v0.6.0 . bool finite_key_pressed(FiniteKey key, FiniteKeyboard *board) The finite_key_pressed checks if a given FiniteKey is currently being pressed. Type Decription FiniteKey key The FiniteKey to check. FiniteKeyboard *board The FiniteKeyboard to check for key events from. Code Example * #include <finite/input.h> #include <finite/log.h> FiniteKeyboard *kbd = finite_input_keyboard_init(myShell->display); FiniteKey xKey = finite_key_from_string(\"X\"); if (!finite_key_valid(xKey)) { FINITE_LOG_FATAL(\"Unable to poll NULL key\"); } // create wayland frame loop while (wl_display_dispatch_pending(myShell->display) != -1) { // poll for input finite_input_poll_keys(kbd, myShell); // handle input if (finite_key_pressed(xKey, kbd)) { FINITE_LOG(\"X Pressed\\n\"); } } Standard Usage * This function returns true if the key was pressed and then released. For Key held events use a function like finite_key_down . Related Docs * finite_key_down finite_key_up FiniteKeyboard","title":"finite_key_pressed"},{"location":"reference/functions/input/finite_key_pressed/#finite_key_pressed","text":"\u2754 finite_key_pressed was last modified in v0.6.0 . bool finite_key_pressed(FiniteKey key, FiniteKeyboard *board) The finite_key_pressed checks if a given FiniteKey is currently being pressed. Type Decription FiniteKey key The FiniteKey to check. FiniteKeyboard *board The FiniteKeyboard to check for key events from.","title":"finite_key_pressed"},{"location":"reference/functions/input/finite_key_pressed/#code-example","text":"#include <finite/input.h> #include <finite/log.h> FiniteKeyboard *kbd = finite_input_keyboard_init(myShell->display); FiniteKey xKey = finite_key_from_string(\"X\"); if (!finite_key_valid(xKey)) { FINITE_LOG_FATAL(\"Unable to poll NULL key\"); } // create wayland frame loop while (wl_display_dispatch_pending(myShell->display) != -1) { // poll for input finite_input_poll_keys(kbd, myShell); // handle input if (finite_key_pressed(xKey, kbd)) { FINITE_LOG(\"X Pressed\\n\"); } }","title":"Code Example"},{"location":"reference/functions/input/finite_key_pressed/#standard-usage","text":"This function returns true if the key was pressed and then released. For Key held events use a function like finite_key_down .","title":"Standard Usage"},{"location":"reference/functions/input/finite_key_pressed/#related-docs","text":"finite_key_down finite_key_up FiniteKeyboard","title":"Related Docs"},{"location":"reference/functions/input/finite_key_string_from_key/","text":"finite_key_string_from_key * \u2754 finite_key_string_from_key was last modified in v0.6.0 . const char *finite_key_string_from_key(FiniteKey key) The finite_key_string_from_key takes a FiniteKey and returns an equalivlant string Type Decription FiniteKey key The FiniteKey to get a string for. Code Example * #include <finite/input.h> #include <finite/log.h> FiniteKeyboard *kbd = finite_input_keyboard_init(myShell->display); FiniteKey xKey = finite_key_from_string(\"X\"); if (!finite_key_valid(xKey)) { FINITE_LOG_FATAL(\"Unable to poll NULL key\"); } // create wayland frame loop while (wl_display_dispatch_pending(myShell->display) != -1) { // poll for input finite_input_poll_keys(kbd, myShell); // handle input if (finite_key_pressed(xKey, kbd)) { const char *key = finite_key_string_from_key(xKey); FINITE_LOG(\"%s Pressed\\n\", key); } } Standard Usage * When call this function you should ALWAYS call finite_key_valid prior to avoid unexpected errors, undefined behavior or missed key events. Related Docs * finite_key_valid finite_input_keyboard_init FiniteKeyboard","title":"finite_key_string_from_key"},{"location":"reference/functions/input/finite_key_string_from_key/#finite_key_string_from_key","text":"\u2754 finite_key_string_from_key was last modified in v0.6.0 . const char *finite_key_string_from_key(FiniteKey key) The finite_key_string_from_key takes a FiniteKey and returns an equalivlant string Type Decription FiniteKey key The FiniteKey to get a string for.","title":"finite_key_string_from_key"},{"location":"reference/functions/input/finite_key_string_from_key/#code-example","text":"#include <finite/input.h> #include <finite/log.h> FiniteKeyboard *kbd = finite_input_keyboard_init(myShell->display); FiniteKey xKey = finite_key_from_string(\"X\"); if (!finite_key_valid(xKey)) { FINITE_LOG_FATAL(\"Unable to poll NULL key\"); } // create wayland frame loop while (wl_display_dispatch_pending(myShell->display) != -1) { // poll for input finite_input_poll_keys(kbd, myShell); // handle input if (finite_key_pressed(xKey, kbd)) { const char *key = finite_key_string_from_key(xKey); FINITE_LOG(\"%s Pressed\\n\", key); } }","title":"Code Example"},{"location":"reference/functions/input/finite_key_string_from_key/#standard-usage","text":"When call this function you should ALWAYS call finite_key_valid prior to avoid unexpected errors, undefined behavior or missed key events.","title":"Standard Usage"},{"location":"reference/functions/input/finite_key_string_from_key/#related-docs","text":"finite_key_valid finite_input_keyboard_init FiniteKeyboard","title":"Related Docs"},{"location":"reference/functions/input/finite_key_up/","text":"finite_key_up * \u2754 finite_key_up was last modified in v0.6.0 . bool finite_key_up(FiniteKey key, FiniteKeyboard *board) The finite_key_up checks if a given FiniteKey is currently not being pressed. Type Decription FiniteKey key The FiniteKey to check. FiniteKeyboard *board The FiniteKeyboard to check for key events from. Code Example * #include <finite/input.h> #include <finite/log.h> FiniteKeyboard *kbd = finite_input_keyboard_init(myShell->display); FiniteKey xKey = finite_key_from_string(\"X\"); if (!finite_key_valid(xKey)) { FINITE_LOG_FATAL(\"Unable to poll NULL key\"); } // create wayland frame loop while (wl_display_dispatch_pending(myShell->display) != -1) { // poll for input finite_input_poll_keys(kbd, myShell); // handle input if (finite_key_up(xKey, kbd)) { FINITE_LOG(\"X not Pressed\\n\"); } } Standard Usage * This function returns true if the key is not down. For usefulness it should be paired with a finite_key_down or finite_key_pressed call. Related Docs * finite_key_down finite_key_pressed FiniteKeyboard","title":"finite_key_up"},{"location":"reference/functions/input/finite_key_up/#finite_key_up","text":"\u2754 finite_key_up was last modified in v0.6.0 . bool finite_key_up(FiniteKey key, FiniteKeyboard *board) The finite_key_up checks if a given FiniteKey is currently not being pressed. Type Decription FiniteKey key The FiniteKey to check. FiniteKeyboard *board The FiniteKeyboard to check for key events from.","title":"finite_key_up"},{"location":"reference/functions/input/finite_key_up/#code-example","text":"#include <finite/input.h> #include <finite/log.h> FiniteKeyboard *kbd = finite_input_keyboard_init(myShell->display); FiniteKey xKey = finite_key_from_string(\"X\"); if (!finite_key_valid(xKey)) { FINITE_LOG_FATAL(\"Unable to poll NULL key\"); } // create wayland frame loop while (wl_display_dispatch_pending(myShell->display) != -1) { // poll for input finite_input_poll_keys(kbd, myShell); // handle input if (finite_key_up(xKey, kbd)) { FINITE_LOG(\"X not Pressed\\n\"); } }","title":"Code Example"},{"location":"reference/functions/input/finite_key_up/#standard-usage","text":"This function returns true if the key is not down. For usefulness it should be paired with a finite_key_down or finite_key_pressed call.","title":"Standard Usage"},{"location":"reference/functions/input/finite_key_up/#related-docs","text":"finite_key_down finite_key_pressed FiniteKeyboard","title":"Related Docs"},{"location":"reference/functions/input/finite_key_valid/","text":"finite_key_valid * \u2754 finite_key_valid was last modified in v0.6.0 . FiniteKeyboard *finite_key_valid(FiniteKey key) The finite_key_valid verifies if a given FiniteKey is a valid FiniteKey. Type Decription FiniteKey key The FiniteKey to validate. Code Example * #include <finite/input.h> #include <finite/log.h> FiniteKeyboard *kbd = finite_input_keyboard_init(myShell->display); FiniteKey xKey = finite_key_from_string(\"X\"); if (!finite_key_valid(xKey)) { FINITE_LOG_FATAL(\"Unable to poll NULL key\"); } // create wayland frame loop while (wl_display_dispatch_pending(myShell->display) != -1) { // poll for input finite_input_poll_keys(kbd, myShell); // handle input if (finite_key_pressed(xKey, kbd)) { FINITE_LOG(\"X Pressed\\n\"); } } Standard Usage * When creating a new FiniteKey with a function such as finite_key_from_string you should ALWAYS call this function afterword to avoid unexpected errors, undefined behavior or missed key events. Related Docs * finite_key_from_string finite_input_keyboard_init FiniteKeyboard","title":"finite_key_valid"},{"location":"reference/functions/input/finite_key_valid/#finite_key_valid","text":"\u2754 finite_key_valid was last modified in v0.6.0 . FiniteKeyboard *finite_key_valid(FiniteKey key) The finite_key_valid verifies if a given FiniteKey is a valid FiniteKey. Type Decription FiniteKey key The FiniteKey to validate.","title":"finite_key_valid"},{"location":"reference/functions/input/finite_key_valid/#code-example","text":"#include <finite/input.h> #include <finite/log.h> FiniteKeyboard *kbd = finite_input_keyboard_init(myShell->display); FiniteKey xKey = finite_key_from_string(\"X\"); if (!finite_key_valid(xKey)) { FINITE_LOG_FATAL(\"Unable to poll NULL key\"); } // create wayland frame loop while (wl_display_dispatch_pending(myShell->display) != -1) { // poll for input finite_input_poll_keys(kbd, myShell); // handle input if (finite_key_pressed(xKey, kbd)) { FINITE_LOG(\"X Pressed\\n\"); } }","title":"Code Example"},{"location":"reference/functions/input/finite_key_valid/#standard-usage","text":"When creating a new FiniteKey with a function such as finite_key_from_string you should ALWAYS call this function afterword to avoid unexpected errors, undefined behavior or missed key events.","title":"Standard Usage"},{"location":"reference/functions/input/finite_key_valid/#related-docs","text":"finite_key_from_string finite_input_keyboard_init FiniteKeyboard","title":"Related Docs"},{"location":"reference/functions/input/finite_keyboard_destroy/","text":"finite_keyboard_destroy * \u2754 finite_keyboard_destroy was last modified in v0.6.0 . FiniteKeyboard *finite_keyboard_destroy(struct wl_display *device) The finite_keyboard_destroy attempts to destroy a FiniteKeyboard . Type Decription FiniteKeyboard *board The FiniteKeyboard to destrooy. Code Example * #include <finite/input.h> #include <finite/log.h> FiniteKeyboard *kbd = finite_input_keyboard_init(myShell->display); FiniteKey xKey = finite_key_from_string(\"X\"); if (!finite_key_valid(xKey)) { FINITE_LOG_FATAL(\"Unable to poll NULL key\"); } // create wayland frame loop while (wl_display_dispatch_pending(myShell->display) != -1) { // poll for input finite_input_poll_keys(kbd, myShell); // handle input if (finite_key_pressed(xKey, kbd)) { FINITE_LOG(\"X Pressed\\n\"); } } finite_keyboard_destroy(kbd); Standard Usage * This function must have a valid FiniteKeyboard . The function should be called as soon as the FiniteKeyboard . is no longer needed. FiniteKeyboards are not automatically cleaned up. Related Docs * FiniteKeyboard finite_key_valid","title":"finite_keyboard_destroy"},{"location":"reference/functions/input/finite_keyboard_destroy/#finite_keyboard_destroy","text":"\u2754 finite_keyboard_destroy was last modified in v0.6.0 . FiniteKeyboard *finite_keyboard_destroy(struct wl_display *device) The finite_keyboard_destroy attempts to destroy a FiniteKeyboard . Type Decription FiniteKeyboard *board The FiniteKeyboard to destrooy.","title":"finite_keyboard_destroy"},{"location":"reference/functions/input/finite_keyboard_destroy/#code-example","text":"#include <finite/input.h> #include <finite/log.h> FiniteKeyboard *kbd = finite_input_keyboard_init(myShell->display); FiniteKey xKey = finite_key_from_string(\"X\"); if (!finite_key_valid(xKey)) { FINITE_LOG_FATAL(\"Unable to poll NULL key\"); } // create wayland frame loop while (wl_display_dispatch_pending(myShell->display) != -1) { // poll for input finite_input_poll_keys(kbd, myShell); // handle input if (finite_key_pressed(xKey, kbd)) { FINITE_LOG(\"X Pressed\\n\"); } } finite_keyboard_destroy(kbd);","title":"Code Example"},{"location":"reference/functions/input/finite_keyboard_destroy/#standard-usage","text":"This function must have a valid FiniteKeyboard . The function should be called as soon as the FiniteKeyboard . is no longer needed. FiniteKeyboards are not automatically cleaned up.","title":"Standard Usage"},{"location":"reference/functions/input/finite_keyboard_destroy/#related-docs","text":"FiniteKeyboard finite_key_valid","title":"Related Docs"},{"location":"reference/functions/render/","text":"Render * The Finite Render function family","title":"Render"},{"location":"reference/functions/render/#render","text":"The Finite Render function family","title":"Render"},{"location":"reference/functions/render/finite_render_create_device/","text":"finite_render_create_device * \u2754 finite_render_create_device was last modified in v0.6.0 . void finite_render_create_device(FiniteRender *render, FiniteRenderQueueFamilies fIndex, uint32_t *uniqueQueueFamilies, char **device_extentsions, uint32_t _ext); reates a logical Vulkan device and stores device queues in the render context. Parameters * Type Description FiniteRender *render The render context to store the created device and queues. FiniteRenderQueueFamilies fIndex Contains indices for the graphics and presentation queues. uint32_t *uniqueQueueFamilies Array of unique queue family indices used to create queues. char **device_extentsions Optional array of Vulkan device extension names to enable. uint32_t _ext Number of device extensions in the array. Code Example * #include <finite/log.h> #include <finite/render.h> uint32_t uniqueQueues[] = { graphicsQueueIndex, presentQueueIndex }; FiniteRenderQueueFamilies families = { .graphicsFamily = graphicsQueueIndex, .presentFamily = presentQueueIndex, ._unique = 2 }; char *extensions[] = { VK_KHR_SWAPCHAIN_EXTENSION_NAME }; finite_render_create_device(render, families, uniqueQueues, extensions, 1); Standard Usage * Call this after selecting a physical device. It will create a logical device and initialize queues needed for rendering. Related Docs * finite_render_create_physical_device finite_render_init","title":"finite_render_create_device"},{"location":"reference/functions/render/finite_render_create_device/#finite_render_create_device","text":"\u2754 finite_render_create_device was last modified in v0.6.0 . void finite_render_create_device(FiniteRender *render, FiniteRenderQueueFamilies fIndex, uint32_t *uniqueQueueFamilies, char **device_extentsions, uint32_t _ext); reates a logical Vulkan device and stores device queues in the render context.","title":"finite_render_create_device"},{"location":"reference/functions/render/finite_render_create_device/#parameters","text":"Type Description FiniteRender *render The render context to store the created device and queues. FiniteRenderQueueFamilies fIndex Contains indices for the graphics and presentation queues. uint32_t *uniqueQueueFamilies Array of unique queue family indices used to create queues. char **device_extentsions Optional array of Vulkan device extension names to enable. uint32_t _ext Number of device extensions in the array.","title":"Parameters"},{"location":"reference/functions/render/finite_render_create_device/#code-example","text":"#include <finite/log.h> #include <finite/render.h> uint32_t uniqueQueues[] = { graphicsQueueIndex, presentQueueIndex }; FiniteRenderQueueFamilies families = { .graphicsFamily = graphicsQueueIndex, .presentFamily = presentQueueIndex, ._unique = 2 }; char *extensions[] = { VK_KHR_SWAPCHAIN_EXTENSION_NAME }; finite_render_create_device(render, families, uniqueQueues, extensions, 1);","title":"Code Example"},{"location":"reference/functions/render/finite_render_create_device/#standard-usage","text":"Call this after selecting a physical device. It will create a logical device and initialize queues needed for rendering.","title":"Standard Usage"},{"location":"reference/functions/render/finite_render_create_device/#related-docs","text":"finite_render_create_physical_device finite_render_init","title":"Related Docs"},{"location":"reference/functions/render/finite_render_create_example_render_pass/","text":"finite_render_create_example_render_pass * \u2754 finite_render_create_example_render_pass was last modified in v0.6.0 . void finite_render_create_example_render_pass(FiniteRender *render); Creates a basic Vulkan render pass and stores it in the render context. Parameters * Type Description FiniteRender *render The render context to store the created render pass. Code Example * #include <finite/log.h> #include <finite/render.h> finite_render_create_example_render_pass(render); Standard Usage * Call this after creating the swapchain and selecting an image format. It will set up a basic render pass for use with framebuffers. Related Pages * finite_render_create_swapchain finite_render_init","title":"finite_render_create_example_render_pass"},{"location":"reference/functions/render/finite_render_create_example_render_pass/#finite_render_create_example_render_pass","text":"\u2754 finite_render_create_example_render_pass was last modified in v0.6.0 . void finite_render_create_example_render_pass(FiniteRender *render); Creates a basic Vulkan render pass and stores it in the render context.","title":"finite_render_create_example_render_pass"},{"location":"reference/functions/render/finite_render_create_example_render_pass/#parameters","text":"Type Description FiniteRender *render The render context to store the created render pass.","title":"Parameters"},{"location":"reference/functions/render/finite_render_create_example_render_pass/#code-example","text":"#include <finite/log.h> #include <finite/render.h> finite_render_create_example_render_pass(render);","title":"Code Example"},{"location":"reference/functions/render/finite_render_create_example_render_pass/#standard-usage","text":"Call this after creating the swapchain and selecting an image format. It will set up a basic render pass for use with framebuffers.","title":"Standard Usage"},{"location":"reference/functions/render/finite_render_create_example_render_pass/#related-pages","text":"finite_render_create_swapchain finite_render_init","title":"Related Pages"},{"location":"reference/functions/render/finite_render_create_physical_device/","text":"finite_render_create_physical_device * \u2754 finite_render_create_physical_device was last modified in v0.6.0 . void finite_render_create_physical_device(FiniteRender *render); Selects and stores a compatible physical device for the given render context. Parameters * Type Decription FiniteRender *render The render context to store the selected physical device. #include <finite/log.h> #include <finite/render.h> char *extensions[] = { VK_KHR_SURFACE_EXTENSION_NAME, VK_EXT_DEBUG_UTILS_EXTENSION_NAME, VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME }; char *layers[] = { \"VK_LAYER_KHRONOS_validation\" }; FiniteRender *render = finite_render_init(shell, extensions, layers, 3, 1); finite_render_create_physical_device(render); Standard Usage * Call this after initializing the render context. It will choose a compatible device from the available hardware. Related Docs * finite_render_init","title":"finite_render_create_physical_device"},{"location":"reference/functions/render/finite_render_create_physical_device/#finite_render_create_physical_device","text":"\u2754 finite_render_create_physical_device was last modified in v0.6.0 . void finite_render_create_physical_device(FiniteRender *render); Selects and stores a compatible physical device for the given render context.","title":"finite_render_create_physical_device"},{"location":"reference/functions/render/finite_render_create_physical_device/#parameters","text":"Type Decription FiniteRender *render The render context to store the selected physical device. #include <finite/log.h> #include <finite/render.h> char *extensions[] = { VK_KHR_SURFACE_EXTENSION_NAME, VK_EXT_DEBUG_UTILS_EXTENSION_NAME, VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME }; char *layers[] = { \"VK_LAYER_KHRONOS_validation\" }; FiniteRender *render = finite_render_init(shell, extensions, layers, 3, 1); finite_render_create_physical_device(render);","title":"Parameters"},{"location":"reference/functions/render/finite_render_create_physical_device/#standard-usage","text":"Call this after initializing the render context. It will choose a compatible device from the available hardware.","title":"Standard Usage"},{"location":"reference/functions/render/finite_render_create_physical_device/#related-docs","text":"finite_render_init","title":"Related Docs"},{"location":"reference/functions/render/finite_render_create_swapchain/","text":"finite_render_create_swapchain * \u2754 finite_render_create_swapchain was last modified in v0.6.0 . void finite_render_create_swapchain(FiniteRender *render, FiniteRenderSwapchainInfo info); Creates a Vulkan swapchain using the provided capabilities and render configuration. Parameters * Type Description FiniteRender *render The render context to store the created swapchain. FiniteRenderSwapchainInfo info Holds surface capabilities for configuring the swapchain. Code Examples * #include <finite/log.h> #include <finite/render.h> FiniteRenderSwapchainInfo info = { .caps = surfaceCapabilities }; finite_render_create_swapchain(render, info); Standard Usage * Call this after configuring the render surface and selecting the image format and present mode. It will create the swapchain used for rendering frames Related Docs * finite_render_init","title":"finite_render_create_swapchain"},{"location":"reference/functions/render/finite_render_create_swapchain/#finite_render_create_swapchain","text":"\u2754 finite_render_create_swapchain was last modified in v0.6.0 . void finite_render_create_swapchain(FiniteRender *render, FiniteRenderSwapchainInfo info); Creates a Vulkan swapchain using the provided capabilities and render configuration.","title":"finite_render_create_swapchain"},{"location":"reference/functions/render/finite_render_create_swapchain/#parameters","text":"Type Description FiniteRender *render The render context to store the created swapchain. FiniteRenderSwapchainInfo info Holds surface capabilities for configuring the swapchain.","title":"Parameters"},{"location":"reference/functions/render/finite_render_create_swapchain/#code-examples","text":"#include <finite/log.h> #include <finite/render.h> FiniteRenderSwapchainInfo info = { .caps = surfaceCapabilities }; finite_render_create_swapchain(render, info);","title":"Code Examples"},{"location":"reference/functions/render/finite_render_create_swapchain/#standard-usage","text":"Call this after configuring the render surface and selecting the image format and present mode. It will create the swapchain used for rendering frames","title":"Standard Usage"},{"location":"reference/functions/render/finite_render_create_swapchain/#related-docs","text":"finite_render_init","title":"Related Docs"},{"location":"reference/functions/render/finite_render_create_swapchain_images/","text":"finite_render_create_swapchain_images * \u2754 finite_render_create_swapchain_images was last modified in v0.6.0 . void finite_render_create_swapchain_images(FiniteRender *render); Retrieves swapchain images and creates image views for rendering. Parameters * Type Description FiniteRender *render The render context to store the retrieved images and views. Code Examples * #include <finite/log.h> #include <finite/render.h> finite_render_create_swapchain_images(render); Standard Usage * Call this after creating the swapchain. It will populate the render object with image handles and image views for each swapchain image. Related Docs * finite_render_create_swapchain finite_render_init","title":"finite_render_create_swapchain_images"},{"location":"reference/functions/render/finite_render_create_swapchain_images/#finite_render_create_swapchain_images","text":"\u2754 finite_render_create_swapchain_images was last modified in v0.6.0 . void finite_render_create_swapchain_images(FiniteRender *render); Retrieves swapchain images and creates image views for rendering.","title":"finite_render_create_swapchain_images"},{"location":"reference/functions/render/finite_render_create_swapchain_images/#parameters","text":"Type Description FiniteRender *render The render context to store the retrieved images and views.","title":"Parameters"},{"location":"reference/functions/render/finite_render_create_swapchain_images/#code-examples","text":"#include <finite/log.h> #include <finite/render.h> finite_render_create_swapchain_images(render);","title":"Code Examples"},{"location":"reference/functions/render/finite_render_create_swapchain_images/#standard-usage","text":"Call this after creating the swapchain. It will populate the render object with image handles and image views for each swapchain image.","title":"Standard Usage"},{"location":"reference/functions/render/finite_render_create_swapchain_images/#related-docs","text":"finite_render_create_swapchain finite_render_init","title":"Related Docs"},{"location":"reference/functions/render/finite_render_get_shader_code/","text":"finite_render_get_shader_code * \u2754 finite_render_get_shader_code was last modified in v0.6.0 . char *finite_render_get_shader_code(const char *fileName, uint32_t *pShaderSize) The finite_render_get_shader_code attempts to get shader code and convert it into bytes. Parameters * Type Decription char *fileName The file to get shader code from. uint32_t *pShaderSize Size of the shader code Code Example * #include <finite/render.h> #include <finite/log.h> // load shaders uint32_t vertSize; char *vertCode = finite_render_get_shader_code(\"vert.spv\", &vertSize); bool success = finite_render_get_shader_module(render, vertCode, vertSize); if (!success) { FINITE_LOG_ERROR(\"Unable to create Vertex Shader Module\"); return -1; } uint32_t fragSize; char *fragCode = finite_render_get_shader_code(\"frag.spv\", &fragSize); success = finite_render_get_shader_module(render, fragCode, fragSize); if (!success) { FINITE_LOG_ERROR(\"Unable to create Fragment Shader Module\"); return -1; } Notes * finite_render_get_shader_code requires precompiled shaders in order to work. Standard Usage * This function requires you to get the shader's file size. Related Docs * FiniteShaderType","title":"finite_render_get_shader_code"},{"location":"reference/functions/render/finite_render_get_shader_code/#finite_render_get_shader_code","text":"\u2754 finite_render_get_shader_code was last modified in v0.6.0 . char *finite_render_get_shader_code(const char *fileName, uint32_t *pShaderSize) The finite_render_get_shader_code attempts to get shader code and convert it into bytes.","title":"finite_render_get_shader_code"},{"location":"reference/functions/render/finite_render_get_shader_code/#parameters","text":"Type Decription char *fileName The file to get shader code from. uint32_t *pShaderSize Size of the shader code","title":"Parameters"},{"location":"reference/functions/render/finite_render_get_shader_code/#code-example","text":"#include <finite/render.h> #include <finite/log.h> // load shaders uint32_t vertSize; char *vertCode = finite_render_get_shader_code(\"vert.spv\", &vertSize); bool success = finite_render_get_shader_module(render, vertCode, vertSize); if (!success) { FINITE_LOG_ERROR(\"Unable to create Vertex Shader Module\"); return -1; } uint32_t fragSize; char *fragCode = finite_render_get_shader_code(\"frag.spv\", &fragSize); success = finite_render_get_shader_module(render, fragCode, fragSize); if (!success) { FINITE_LOG_ERROR(\"Unable to create Fragment Shader Module\"); return -1; }","title":"Code Example"},{"location":"reference/functions/render/finite_render_get_shader_code/#notes","text":"finite_render_get_shader_code requires precompiled shaders in order to work.","title":"Notes"},{"location":"reference/functions/render/finite_render_get_shader_code/#standard-usage","text":"This function requires you to get the shader's file size.","title":"Standard Usage"},{"location":"reference/functions/render/finite_render_get_shader_code/#related-docs","text":"FiniteShaderType","title":"Related Docs"},{"location":"reference/functions/render/finite_render_init/","text":"finite_render_init * \u2754 finite_render_init was last modified in v0.6.0 . FiniteRender *finite_render_init(FiniteShell *shell, char **extensions, char **layers, uint32_t _exts, uint32_t _layers); Creates a Vulkan instance and surface using the provided shell and configuration data. Parameters * Type Description FiniteShell *shell Shell that holds the surface and display needed for surface creation. char **extensions Optional array of Vulkan instance extensions to enable. char **layers Optional array of Vulkan validation layers to enable. uint32_t _exts Number of Vulkan instance extensions in the extensions array. uint32_t _layers Number of Vulkan validation layers in the layers array. Code Example * #include <finite/log.h> #include <finite/render.h> FiniteShell *shell = finite_shell_init(\"wayland-0\"); char *extensions[] = { VK_KHR_SURFACE_EXTENSION_NAME, VK_EXT_DEBUG_UTILS_EXTENSION_NAME, VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME }; char *layers[] = { \"VK_LAYER_KHRONOS_validation\" }; FiniteRender *render = finite_render_init(shell, extensions, layers, 3, 1); Standard Usage * This function must have a valid FiniteShell . Call this function after creating a shell. It sets up the Vulkan instance and prepares a surface for rendering. FiniteShell *shell = finite_shell_init(\"wayland-0\"); FiniteRender *render = finite_render_init(shell, NULL, NULL, 0, 0); Related Docs * finite_render_create_physical_device","title":"finite_render_init"},{"location":"reference/functions/render/finite_render_init/#finite_render_init","text":"\u2754 finite_render_init was last modified in v0.6.0 . FiniteRender *finite_render_init(FiniteShell *shell, char **extensions, char **layers, uint32_t _exts, uint32_t _layers); Creates a Vulkan instance and surface using the provided shell and configuration data.","title":"finite_render_init"},{"location":"reference/functions/render/finite_render_init/#parameters","text":"Type Description FiniteShell *shell Shell that holds the surface and display needed for surface creation. char **extensions Optional array of Vulkan instance extensions to enable. char **layers Optional array of Vulkan validation layers to enable. uint32_t _exts Number of Vulkan instance extensions in the extensions array. uint32_t _layers Number of Vulkan validation layers in the layers array.","title":"Parameters"},{"location":"reference/functions/render/finite_render_init/#code-example","text":"#include <finite/log.h> #include <finite/render.h> FiniteShell *shell = finite_shell_init(\"wayland-0\"); char *extensions[] = { VK_KHR_SURFACE_EXTENSION_NAME, VK_EXT_DEBUG_UTILS_EXTENSION_NAME, VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME }; char *layers[] = { \"VK_LAYER_KHRONOS_validation\" }; FiniteRender *render = finite_render_init(shell, extensions, layers, 3, 1);","title":"Code Example"},{"location":"reference/functions/render/finite_render_init/#standard-usage","text":"This function must have a valid FiniteShell . Call this function after creating a shell. It sets up the Vulkan instance and prepares a surface for rendering. FiniteShell *shell = finite_shell_init(\"wayland-0\"); FiniteRender *render = finite_render_init(shell, NULL, NULL, 0, 0);","title":"Standard Usage"},{"location":"reference/functions/render/finite_render_init/#related-docs","text":"finite_render_create_physical_device","title":"Related Docs"},{"location":"reference/types/FiniteBtn/","text":"FiniteBtn * \u2754 FiniteBtn was last modified in 0.4.0 typedef struct FiniteBtn FiniteBtn; struct FiniteBtn { FiniteBtn *self; bool isActive; int id; FiniteBtnRelationShips *relations; void *data; FiniteShell *link; void (*on_select_callback)(FiniteBtn *self, int id, void *data); void (*on_focus_callback)(FiniteBtn *self, int id, void *data); void (*on_unfocus_callback)(FiniteBtn *self, int id, void *data); }; The FiniteBtn struct refers to metadata for a button drawn with Cairo. In Cairo, everything is stateless, meaning there is no way to refer to specific parts of UI. FiniteBtn provides an easy way to refer to button elements and keep track of when they are selected. Properties * Type Decription FiniteBtn *self Refers to this button. bool isActive Refers to whether this button is currently selected. int id The ID of the button. Button IDs start at 0 and refer to the position of the button in the array. FiniteBtnRelationShips *relations The FiniteBtnRelationShips for this button. FiniteShell *link The FiniteShell assocciated with this button void *data Custom data Functions * Function Description void *on_select_callback The on_selected callback. Fires when the button is active has recieved a Selected event. void *on_focus_callback The on_focused callback. Fires when the button becomes active. void *on_unfocus_callback The on_unfocused callback. Fires when the button becomes unactive after previously being active. Notes * \u26a0 Button ids can change!! Button ids refer to the position of the data in the buttons array inside of [`FiniteShell`]((../FiniteShell/)). This means that if a button is deleted, all [`FiniteBtnRelationShips`](../FiniteBtnRelationShips) and other references to buttons that come after that button are **invalid**. If you have a lot of buttons that rely on each other, be extreme careful when deleting buttons. Additionall, when creating temporary buttons, ensure all base buttons have been made first to avoid unexpected behavior It's important to note that FiniteBtn does not store location data . It's up to you as the developer to figure out where buttons are. There are several different ways to do this, such as storing the button's location in a custom struct store in FiniteBtn.data or simply hardcoding the location. Standard Usage * When creating more than one FiniteBtn , a valid FiniteBtnRelatioShip is required to make both buttons selectable. The link value should refer to a valid FiniteShell that contains the drawn data of the button. Related Docs * finite_button_create_relation FiniteShell","title":"FiniteBtn"},{"location":"reference/types/FiniteBtn/#finitebtn","text":"\u2754 FiniteBtn was last modified in 0.4.0 typedef struct FiniteBtn FiniteBtn; struct FiniteBtn { FiniteBtn *self; bool isActive; int id; FiniteBtnRelationShips *relations; void *data; FiniteShell *link; void (*on_select_callback)(FiniteBtn *self, int id, void *data); void (*on_focus_callback)(FiniteBtn *self, int id, void *data); void (*on_unfocus_callback)(FiniteBtn *self, int id, void *data); }; The FiniteBtn struct refers to metadata for a button drawn with Cairo. In Cairo, everything is stateless, meaning there is no way to refer to specific parts of UI. FiniteBtn provides an easy way to refer to button elements and keep track of when they are selected.","title":"FiniteBtn"},{"location":"reference/types/FiniteBtn/#properties","text":"Type Decription FiniteBtn *self Refers to this button. bool isActive Refers to whether this button is currently selected. int id The ID of the button. Button IDs start at 0 and refer to the position of the button in the array. FiniteBtnRelationShips *relations The FiniteBtnRelationShips for this button. FiniteShell *link The FiniteShell assocciated with this button void *data Custom data","title":"Properties"},{"location":"reference/types/FiniteBtn/#functions","text":"Function Description void *on_select_callback The on_selected callback. Fires when the button is active has recieved a Selected event. void *on_focus_callback The on_focused callback. Fires when the button becomes active. void *on_unfocus_callback The on_unfocused callback. Fires when the button becomes unactive after previously being active.","title":"Functions"},{"location":"reference/types/FiniteBtn/#notes","text":"","title":"Notes"},{"location":"reference/types/FiniteBtn/#standard-usage","text":"When creating more than one FiniteBtn , a valid FiniteBtnRelatioShip is required to make both buttons selectable. The link value should refer to a valid FiniteShell that contains the drawn data of the button.","title":"Standard Usage"},{"location":"reference/types/FiniteBtn/#related-docs","text":"finite_button_create_relation FiniteShell","title":"Related Docs"},{"location":"reference/types/FiniteBtnRelationShips/","text":"FiniteBtnRelationShips * \u2754 FiniteBtnRelationShips was last modified in 0.4.0 typedef struct { int left; int right; int down; int up; // optional diagonals int leftUp; int rightUp; int leftDown; int rightDown; } FiniteBtnRelationShips; The FiniteBtnRelationShips struct describes the relationship between a given button and it's neighbors. Properties * Type Decription int left,right,down.... Each parameter refers to the id of the button in that direction. Standard Usage * When creating a FiniteBtn this struct refers to relationship between it an other buttons. When there is more than one button you must include a valid FiniteBtnRelationShips by calling finite_button_create_relation . Related Docs * finite_button_create_relation","title":"FiniteBtnRelationShips"},{"location":"reference/types/FiniteBtnRelationShips/#finitebtnrelationships","text":"\u2754 FiniteBtnRelationShips was last modified in 0.4.0 typedef struct { int left; int right; int down; int up; // optional diagonals int leftUp; int rightUp; int leftDown; int rightDown; } FiniteBtnRelationShips; The FiniteBtnRelationShips struct describes the relationship between a given button and it's neighbors.","title":"FiniteBtnRelationShips"},{"location":"reference/types/FiniteBtnRelationShips/#properties","text":"Type Decription int left,right,down.... Each parameter refers to the id of the button in that direction.","title":"Properties"},{"location":"reference/types/FiniteBtnRelationShips/#standard-usage","text":"When creating a FiniteBtn this struct refers to relationship between it an other buttons. When there is more than one button you must include a valid FiniteBtnRelationShips by calling finite_button_create_relation .","title":"Standard Usage"},{"location":"reference/types/FiniteBtnRelationShips/#related-docs","text":"finite_button_create_relation","title":"Related Docs"},{"location":"reference/types/FiniteKeyState/","text":"FiniteKeyState * \u2754 FiniteKeyState was last modified in 0.4.9 typedef struct { uint16_t id; bool isHeld; bool isDown; bool isUp; } FiniteKeyState; The FiniteKeyState struct refers to the state single FiniteKey Properties * Type Decription uint32_t The id of this FiniteKeyState. bool isHeld Whether the key is being held. bool isDown Whether the key is down. bool isUp Whether the key is not pressed. Standard Usage * This struct is automatically created for all available keys with a FiniteKeyboard Related Docs * finite_input_keyboard_init FiniteKeyboard finite_keyboard_destroy","title":"FiniteKeyState"},{"location":"reference/types/FiniteKeyState/#finitekeystate","text":"\u2754 FiniteKeyState was last modified in 0.4.9 typedef struct { uint16_t id; bool isHeld; bool isDown; bool isUp; } FiniteKeyState; The FiniteKeyState struct refers to the state single FiniteKey","title":"FiniteKeyState"},{"location":"reference/types/FiniteKeyState/#properties","text":"Type Decription uint32_t The id of this FiniteKeyState. bool isHeld Whether the key is being held. bool isDown Whether the key is down. bool isUp Whether the key is not pressed.","title":"Properties"},{"location":"reference/types/FiniteKeyState/#standard-usage","text":"This struct is automatically created for all available keys with a FiniteKeyboard","title":"Standard Usage"},{"location":"reference/types/FiniteKeyState/#related-docs","text":"finite_input_keyboard_init FiniteKeyboard finite_keyboard_destroy","title":"Related Docs"},{"location":"reference/types/FiniteKeyboard/","text":"FiniteKeyboard * \u2754 FiniteKeyboard was last modified in 0.4.9 typedef struct { FiniteInput *input; struct wl_keyboard *keyboard; struct xkb_context *xkb_ctx; struct xkb_keymap *xkb_keymap; struct xkb_state *xkb_state; FiniteKeyState keys[256]; bool keys_down[256]; bool keys_up[256]; } FiniteKeyboard; The FiniteKeyboard struct refers to a single keyboard attached to a shell via the internal FiniteInput type. Properties * Type Decription struct wl_keyboard *keyboard The Wayland Keyboard that is connected to this FiniteKeyboard struct xkb_context *xkb_ctx The xkb context for the input device. struct xkb_keymap *xkb_keymap The xkb keymapping for the input device. struct xkb_state *xkb_state The xkb state of the input device. FiniteKeyState keys[256] The FiniteKeyState array. bool keys_down[256] The FiniteKey isDown array. bool keys_up[256] The FiniteKey isUp array. Standard Usage * This struct should be created with finite_input_keyboard_init and destroyed with finite_keyboard_destroy Related Docs * finite_input_keyboard_init finite_keyboard_destroy","title":"FiniteKeyboard"},{"location":"reference/types/FiniteKeyboard/#finitekeyboard","text":"\u2754 FiniteKeyboard was last modified in 0.4.9 typedef struct { FiniteInput *input; struct wl_keyboard *keyboard; struct xkb_context *xkb_ctx; struct xkb_keymap *xkb_keymap; struct xkb_state *xkb_state; FiniteKeyState keys[256]; bool keys_down[256]; bool keys_up[256]; } FiniteKeyboard; The FiniteKeyboard struct refers to a single keyboard attached to a shell via the internal FiniteInput type.","title":"FiniteKeyboard"},{"location":"reference/types/FiniteKeyboard/#properties","text":"Type Decription struct wl_keyboard *keyboard The Wayland Keyboard that is connected to this FiniteKeyboard struct xkb_context *xkb_ctx The xkb context for the input device. struct xkb_keymap *xkb_keymap The xkb keymapping for the input device. struct xkb_state *xkb_state The xkb state of the input device. FiniteKeyState keys[256] The FiniteKeyState array. bool keys_down[256] The FiniteKey isDown array. bool keys_up[256] The FiniteKey isUp array.","title":"Properties"},{"location":"reference/types/FiniteKeyboard/#standard-usage","text":"This struct should be created with finite_input_keyboard_init and destroyed with finite_keyboard_destroy","title":"Standard Usage"},{"location":"reference/types/FiniteKeyboard/#related-docs","text":"finite_input_keyboard_init finite_keyboard_destroy","title":"Related Docs"},{"location":"reference/types/FinitePlaybackDevice/","text":"FinitePlaybackDevice * \u2754 FinitePlaybackDevice was last modified in 0.4.9 typedef struct FinitePlaybackDevice FinitePlaybackDevice; struct FinitePlaybackDevice { char *name; char *filename; bool isPlaying; bool isPaused; short *audioBuffer; FinitePlaybackDuration dur; snd_pcm_t *device; snd_pcm_format_t format; snd_pcm_hw_params_t *params; snd_pcm_uframes_t frames; SNDFILE *file; sf_count_t sfFrames; uint32_t sample_rate; uint32_t channels; uint32_t buff_time; uint32_t buff_per; double freq; int verbose; int resample; int per_event; }; The FinitePlaybackDevice struct refers to a single audio player. Properties * Type Decription char *name The name of the audio device in use. Defaults to \"default\". char *filename The name of the audio in use. bool isPlaying Whether the audio stream is being read (the audio is playing sound) bool isPaused Whether the audio is paused. short *audioBuffer The audio period . FinitePlaybackDuration dur The FinitePlaybackDuration snd_pcm_t *device The ALSA device. snd_pcm_format_t format The ALSA format of the audio. snd_pcm_hw_params_t *params The ALSA audio hardware params. snd_pcm_uframes_t frames The size of the audio period . SNDFILE *file The SND file descriptor for the audio. sf_count_t sfFrames SND Audio Frames. Used to calcuate the actual audio duration. uint32_t sample_rate The Sample Rate of the audio uint32_t channels The number of channels the audio supports. 1 = Mono and 2 = Stereo uint32_t buff_time Unused. uint32_t buff_per Unused. double freq Unused. int verbose Unused. int resample The resample rate of the audio. int per_event Unused. Standard Usage * This struct refers to a single audio. Do not reuse a FinitePlaybackDevice for multiple audios. This struct should be created with finite_audio_device_init and destroyed with finite_audio_cleanup Related Docs * finite_audio_device_init finite_audio_cleanup","title":"FinitePlaybackDevice"},{"location":"reference/types/FinitePlaybackDevice/#finiteplaybackdevice","text":"\u2754 FinitePlaybackDevice was last modified in 0.4.9 typedef struct FinitePlaybackDevice FinitePlaybackDevice; struct FinitePlaybackDevice { char *name; char *filename; bool isPlaying; bool isPaused; short *audioBuffer; FinitePlaybackDuration dur; snd_pcm_t *device; snd_pcm_format_t format; snd_pcm_hw_params_t *params; snd_pcm_uframes_t frames; SNDFILE *file; sf_count_t sfFrames; uint32_t sample_rate; uint32_t channels; uint32_t buff_time; uint32_t buff_per; double freq; int verbose; int resample; int per_event; }; The FinitePlaybackDevice struct refers to a single audio player.","title":"FinitePlaybackDevice"},{"location":"reference/types/FinitePlaybackDevice/#properties","text":"Type Decription char *name The name of the audio device in use. Defaults to \"default\". char *filename The name of the audio in use. bool isPlaying Whether the audio stream is being read (the audio is playing sound) bool isPaused Whether the audio is paused. short *audioBuffer The audio period . FinitePlaybackDuration dur The FinitePlaybackDuration snd_pcm_t *device The ALSA device. snd_pcm_format_t format The ALSA format of the audio. snd_pcm_hw_params_t *params The ALSA audio hardware params. snd_pcm_uframes_t frames The size of the audio period . SNDFILE *file The SND file descriptor for the audio. sf_count_t sfFrames SND Audio Frames. Used to calcuate the actual audio duration. uint32_t sample_rate The Sample Rate of the audio uint32_t channels The number of channels the audio supports. 1 = Mono and 2 = Stereo uint32_t buff_time Unused. uint32_t buff_per Unused. double freq Unused. int verbose Unused. int resample The resample rate of the audio. int per_event Unused.","title":"Properties"},{"location":"reference/types/FinitePlaybackDevice/#standard-usage","text":"This struct refers to a single audio. Do not reuse a FinitePlaybackDevice for multiple audios. This struct should be created with finite_audio_device_init and destroyed with finite_audio_cleanup","title":"Standard Usage"},{"location":"reference/types/FinitePlaybackDevice/#related-docs","text":"finite_audio_device_init finite_audio_cleanup","title":"Related Docs"},{"location":"reference/types/FinitePlaybackDuration/","text":"FinitePlaybackDuration * \u2754 FinitePlaybackDuration was last modified in 0.4.9 typedef struct FinitePlaybackDuration FinitePlaybackDuration; struct FinitePlaybackDuration { double trueSeconds; int hours; int minutes; int seconds; int milliseconds; }; The FinitePlaybackDuration struct refers to a single audio's duration. Properties * Type Decription double trueSeconds The true duration of the audio in seconds int hours The amount of hours in the audio's duration. int minutes The minutes in the audio's duration (after calculating the hours) int seconds The seconds in the audio's duration (after calculating the minutes) int milliseconds The ms in the audio's duration (after calculating the seconds) Standard Usage * This struct should be created with finite_audio_get_audio_duration and destroyed with finite_audio_cleanup Related Docs * finite_audio_get_audio_duration finite_audio_cleanup","title":"FinitePlaybackDuration"},{"location":"reference/types/FinitePlaybackDuration/#finiteplaybackduration","text":"\u2754 FinitePlaybackDuration was last modified in 0.4.9 typedef struct FinitePlaybackDuration FinitePlaybackDuration; struct FinitePlaybackDuration { double trueSeconds; int hours; int minutes; int seconds; int milliseconds; }; The FinitePlaybackDuration struct refers to a single audio's duration.","title":"FinitePlaybackDuration"},{"location":"reference/types/FinitePlaybackDuration/#properties","text":"Type Decription double trueSeconds The true duration of the audio in seconds int hours The amount of hours in the audio's duration. int minutes The minutes in the audio's duration (after calculating the hours) int seconds The seconds in the audio's duration (after calculating the minutes) int milliseconds The ms in the audio's duration (after calculating the seconds)","title":"Properties"},{"location":"reference/types/FinitePlaybackDuration/#standard-usage","text":"This struct should be created with finite_audio_get_audio_duration and destroyed with finite_audio_cleanup","title":"Standard Usage"},{"location":"reference/types/FinitePlaybackDuration/#related-docs","text":"finite_audio_get_audio_duration finite_audio_cleanup","title":"Related Docs"},{"location":"reference/types/FiniteShell/","text":"FiniteShell * \u2754 FiniteShell was last modified in 0.4.0 typedef struct FiniteShell FiniteShell; struct FiniteShell{ int shm_fd; int pool_size; int stride; uint8_t *pool_data; struct wl_display *display; struct wl_registry *registry; struct wl_output *output; struct wl_shm *shm; struct wl_shm_pool *pool; struct wl_buffer *buffer; struct wl_compositor *isle; struct wl_surface *isle_surface; struct xdg_wm_base *base; struct xdg_surface *surface; struct xdg_toplevel *window; struct zwlr_layer_shell_v1 *shell; struct zwlr_layer_surface_v1 *layer_surface; FiniteWindowInfo *details; cairo_t *cr; cairo_surface_t *cairo_surface; unsigned char *snapshot; FiniteBtn **btns; int _btns; int activeButton; void *data; }; The FiniteShell struct stores general information about a window. Properties * Type Decription int shm_fd An integer file descriptor for the shared memory(shm) buffer associated with the file. int pool_size The size of the shm pool int stride The spacing between blocks of memory when drawing with Cairo. uint8_t pool_data The mmapped data in the pool. struct wl_display *display The Wayland display associated with the FiniteShell. struct wl_registry *registry The Wayland registry associated with the display. struct wl_output *output The Wayland Output that is currently connected. struct wl_shm *shm The Wayland shm struct associated with the FiniteShell struct wl_shm_pool *pool The Wayland shm pool associated with the shm struct wl_buffer *buffer The Wayland shm buffer associated with the FiniteShell struct wl_compositor *isle The Compositor connected the display struct wl_surface *isle_surface The Wayland surface connected to display struct xdg_wm_base *base The xdg_wm_base associated with the FiniteShell struct xdg_surface *surface The xdg_surface associated with the base struct xdg_toplevel *window The xdg_toplevel where data will be rendered to. struct zwlr_layer_shell_v1 *shell The layer shell associated with the FiniteShell struct zwlr_layer_surface_v1 *layer_surface The layer surface associated with the layer shell FiniteWindowInfo *details Data about the window cairo_t *cr The Cairo drawing object. cairo_surface_t *cairo_surface The cairo surface associated with the window. unsigned char *snapshot A single cairo snapshot FiniteBtn **btns An array of FiniteBtns int _btns The number of FiniteBtns currently visible. int activeButton The Array position of the currently selected void *data Custom data Notes * 1) wl_output is a pointer but not an array. The Islands compositor only allows one output at a time which is reflected in this value. 2) Snapshots are able to be recovered to return the UI to a previous state. They currently do not apply array related changes to buttons. Standard Usage * When creating an appplication in libfinite you must always use a FiniteShell object created with finite_shell_init . Unless you need a specific wayland client, \"wayland-0\" should be the parameter passed into finite_shell_init . The Cubix Infinite uses Wayland as it's display server so in order to keep the FiniteShell session alive you'll need to use use the wayland function wl_display_dispatch for cairo based applications or wl_display_dispatch_pending for Vulkan based applications. When creating an application in libfinite you'll need to call either finite_window_init or finite_overlay_init depending on what you're creating. For more information, see their corresponding pages. Related Docs * finite_shell_init finite_window_init finite_overlay_init","title":"FiniteShell"},{"location":"reference/types/FiniteShell/#finiteshell","text":"\u2754 FiniteShell was last modified in 0.4.0 typedef struct FiniteShell FiniteShell; struct FiniteShell{ int shm_fd; int pool_size; int stride; uint8_t *pool_data; struct wl_display *display; struct wl_registry *registry; struct wl_output *output; struct wl_shm *shm; struct wl_shm_pool *pool; struct wl_buffer *buffer; struct wl_compositor *isle; struct wl_surface *isle_surface; struct xdg_wm_base *base; struct xdg_surface *surface; struct xdg_toplevel *window; struct zwlr_layer_shell_v1 *shell; struct zwlr_layer_surface_v1 *layer_surface; FiniteWindowInfo *details; cairo_t *cr; cairo_surface_t *cairo_surface; unsigned char *snapshot; FiniteBtn **btns; int _btns; int activeButton; void *data; }; The FiniteShell struct stores general information about a window.","title":"FiniteShell"},{"location":"reference/types/FiniteShell/#properties","text":"Type Decription int shm_fd An integer file descriptor for the shared memory(shm) buffer associated with the file. int pool_size The size of the shm pool int stride The spacing between blocks of memory when drawing with Cairo. uint8_t pool_data The mmapped data in the pool. struct wl_display *display The Wayland display associated with the FiniteShell. struct wl_registry *registry The Wayland registry associated with the display. struct wl_output *output The Wayland Output that is currently connected. struct wl_shm *shm The Wayland shm struct associated with the FiniteShell struct wl_shm_pool *pool The Wayland shm pool associated with the shm struct wl_buffer *buffer The Wayland shm buffer associated with the FiniteShell struct wl_compositor *isle The Compositor connected the display struct wl_surface *isle_surface The Wayland surface connected to display struct xdg_wm_base *base The xdg_wm_base associated with the FiniteShell struct xdg_surface *surface The xdg_surface associated with the base struct xdg_toplevel *window The xdg_toplevel where data will be rendered to. struct zwlr_layer_shell_v1 *shell The layer shell associated with the FiniteShell struct zwlr_layer_surface_v1 *layer_surface The layer surface associated with the layer shell FiniteWindowInfo *details Data about the window cairo_t *cr The Cairo drawing object. cairo_surface_t *cairo_surface The cairo surface associated with the window. unsigned char *snapshot A single cairo snapshot FiniteBtn **btns An array of FiniteBtns int _btns The number of FiniteBtns currently visible. int activeButton The Array position of the currently selected void *data Custom data","title":"Properties"},{"location":"reference/types/FiniteShell/#notes","text":"1) wl_output is a pointer but not an array. The Islands compositor only allows one output at a time which is reflected in this value. 2) Snapshots are able to be recovered to return the UI to a previous state. They currently do not apply array related changes to buttons.","title":"Notes"},{"location":"reference/types/FiniteShell/#standard-usage","text":"When creating an appplication in libfinite you must always use a FiniteShell object created with finite_shell_init . Unless you need a specific wayland client, \"wayland-0\" should be the parameter passed into finite_shell_init . The Cubix Infinite uses Wayland as it's display server so in order to keep the FiniteShell session alive you'll need to use use the wayland function wl_display_dispatch for cairo based applications or wl_display_dispatch_pending for Vulkan based applications. When creating an application in libfinite you'll need to call either finite_window_init or finite_overlay_init depending on what you're creating. For more information, see their corresponding pages.","title":"Standard Usage"},{"location":"reference/types/FiniteShell/#related-docs","text":"finite_shell_init finite_window_init finite_overlay_init","title":"Related Docs"},{"location":"reference/types/FiniteTextGroup/","text":"FiniteTextGroup * \u2754 FiniteTextGroup was last modified in 0.4.0 typedef struct { double r; double g; double b; double a; const char *text; } FiniteTextGroup; The FiniteTextGroup struct stores general information about a window. Properties * Type Decription double r,g,b,a The RGBA value of the text.. const char *text The text. Notes * The RGB values must be double (float) values between 0 and 1. The way to convert the RGB colors to valid doubles is to divide the value by 255. Below is one way to get the correct RGB values. size_t members = 2; FiniteTextGroup myGroup[2] = { { .r = 216.0/255.0, // 0.847 .g = 90.0/255.0, // 0.352 .b = 71.0/255.0, // 0.278 .a = 1.0, .text = \"Test \" }, { .r = 6.0/255.0, // 0.023 .g = 190.0/255.0, //0.745 .b = 31.0/255.0, // 0.121 .a = 1.0, .text = \"Subject.\" }, } Standard Usage * When using a FiniteTextGroup , you should keep track of the number of items in the array. Additionally, FiniteTextGroups are meant to be stored in an array, as having a single item in a finite text group is both pointless and causes errors. Related Docs * finite_draw_set_text finite_draw_text_group","title":"FiniteTextGroup"},{"location":"reference/types/FiniteTextGroup/#finitetextgroup","text":"\u2754 FiniteTextGroup was last modified in 0.4.0 typedef struct { double r; double g; double b; double a; const char *text; } FiniteTextGroup; The FiniteTextGroup struct stores general information about a window.","title":"FiniteTextGroup"},{"location":"reference/types/FiniteTextGroup/#properties","text":"Type Decription double r,g,b,a The RGBA value of the text.. const char *text The text.","title":"Properties"},{"location":"reference/types/FiniteTextGroup/#notes","text":"The RGB values must be double (float) values between 0 and 1. The way to convert the RGB colors to valid doubles is to divide the value by 255. Below is one way to get the correct RGB values. size_t members = 2; FiniteTextGroup myGroup[2] = { { .r = 216.0/255.0, // 0.847 .g = 90.0/255.0, // 0.352 .b = 71.0/255.0, // 0.278 .a = 1.0, .text = \"Test \" }, { .r = 6.0/255.0, // 0.023 .g = 190.0/255.0, //0.745 .b = 31.0/255.0, // 0.121 .a = 1.0, .text = \"Subject.\" }, }","title":"Notes"},{"location":"reference/types/FiniteTextGroup/#standard-usage","text":"When using a FiniteTextGroup , you should keep track of the number of items in the array. Additionally, FiniteTextGroups are meant to be stored in an array, as having a single item in a finite text group is both pointless and causes errors.","title":"Standard Usage"},{"location":"reference/types/FiniteTextGroup/#related-docs","text":"finite_draw_set_text finite_draw_text_group","title":"Related Docs"},{"location":"reference/types/FiniteWindowInfo/","text":"FiniteWindowInfo * \u2754 FiniteWindowInfo was last modified in 0.1.8 struct wl_output *output; int xPos; int yPos; int width; int height; } FiniteWindowInfo; The FiniteWindowInfo struct refers to the active dimensions of the window. Windows are anchored to the top-left corner of the screen. Properties * Type Decription int xPos The x position of the window. Defaults to 0. int yPos The y position of the window. Defaults to 0. int width The width of the window. Defaults to the width of the monitor in pixels. int height The height of the window. Defaults to the height of the monitor in pixels. Standard Usage * When creating a FiniteShell with finite_window_init this struct is automatically created and assigned to the full size of the monitor. You can call finite_window_set_size to change the value of this. It's recommended that you store the original FiniteWindowInfo somewhere. In order to be Infinite compliant, games should be the full size of the screen. Related Docs * FiniteShell finite_window_size_set","title":"FiniteWindowInfo"},{"location":"reference/types/FiniteWindowInfo/#finitewindowinfo","text":"\u2754 FiniteWindowInfo was last modified in 0.1.8 struct wl_output *output; int xPos; int yPos; int width; int height; } FiniteWindowInfo; The FiniteWindowInfo struct refers to the active dimensions of the window. Windows are anchored to the top-left corner of the screen.","title":"FiniteWindowInfo"},{"location":"reference/types/FiniteWindowInfo/#properties","text":"Type Decription int xPos The x position of the window. Defaults to 0. int yPos The y position of the window. Defaults to 0. int width The width of the window. Defaults to the width of the monitor in pixels. int height The height of the window. Defaults to the height of the monitor in pixels.","title":"Properties"},{"location":"reference/types/FiniteWindowInfo/#standard-usage","text":"When creating a FiniteShell with finite_window_init this struct is automatically created and assigned to the full size of the monitor. You can call finite_window_set_size to change the value of this. It's recommended that you store the original FiniteWindowInfo somewhere. In order to be Infinite compliant, games should be the full size of the screen.","title":"Standard Usage"},{"location":"reference/types/FiniteWindowInfo/#related-docs","text":"FiniteShell finite_window_size_set","title":"Related Docs"},{"location":"reference/types/render/FiniteRender/","text":"FiniteRender * \u2754 FiniteRender was last modified in v0.6.0 . #define MAX_FRAMES_IN_FLIGHT 2 struct FiniteRender { FiniteShell *shell; char **required_layers; char **required_extensions; char **required_deviceExtensions; uint32_t _images; uint32_t _layers; uint32_t _exts; uint32_t _devExts; uint32_t _modules; uint32_t _signals; uint32_t _fences; uint32_t _buffers; uint32_t _vertexBufferSize; uint32_t _currentFrame; bool withDepth; FiniteRenderShaderStages stages; VkInstance vk_instance; VkPhysicalDevice vk_pDevice; VkDevice vk_device; VkSurfaceKHR vk_surface; VkQueue vk_graphicsQueue; VkQueue vk_presentQueue; VkSwapchainKHR vk_swapchain; VkImage *vk_image; VkSurfaceFormatKHR vk_imageForm; VkPresentModeKHR mode; VkExtent2D vk_extent; VkImageView *vk_view; VkPipelineLayout vk_layout; VkRenderPass vk_renderPass; VkPipeline vk_pipeline; VkShaderModule *modules; // array of shader modules VkFramebuffer *vk_frameBufs; VkCommandPool vk_pool; VkCommandBuffer *vk_buffer; FiniteRenderBuffer *buffers; VkBuffer vk_vertexBuf; VkBuffer *vk_uniformBuf; VkDeviceMemory vk_memory; VkDeviceMemory *vk_uniformMemory; VkDescriptorSetLayout vk_descriptorLayout; VkDescriptorSet *vk_descriptor; void **uniformData; VkDescriptorPool vk_descPool; VkSemaphore *signals; VkFence *fences; }; The FiniteRender struct refers to a single Vulkan instance. Properties * Type Decription FiniteShell *shell The FiniteShell to attach the Vulkan instance to char **required_layers An array of extension layers (usually just validation which is on by default) char **required_extensions An array of Instance level extensions char **required_deviceExtensions An array of Device level extensions. uint32_t _images The number of Swapchain Images uint32_t _layers The number of extension layers uint32_t _exts The number of instance level extensions uint32_t _devExts The number of device level extensions uint32_t _modules The number of shader modules uint32_t _signals The number of Semaphores (signals) uint32_t _fences The number of fences uint32_t _buffers The number of FiniteRenderBuffers uint32_t _vertexBufferSize Unused uint32_t _currentFrame The current Frame In Flight. bool withDepth Whether to use the v0.6.0 depth layer features. FiniteRenderShaderStages stages The FiniteRenderShaderStages for the Vulkan Instance VkInstance vk_instance The Vulkan Instance struct VkPhysicalDevice vk_pDevice The Physical Device for the Render instance VkDevice vk_device The logical device for the render instance VkSurfaceKHR vk_surface The Vulkan Surface for the render instance. VkQueue vk_graphicsQueue The Graphics Queue for the render instance VkQueue vk_presentQueue The Presentation Queue for the render instance VkSwapchainKHR vk_swapchain The Swapchain for the render instance VkImage *vk_image An array of VkImages for the Render Instance VkSurfaceFormatKHR vk_imageForm The Image Format for the render instance VkPresentModeKHR mode The PresentMode of the Window. Defaults to FIFO VkExtent2D vk_extent The window scale. The value should be retrived from the FiniteShell. VkImageView *vk_view An array of VkImageViews for the render instance. VkPipelineLayout vk_layout The pipeline layout for the vk_pipeline. VkRenderPass vk_renderPass The render pass for the render instance. VkPipeline vk_pipeline The Graphics Pipeline for the render instance. VkShaderModule *modules An array of shader modules VkFramebuffer *vk_frameBufs An array of Framebuffers VkCommandPool vk_pool The MAIN command pool used by the render instance. VkCommandBuffer *vk_buffer; The Command buffer created from the vk_pool FiniteRenderBuffer *buffers An array of VkBuffer details VkBuffer vk_vertexBuf A set of VkBuffers for drawing vertexes. VkBuffer *vk_uniformBuf An array of VkBuffers for Uniform buffers VkDeviceMemory vk_memory A set of VkDeviceMemory for storing info related to drawing vertexes VkDeviceMemory *vk_uniformMemory An array of VkDeviceMemory for storing info related to memory buffers VkDescriptorSetLayout vk_descriptorLayout A VkDescriptorSetLayout for the render instance VkDescriptorSet *vk_descriptor An array of VkDescriptorSets for the render instance void **uniformData Data about the uniform buffers used to render them VkDescriptorPool vk_descPool The descriptor pool for the render instance VkSemaphore *signals An array of Semaphores (signals) VkFence *fences An array of VkFences Notes * The vk_surface in FiniteRender should be attached to a Wayland Surface (not an xdg_surface). The vk_graphicsQueue and vk_presentQueue in FiniteRender are derived from the Physical Device. You must use a GPU that supports both. In order to use multiple swapchains, you'll need to manage the value of vk_swapchain. The vk_image array contains production ready images. This should not be confused with the FiniteRenderImage Swaitandard Usage * When creating a FiniteRender instance you must have a valid FiniteShell to like to it. This struct should be created with finite_render_init and destroyed with finite_render_cleanup Related Docs *","title":"FiniteRender"},{"location":"reference/types/render/FiniteRender/#finiterender","text":"\u2754 FiniteRender was last modified in v0.6.0 . #define MAX_FRAMES_IN_FLIGHT 2 struct FiniteRender { FiniteShell *shell; char **required_layers; char **required_extensions; char **required_deviceExtensions; uint32_t _images; uint32_t _layers; uint32_t _exts; uint32_t _devExts; uint32_t _modules; uint32_t _signals; uint32_t _fences; uint32_t _buffers; uint32_t _vertexBufferSize; uint32_t _currentFrame; bool withDepth; FiniteRenderShaderStages stages; VkInstance vk_instance; VkPhysicalDevice vk_pDevice; VkDevice vk_device; VkSurfaceKHR vk_surface; VkQueue vk_graphicsQueue; VkQueue vk_presentQueue; VkSwapchainKHR vk_swapchain; VkImage *vk_image; VkSurfaceFormatKHR vk_imageForm; VkPresentModeKHR mode; VkExtent2D vk_extent; VkImageView *vk_view; VkPipelineLayout vk_layout; VkRenderPass vk_renderPass; VkPipeline vk_pipeline; VkShaderModule *modules; // array of shader modules VkFramebuffer *vk_frameBufs; VkCommandPool vk_pool; VkCommandBuffer *vk_buffer; FiniteRenderBuffer *buffers; VkBuffer vk_vertexBuf; VkBuffer *vk_uniformBuf; VkDeviceMemory vk_memory; VkDeviceMemory *vk_uniformMemory; VkDescriptorSetLayout vk_descriptorLayout; VkDescriptorSet *vk_descriptor; void **uniformData; VkDescriptorPool vk_descPool; VkSemaphore *signals; VkFence *fences; }; The FiniteRender struct refers to a single Vulkan instance.","title":"FiniteRender"},{"location":"reference/types/render/FiniteRender/#properties","text":"Type Decription FiniteShell *shell The FiniteShell to attach the Vulkan instance to char **required_layers An array of extension layers (usually just validation which is on by default) char **required_extensions An array of Instance level extensions char **required_deviceExtensions An array of Device level extensions. uint32_t _images The number of Swapchain Images uint32_t _layers The number of extension layers uint32_t _exts The number of instance level extensions uint32_t _devExts The number of device level extensions uint32_t _modules The number of shader modules uint32_t _signals The number of Semaphores (signals) uint32_t _fences The number of fences uint32_t _buffers The number of FiniteRenderBuffers uint32_t _vertexBufferSize Unused uint32_t _currentFrame The current Frame In Flight. bool withDepth Whether to use the v0.6.0 depth layer features. FiniteRenderShaderStages stages The FiniteRenderShaderStages for the Vulkan Instance VkInstance vk_instance The Vulkan Instance struct VkPhysicalDevice vk_pDevice The Physical Device for the Render instance VkDevice vk_device The logical device for the render instance VkSurfaceKHR vk_surface The Vulkan Surface for the render instance. VkQueue vk_graphicsQueue The Graphics Queue for the render instance VkQueue vk_presentQueue The Presentation Queue for the render instance VkSwapchainKHR vk_swapchain The Swapchain for the render instance VkImage *vk_image An array of VkImages for the Render Instance VkSurfaceFormatKHR vk_imageForm The Image Format for the render instance VkPresentModeKHR mode The PresentMode of the Window. Defaults to FIFO VkExtent2D vk_extent The window scale. The value should be retrived from the FiniteShell. VkImageView *vk_view An array of VkImageViews for the render instance. VkPipelineLayout vk_layout The pipeline layout for the vk_pipeline. VkRenderPass vk_renderPass The render pass for the render instance. VkPipeline vk_pipeline The Graphics Pipeline for the render instance. VkShaderModule *modules An array of shader modules VkFramebuffer *vk_frameBufs An array of Framebuffers VkCommandPool vk_pool The MAIN command pool used by the render instance. VkCommandBuffer *vk_buffer; The Command buffer created from the vk_pool FiniteRenderBuffer *buffers An array of VkBuffer details VkBuffer vk_vertexBuf A set of VkBuffers for drawing vertexes. VkBuffer *vk_uniformBuf An array of VkBuffers for Uniform buffers VkDeviceMemory vk_memory A set of VkDeviceMemory for storing info related to drawing vertexes VkDeviceMemory *vk_uniformMemory An array of VkDeviceMemory for storing info related to memory buffers VkDescriptorSetLayout vk_descriptorLayout A VkDescriptorSetLayout for the render instance VkDescriptorSet *vk_descriptor An array of VkDescriptorSets for the render instance void **uniformData Data about the uniform buffers used to render them VkDescriptorPool vk_descPool The descriptor pool for the render instance VkSemaphore *signals An array of Semaphores (signals) VkFence *fences An array of VkFences","title":"Properties"},{"location":"reference/types/render/FiniteRender/#notes","text":"The vk_surface in FiniteRender should be attached to a Wayland Surface (not an xdg_surface). The vk_graphicsQueue and vk_presentQueue in FiniteRender are derived from the Physical Device. You must use a GPU that supports both. In order to use multiple swapchains, you'll need to manage the value of vk_swapchain. The vk_image array contains production ready images. This should not be confused with the FiniteRenderImage","title":"Notes"},{"location":"reference/types/render/FiniteRender/#swaitandard-usage","text":"When creating a FiniteRender instance you must have a valid FiniteShell to like to it. This struct should be created with finite_render_init and destroyed with finite_render_cleanup","title":"Swaitandard Usage"},{"location":"reference/types/render/FiniteRender/#related-docs","text":"","title":"Related Docs"},{"location":"reference/types/render/FiniteRenderAttachmentDescriptionInfo/","text":"FiniteRenderAttachmentDescriptionInfo * \u2754 FiniteRenderAttachmentDescriptionInfo was last modified in v0.6.0 . typedef struct FiniteRenderAttachmentDescriptionInfo FiniteRenderAttachmentDescriptionInfo; struct FiniteRenderAttachmentDescriptionInfo { VkAttachmentDescriptionFlags flags; VkFormat format; VkSampleCountFlagBits samples; VkAttachmentLoadOp loadOp; VkAttachmentStoreOp storeOp; VkAttachmentLoadOp stencilLoadOp; VkAttachmentStoreOp stencilStoreOp; VkImageLayout initialLayout; VkImageLayout finalLayout; }; The FiniteRenderAttachmentDescriptionInfo struct param information for creating a VkAttachmentDecription. Properties * Type Decription VkAttachmentDescriptionFlags flags Flags for the AttachmentDescription. VkFormat format The format of the image view. VkSampleCountFlagBits samples The number of VkSamples in the images. VkAttachmentLoadOp loadOp What to do when loading attachments VkAttachmentStoreOp storeOp What to do when storing attachments VkAttachmentLoadOp stencilLoadOp What to do with stencil data when loading attachments VkAttachmentStoreOp stencilStoreOp What to do with stencil data when storing attachments VkImageLayout initialLayout The layout the attachment is currently at. VkImageLayout finalLayout The layout the attachment should be at when finished. Standard Usage * This struct should be created manually and used as a params finite_render_create_render_pass","title":"FiniteRenderAttachmentDescriptionInfo"},{"location":"reference/types/render/FiniteRenderAttachmentDescriptionInfo/#finiterenderattachmentdescriptioninfo","text":"\u2754 FiniteRenderAttachmentDescriptionInfo was last modified in v0.6.0 . typedef struct FiniteRenderAttachmentDescriptionInfo FiniteRenderAttachmentDescriptionInfo; struct FiniteRenderAttachmentDescriptionInfo { VkAttachmentDescriptionFlags flags; VkFormat format; VkSampleCountFlagBits samples; VkAttachmentLoadOp loadOp; VkAttachmentStoreOp storeOp; VkAttachmentLoadOp stencilLoadOp; VkAttachmentStoreOp stencilStoreOp; VkImageLayout initialLayout; VkImageLayout finalLayout; }; The FiniteRenderAttachmentDescriptionInfo struct param information for creating a VkAttachmentDecription.","title":"FiniteRenderAttachmentDescriptionInfo"},{"location":"reference/types/render/FiniteRenderAttachmentDescriptionInfo/#properties","text":"Type Decription VkAttachmentDescriptionFlags flags Flags for the AttachmentDescription. VkFormat format The format of the image view. VkSampleCountFlagBits samples The number of VkSamples in the images. VkAttachmentLoadOp loadOp What to do when loading attachments VkAttachmentStoreOp storeOp What to do when storing attachments VkAttachmentLoadOp stencilLoadOp What to do with stencil data when loading attachments VkAttachmentStoreOp stencilStoreOp What to do with stencil data when storing attachments VkImageLayout initialLayout The layout the attachment is currently at. VkImageLayout finalLayout The layout the attachment should be at when finished.","title":"Properties"},{"location":"reference/types/render/FiniteRenderAttachmentDescriptionInfo/#standard-usage","text":"This struct should be created manually and used as a params finite_render_create_render_pass","title":"Standard Usage"},{"location":"reference/types/render/FiniteRenderAttachmentRefInfo/","text":"FiniteRenderAttachmentRefInfo * \u2754 FiniteRenderAttachmentRefInfo was last modified in v0.6.0 . typedef struct FiniteRenderAttachmentRefInfo FiniteRenderAttachmentRefInfo; struct FiniteRenderAttachmentRefInfo { uint32_t _attachment; VkImageLayout layout; FiniteAttachmentDescriptor type; }; The FiniteRenderAttachmentRefInfo struct contains param information for creating a VkAttachmenReference. Properties * Type Decription uint32_t _attachment The number of attachments. VkImageLayout layout The layout the attachment is currently at. FiniteAttachmentDescriptor The type of descriptor the FintiteRenderAttachmentRef is. Standard Usage * This struct should be created manually and used as a params finite_render_create_render_pass","title":"FiniteRenderAttachmentRefInfo"},{"location":"reference/types/render/FiniteRenderAttachmentRefInfo/#finiterenderattachmentrefinfo","text":"\u2754 FiniteRenderAttachmentRefInfo was last modified in v0.6.0 . typedef struct FiniteRenderAttachmentRefInfo FiniteRenderAttachmentRefInfo; struct FiniteRenderAttachmentRefInfo { uint32_t _attachment; VkImageLayout layout; FiniteAttachmentDescriptor type; }; The FiniteRenderAttachmentRefInfo struct contains param information for creating a VkAttachmenReference.","title":"FiniteRenderAttachmentRefInfo"},{"location":"reference/types/render/FiniteRenderAttachmentRefInfo/#properties","text":"Type Decription uint32_t _attachment The number of attachments. VkImageLayout layout The layout the attachment is currently at. FiniteAttachmentDescriptor The type of descriptor the FintiteRenderAttachmentRef is.","title":"Properties"},{"location":"reference/types/render/FiniteRenderAttachmentRefInfo/#standard-usage","text":"This struct should be created manually and used as a params finite_render_create_render_pass","title":"Standard Usage"},{"location":"reference/types/render/FiniteRenderFramebufferInfo/","text":"FiniteRenderFramebufferInfo * \u2754 FiniteRenderFramebufferInfo was last modified in v0.6.0 . typedef struct FiniteRenderFramebufferInfo FiniteRenderFramebufferInfo; struct FiniteRenderFramebufferInfo { const void *next; VkFramebufferCreateFlags flags; uint32_t _attachments; VkImageView *attachments; uint32_t width; uint32_t height; uint32_t layers; }; The FiniteRenderFramebufferInfo struct contains param information for creating a VkFramebuffer. Properties * Type Decription const void *next An extension of the VkRenderFrameBufferInfo or NULL VkFramebufferCreateFlags flags The VkFramebuffer flags uint32_t _attachments The number of attachments VkImageView *attachments The VkImageView attachments. uint32_t width The width of the framebuffer. uint32_t height The height of the framebuffer. uint32_t layer The depth of the framebuffer. Standard Usage * This struct should be created manually and used as a params finite_render_create_framebuffers","title":"FiniteRenderFramebufferInfo"},{"location":"reference/types/render/FiniteRenderFramebufferInfo/#finiterenderframebufferinfo","text":"\u2754 FiniteRenderFramebufferInfo was last modified in v0.6.0 . typedef struct FiniteRenderFramebufferInfo FiniteRenderFramebufferInfo; struct FiniteRenderFramebufferInfo { const void *next; VkFramebufferCreateFlags flags; uint32_t _attachments; VkImageView *attachments; uint32_t width; uint32_t height; uint32_t layers; }; The FiniteRenderFramebufferInfo struct contains param information for creating a VkFramebuffer.","title":"FiniteRenderFramebufferInfo"},{"location":"reference/types/render/FiniteRenderFramebufferInfo/#properties","text":"Type Decription const void *next An extension of the VkRenderFrameBufferInfo or NULL VkFramebufferCreateFlags flags The VkFramebuffer flags uint32_t _attachments The number of attachments VkImageView *attachments The VkImageView attachments. uint32_t width The width of the framebuffer. uint32_t height The height of the framebuffer. uint32_t layer The depth of the framebuffer.","title":"Properties"},{"location":"reference/types/render/FiniteRenderFramebufferInfo/#standard-usage","text":"This struct should be created manually and used as a params finite_render_create_framebuffers","title":"Standard Usage"},{"location":"reference/types/render/FiniteRenderPassInfo/","text":"FiniteRenderRenderPassInfo * \u2754 FiniteRenderRenderPassInfo was last modified in v0.6.0 . typedef struct FiniteRenderRenderPassInfo FiniteRenderRenderPassInfo; struct FiniteRenderRenderPassInfo { const void *next; VkRenderPassCreateFlags flags; uint32_t _attachments; VkAttachmentDescription *attachments; uint32_t _subpasses; const VkSubpassDescription *subpasses; uint32_t _deps; const VkSubpassDependency *dependencies; uint32_t _refs; }; The FiniteRenderRenderPassInfo struct contains param information for creating a VkRenderPass. Properties * Type Decription const void *next An extension of the VkRenderPassInfo or NULL VkRenderPassCreateFlags flags Additional flags for creating the render pass. uint32_t _attachments The number of attachments there are. VkAttachmentDescription *attachments The attachments. uint32_t _subpasses The number of subpasses const VkSubpassDescription *subpasses The subpasses uint32_t _deps The numbers of subpass dependencies. const VkSubpassDependency *dependencies The subpass dependencies. uint32_t _refs The number of Color Attachment references Standard Usage * All _values must always be defined. This struct should be created manually and used as a params finite_render_create_render_pass","title":"FiniteRenderRenderPassInfo"},{"location":"reference/types/render/FiniteRenderPassInfo/#finiterenderrenderpassinfo","text":"\u2754 FiniteRenderRenderPassInfo was last modified in v0.6.0 . typedef struct FiniteRenderRenderPassInfo FiniteRenderRenderPassInfo; struct FiniteRenderRenderPassInfo { const void *next; VkRenderPassCreateFlags flags; uint32_t _attachments; VkAttachmentDescription *attachments; uint32_t _subpasses; const VkSubpassDescription *subpasses; uint32_t _deps; const VkSubpassDependency *dependencies; uint32_t _refs; }; The FiniteRenderRenderPassInfo struct contains param information for creating a VkRenderPass.","title":"FiniteRenderRenderPassInfo"},{"location":"reference/types/render/FiniteRenderPassInfo/#properties","text":"Type Decription const void *next An extension of the VkRenderPassInfo or NULL VkRenderPassCreateFlags flags Additional flags for creating the render pass. uint32_t _attachments The number of attachments there are. VkAttachmentDescription *attachments The attachments. uint32_t _subpasses The number of subpasses const VkSubpassDescription *subpasses The subpasses uint32_t _deps The numbers of subpass dependencies. const VkSubpassDependency *dependencies The subpass dependencies. uint32_t _refs The number of Color Attachment references","title":"Properties"},{"location":"reference/types/render/FiniteRenderPassInfo/#standard-usage","text":"All _values must always be defined. This struct should be created manually and used as a params finite_render_create_render_pass","title":"Standard Usage"},{"location":"reference/types/render/FiniteRenderPipelineLayoutInfo/","text":"FiniteRenderPipelineLayoutInfo * \u2754 FiniteRenderPipelineLayoutInfo was last modified in v0.6.0 . typedef struct FiniteRenderPipelineLayoutInfo FiniteRenderPipelineLayoutInfo; struct FiniteRenderPipelineLayoutInfo { VkPipelineLayoutCreateFlags flags; uint32_t _setConsts; VkDescriptorSetLayout *setConsts; uint32_t _pushRange; VkPushConstantRange *pushRange; }; The FiniteRenderSwapchainInfo struct contains param information for creating a VkSwapchain. Properties * Type Decription VkPipelineLayoutCreateFlags flags The Pipeline Layout Flags. uint32_t _setConsts The number of Set Constants VkDescriptorSetLayout *setConsts An array of the Set Constants. uint32_t _pushRange The number of push range constants. VkPushConstantRange *pushRange An array of the push range constants Standard Usage * All _values must always be defined. This struct should be created manually and used as a param to finite_render_create_swapchain","title":"FiniteRenderPipelineLayoutInfo"},{"location":"reference/types/render/FiniteRenderPipelineLayoutInfo/#finiterenderpipelinelayoutinfo","text":"\u2754 FiniteRenderPipelineLayoutInfo was last modified in v0.6.0 . typedef struct FiniteRenderPipelineLayoutInfo FiniteRenderPipelineLayoutInfo; struct FiniteRenderPipelineLayoutInfo { VkPipelineLayoutCreateFlags flags; uint32_t _setConsts; VkDescriptorSetLayout *setConsts; uint32_t _pushRange; VkPushConstantRange *pushRange; }; The FiniteRenderSwapchainInfo struct contains param information for creating a VkSwapchain.","title":"FiniteRenderPipelineLayoutInfo"},{"location":"reference/types/render/FiniteRenderPipelineLayoutInfo/#properties","text":"Type Decription VkPipelineLayoutCreateFlags flags The Pipeline Layout Flags. uint32_t _setConsts The number of Set Constants VkDescriptorSetLayout *setConsts An array of the Set Constants. uint32_t _pushRange The number of push range constants. VkPushConstantRange *pushRange An array of the push range constants","title":"Properties"},{"location":"reference/types/render/FiniteRenderPipelineLayoutInfo/#standard-usage","text":"All _values must always be defined. This struct should be created manually and used as a param to finite_render_create_swapchain","title":"Standard Usage"},{"location":"reference/types/render/FiniteRenderQueueFamily/","text":"FiniteRenderQueueFamilies * \u2754 FiniteRenderQueueFamilies was last modified in v0.6.0 . typedef struct FiniteRenderQueueFamilies FiniteRenderQueueFamilies; struct FiniteRenderQueueFamilies { uint32_t graphicsFamily; uint32_t presentFamily; uint32_t _unique; }; The FiniteRenderQueueFamilies struct refers to where the graphicsFamily and presentFamily are on the GPU. Properties * Type Decription uint32_t graphicsFamily The location of the graphicsFamily uint32_t presentFamily The location of the presentFamily uint32_t _unique The how many unique addresses there are. Standard Usage * This struct should be created with finite_render_find_queue_families .","title":"FiniteRenderQueueFamilies"},{"location":"reference/types/render/FiniteRenderQueueFamily/#finiterenderqueuefamilies","text":"\u2754 FiniteRenderQueueFamilies was last modified in v0.6.0 . typedef struct FiniteRenderQueueFamilies FiniteRenderQueueFamilies; struct FiniteRenderQueueFamilies { uint32_t graphicsFamily; uint32_t presentFamily; uint32_t _unique; }; The FiniteRenderQueueFamilies struct refers to where the graphicsFamily and presentFamily are on the GPU.","title":"FiniteRenderQueueFamilies"},{"location":"reference/types/render/FiniteRenderQueueFamily/#properties","text":"Type Decription uint32_t graphicsFamily The location of the graphicsFamily uint32_t presentFamily The location of the presentFamily uint32_t _unique The how many unique addresses there are.","title":"Properties"},{"location":"reference/types/render/FiniteRenderQueueFamily/#standard-usage","text":"This struct should be created with finite_render_find_queue_families .","title":"Standard Usage"},{"location":"reference/types/render/FiniteRenderShaderStageInfo/","text":"FiniteRenderShaderStageInfo * \u2754 FiniteRenderShaderStageInfo was last modified in v0.6.0 . typedef struct FiniteRenderShaderStageInfo FiniteRenderShaderStageInfo; struct FiniteRenderShaderStageInfo { const void *next; VkPipelineShaderStageCreateFlags flags; FiniteShaderType stage; VkShaderModule shader; const char *name; const VkSpecializationInfo *specializationInfo; }; The FiniteRenderShaderStageInfo struct contains param information for creating a VkShaderStage. Properties * Type Decription const void *next An extension of the VkShaderStageInfo or NULL VkPipelineShaderStageCreateFlags flags The Shader Stage Flags. FiniteShaderType stage The FiniteShaderType of Shader stage VkShaderModule shader The VkShaderModule const char *name The name of entry function for the shader. const VkSpecializationInfo *specializationInfo Additional specizialization info for the VkShaderModule. Standard Usage * All _values must always be defined. This struct should be created manually and used as a param to finite_render_add_shader_stage","title":"FiniteRenderShaderStageInfo"},{"location":"reference/types/render/FiniteRenderShaderStageInfo/#finiterendershaderstageinfo","text":"\u2754 FiniteRenderShaderStageInfo was last modified in v0.6.0 . typedef struct FiniteRenderShaderStageInfo FiniteRenderShaderStageInfo; struct FiniteRenderShaderStageInfo { const void *next; VkPipelineShaderStageCreateFlags flags; FiniteShaderType stage; VkShaderModule shader; const char *name; const VkSpecializationInfo *specializationInfo; }; The FiniteRenderShaderStageInfo struct contains param information for creating a VkShaderStage.","title":"FiniteRenderShaderStageInfo"},{"location":"reference/types/render/FiniteRenderShaderStageInfo/#properties","text":"Type Decription const void *next An extension of the VkShaderStageInfo or NULL VkPipelineShaderStageCreateFlags flags The Shader Stage Flags. FiniteShaderType stage The FiniteShaderType of Shader stage VkShaderModule shader The VkShaderModule const char *name The name of entry function for the shader. const VkSpecializationInfo *specializationInfo Additional specizialization info for the VkShaderModule.","title":"Properties"},{"location":"reference/types/render/FiniteRenderShaderStageInfo/#standard-usage","text":"All _values must always be defined. This struct should be created manually and used as a param to finite_render_add_shader_stage","title":"Standard Usage"},{"location":"reference/types/render/FiniteRenderShaderStages/","text":"FiniteRenderShaderStages * \u2754 FiniteRenderShaderStages was last modified in v0.6.0 . typedef struct FiniteRenderShaderStages FiniteRenderShaderStages ; struct FiniteRenderShaderStages { uint32_t _stages; VkPipelineShaderStageCreateInfo *infos; }; The FiniteRenderSwapchainInfo struct contains param information for creating a VkSwapchain. Properties * Type Decription uint32_t _stage The number of Pipelines Shader stages VkPipelineShaderStageCreateInfo *infos An array of Pipeline Shader Stages Standard Usage * This struct should be created manually and used as a param to finite_render_add_shader_stage","title":"FiniteRenderShaderStages"},{"location":"reference/types/render/FiniteRenderShaderStages/#finiterendershaderstages","text":"\u2754 FiniteRenderShaderStages was last modified in v0.6.0 . typedef struct FiniteRenderShaderStages FiniteRenderShaderStages ; struct FiniteRenderShaderStages { uint32_t _stages; VkPipelineShaderStageCreateInfo *infos; }; The FiniteRenderSwapchainInfo struct contains param information for creating a VkSwapchain.","title":"FiniteRenderShaderStages"},{"location":"reference/types/render/FiniteRenderShaderStages/#properties","text":"Type Decription uint32_t _stage The number of Pipelines Shader stages VkPipelineShaderStageCreateInfo *infos An array of Pipeline Shader Stages","title":"Properties"},{"location":"reference/types/render/FiniteRenderShaderStages/#standard-usage","text":"This struct should be created manually and used as a param to finite_render_add_shader_stage","title":"Standard Usage"},{"location":"reference/types/render/FiniteRenderSubpassDependencyInfo/","text":"FiniteRenderSubpassDependencyInfo * \u2754 FiniteRenderSubpassDependencyInfo was last modified in v0.6.0 . typedef struct FiniteRenderSubpassDependencyInfo FiniteRenderSubpassDependencyInfo ; struct FiniteRenderSubpassDependencyInfo { uint32_t srcSubpass; uint32_t destSubpass; VkPipelineStageFlags srcStageMask; VkPipelineStageFlags destStageMask; VkAccessFlags srcAccessMask; VkAccessFlags destAccessMask; VkDependencyFlags dependencyFlags; }; The FiniteRenderSubpassDependencyInfo struct contains param information for creating a VkSubpassDependency. Properties * Type Decription uint32_t srcSubpass The index of the source subpass uint32_t destSubpass The index of the destination subpass. VkPipelineStageFlags srcStageMask The stage mask flags for the source depenency. VkPipelineStageFlags destStageMask The stage mask flags for the destination dependency. VkAccessFlags srcAccessMask The access mask flags of the source depenedencies. VkAccessFlags destAccessMask The access mask flags for destination dependency. VkDependencyFlags dependencyFlags Additional dependency flags. Standard Usage * The value of pipelineBindPoint should be VK_PIPELINE_BIND_POINT_GRAPHICS . This struct should be created manually and used as a params finite_render_create_render_pass","title":"FiniteRenderSubpassDependencyInfo"},{"location":"reference/types/render/FiniteRenderSubpassDependencyInfo/#finiterendersubpassdependencyinfo","text":"\u2754 FiniteRenderSubpassDependencyInfo was last modified in v0.6.0 . typedef struct FiniteRenderSubpassDependencyInfo FiniteRenderSubpassDependencyInfo ; struct FiniteRenderSubpassDependencyInfo { uint32_t srcSubpass; uint32_t destSubpass; VkPipelineStageFlags srcStageMask; VkPipelineStageFlags destStageMask; VkAccessFlags srcAccessMask; VkAccessFlags destAccessMask; VkDependencyFlags dependencyFlags; }; The FiniteRenderSubpassDependencyInfo struct contains param information for creating a VkSubpassDependency.","title":"FiniteRenderSubpassDependencyInfo"},{"location":"reference/types/render/FiniteRenderSubpassDependencyInfo/#properties","text":"Type Decription uint32_t srcSubpass The index of the source subpass uint32_t destSubpass The index of the destination subpass. VkPipelineStageFlags srcStageMask The stage mask flags for the source depenency. VkPipelineStageFlags destStageMask The stage mask flags for the destination dependency. VkAccessFlags srcAccessMask The access mask flags of the source depenedencies. VkAccessFlags destAccessMask The access mask flags for destination dependency. VkDependencyFlags dependencyFlags Additional dependency flags.","title":"Properties"},{"location":"reference/types/render/FiniteRenderSubpassDependencyInfo/#standard-usage","text":"The value of pipelineBindPoint should be VK_PIPELINE_BIND_POINT_GRAPHICS . This struct should be created manually and used as a params finite_render_create_render_pass","title":"Standard Usage"},{"location":"reference/types/render/FiniteRenderSubpassDescriptionInfo/","text":"FiniteRenderSubpassDescriptionInfo * \u2754 FiniteRenderSubpassDependencyInfo was last modified in v0.6.0 . typedef struct FiniteRenderSubpassDescriptionInfo FiniteRenderSubpassDescriptionInfo; struct FiniteRenderSubpassDescriptionInfo { VkSubpassDescriptionFlags flags; VkPipelineBindPoint pipelineBindPoint; uint32_t _inputAttachments; const VkAttachmentReference *inputAttachments; uint32_t _colorAttachments; VkAttachmentReference *colorAttachments; const VkAttachmentReference *resolveAttachments; VkAttachmentReference *depthStencilAttachment; uint32_t _preserveAttachments; const uint32_t *preserveAttachments; }; The FiniteRenderSubpassDescriptionInfo struct contains param information for creating a VkSubpassDescription. Properties * Type Decription VkSubpassDescriptionFlags flags The VkSubpassDescriptionFlags VkPipelineBindPoint pipelineBindPoint What type of pipeline to bind to. uint32_t _inputAttachments The number of input attachments there are. const VkAttachmentReference *inputAttachments The actual input attachments. uint32_t _colorAttachment The number of color attachments VkAttachmentReference *colorAttachments The color attachments const VkAttachmentReference *resolveAttachments The resolve attachments. VkAttachmentReference *depthStencilAttachment The 3D Depth stencil attachment. uint32_t _preserveAttachments The number of preserve attachments const uint32_t *preserveAttachments The preserve attachments Standard Usage * The value of pipelineBindPoint should be VK_PIPELINE_BIND_POINT_GRAPHICS . This struct should be created manually and used as a params finite_render_create_render_pass","title":"FiniteRenderSubpassDescriptionInfo"},{"location":"reference/types/render/FiniteRenderSubpassDescriptionInfo/#finiterendersubpassdescriptioninfo","text":"\u2754 FiniteRenderSubpassDependencyInfo was last modified in v0.6.0 . typedef struct FiniteRenderSubpassDescriptionInfo FiniteRenderSubpassDescriptionInfo; struct FiniteRenderSubpassDescriptionInfo { VkSubpassDescriptionFlags flags; VkPipelineBindPoint pipelineBindPoint; uint32_t _inputAttachments; const VkAttachmentReference *inputAttachments; uint32_t _colorAttachments; VkAttachmentReference *colorAttachments; const VkAttachmentReference *resolveAttachments; VkAttachmentReference *depthStencilAttachment; uint32_t _preserveAttachments; const uint32_t *preserveAttachments; }; The FiniteRenderSubpassDescriptionInfo struct contains param information for creating a VkSubpassDescription.","title":"FiniteRenderSubpassDescriptionInfo"},{"location":"reference/types/render/FiniteRenderSubpassDescriptionInfo/#properties","text":"Type Decription VkSubpassDescriptionFlags flags The VkSubpassDescriptionFlags VkPipelineBindPoint pipelineBindPoint What type of pipeline to bind to. uint32_t _inputAttachments The number of input attachments there are. const VkAttachmentReference *inputAttachments The actual input attachments. uint32_t _colorAttachment The number of color attachments VkAttachmentReference *colorAttachments The color attachments const VkAttachmentReference *resolveAttachments The resolve attachments. VkAttachmentReference *depthStencilAttachment The 3D Depth stencil attachment. uint32_t _preserveAttachments The number of preserve attachments const uint32_t *preserveAttachments The preserve attachments","title":"Properties"},{"location":"reference/types/render/FiniteRenderSubpassDescriptionInfo/#standard-usage","text":"The value of pipelineBindPoint should be VK_PIPELINE_BIND_POINT_GRAPHICS . This struct should be created manually and used as a params finite_render_create_render_pass","title":"Standard Usage"},{"location":"reference/types/render/FiniteRenderSwapchainInfo/","text":"FiniteRenderSwapchainInfo * \u2754 FiniteRenderSwapchainInfo was last modified in v0.6.0 . typedef struct FiniteRenderSwapchainInfo FiniteRenderSwapchainInfo; struct FiniteRenderSwapchainInfo { VkSurfaceCapabilitiesKHR caps; uint32_t _forms; VkSurfaceFormatKHR *forms; uint32_t _modes; VkPresentModeKHR *modes; }; The FiniteRenderSwapchainInfo struct contains param information for creating a VkSwapchain. Properties * Type Decription VkSurfaceCapabilitiesKHR caps The swapchain capabilities. uint32_t _forms Additional flags for creating the render pass. VkSurfaceFormatKHR *forms The number of attachments there are. uint32_t _modes The number of possible present modes. VkPresentModeKHR *modes An array of possible present modes Standard Usage * All _values must always be defined. This struct should be created manually and used as a param to finite_render_create_swapchain","title":"FiniteRenderSwapchainInfo"},{"location":"reference/types/render/FiniteRenderSwapchainInfo/#finiterenderswapchaininfo","text":"\u2754 FiniteRenderSwapchainInfo was last modified in v0.6.0 . typedef struct FiniteRenderSwapchainInfo FiniteRenderSwapchainInfo; struct FiniteRenderSwapchainInfo { VkSurfaceCapabilitiesKHR caps; uint32_t _forms; VkSurfaceFormatKHR *forms; uint32_t _modes; VkPresentModeKHR *modes; }; The FiniteRenderSwapchainInfo struct contains param information for creating a VkSwapchain.","title":"FiniteRenderSwapchainInfo"},{"location":"reference/types/render/FiniteRenderSwapchainInfo/#properties","text":"Type Decription VkSurfaceCapabilitiesKHR caps The swapchain capabilities. uint32_t _forms Additional flags for creating the render pass. VkSurfaceFormatKHR *forms The number of attachments there are. uint32_t _modes The number of possible present modes. VkPresentModeKHR *modes An array of possible present modes","title":"Properties"},{"location":"reference/types/render/FiniteRenderSwapchainInfo/#standard-usage","text":"All _values must always be defined. This struct should be created manually and used as a param to finite_render_create_swapchain","title":"Standard Usage"},{"location":"reference/types/render/FiniteRenderVertexInputInfo/","text":"FiniteRenderVertexInputInfo * \u2754 FiniteRenderVertexInputInfo was last modified in v0.6.0 . typedef struct FiniteRenderVertexInputInfo FiniteRenderVertexInputInfo; struct FiniteRenderVertexInputInfo { const void *next; VkPipelineVertexInputStateCreateFlags flags; uint32_t _vertexBindings; const VkVertexInputBindingDescription *vertexBindingDescriptions; uint32_t _vertexAtributes; const VkVertexInputAttributeDescription *vertexAttributeDescriptions; }; The FiniteRenderVertexInputInfo struct contains param information for creating a VkVertexInputState. Properties * Type Decription const void *next An extension of the VKVertexInputStateInfo or NULL VkPipelineVertexInputStateCreateFlags flags The Vertex Input State Flags. uint32_t _vertexBinding The number of Vertex Binding Descriptions const VkVertexInputBindingDescription *vertexBindingDescriptions The Vertex Binding Descriptions uint32_t _vertexAtributes The number of Vertex Attribute Descriptions const VkVertexInputAttributeDescription *vertexAttributeDescriptions The Vertex Attribute Descriptions. Standard Usage * All _values must always be defined. This struct should be created manually and used as a param to finite_render_create_vertex_input","title":"FiniteRenderVertexInputInfo"},{"location":"reference/types/render/FiniteRenderVertexInputInfo/#finiterendervertexinputinfo","text":"\u2754 FiniteRenderVertexInputInfo was last modified in v0.6.0 . typedef struct FiniteRenderVertexInputInfo FiniteRenderVertexInputInfo; struct FiniteRenderVertexInputInfo { const void *next; VkPipelineVertexInputStateCreateFlags flags; uint32_t _vertexBindings; const VkVertexInputBindingDescription *vertexBindingDescriptions; uint32_t _vertexAtributes; const VkVertexInputAttributeDescription *vertexAttributeDescriptions; }; The FiniteRenderVertexInputInfo struct contains param information for creating a VkVertexInputState.","title":"FiniteRenderVertexInputInfo"},{"location":"reference/types/render/FiniteRenderVertexInputInfo/#properties","text":"Type Decription const void *next An extension of the VKVertexInputStateInfo or NULL VkPipelineVertexInputStateCreateFlags flags The Vertex Input State Flags. uint32_t _vertexBinding The number of Vertex Binding Descriptions const VkVertexInputBindingDescription *vertexBindingDescriptions The Vertex Binding Descriptions uint32_t _vertexAtributes The number of Vertex Attribute Descriptions const VkVertexInputAttributeDescription *vertexAttributeDescriptions The Vertex Attribute Descriptions.","title":"Properties"},{"location":"reference/types/render/FiniteRenderVertexInputInfo/#standard-usage","text":"All _values must always be defined. This struct should be created manually and used as a param to finite_render_create_vertex_input","title":"Standard Usage"},{"location":"reference/types/render/FiniteRenderViewportState/","text":"FiniteRenderViewportState * \u2754 FiniteRenderViewportState was last modified in v0.6.0 . typedef struct FiniteRenderViewportState FiniteRenderViewportState; struct FiniteRenderViewportState { const void* next; VkPipelineViewportStateCreateFlags flags; uint32_t _viewports; const VkViewport *viewports; uint32_t _scissors; const VkRect2D *scissors; }; The FiniteRenderViewportState struct contains param information for creating a VkPipelineViewportStateCreateInfo. Properties * Type Decription const void *next An extension of the VkPipelineViewportStateCreateInfo or NULL VkPipelineInputAssemblyStateCreateFlags flags The Assembly Flags. VkPrimitiveTopology toplogy The VKTopology data bool primitiveRestartEnable The Vertex Binding Descriptions Standard Usage * This struct should be created manually and used as a param to finite_render_create_viewport_state","title":"FiniteRenderViewportState"},{"location":"reference/types/render/FiniteRenderViewportState/#finiterenderviewportstate","text":"\u2754 FiniteRenderViewportState was last modified in v0.6.0 . typedef struct FiniteRenderViewportState FiniteRenderViewportState; struct FiniteRenderViewportState { const void* next; VkPipelineViewportStateCreateFlags flags; uint32_t _viewports; const VkViewport *viewports; uint32_t _scissors; const VkRect2D *scissors; }; The FiniteRenderViewportState struct contains param information for creating a VkPipelineViewportStateCreateInfo.","title":"FiniteRenderViewportState"},{"location":"reference/types/render/FiniteRenderViewportState/#properties","text":"Type Decription const void *next An extension of the VkPipelineViewportStateCreateInfo or NULL VkPipelineInputAssemblyStateCreateFlags flags The Assembly Flags. VkPrimitiveTopology toplogy The VKTopology data bool primitiveRestartEnable The Vertex Binding Descriptions","title":"Properties"},{"location":"reference/types/render/FiniteRenderViewportState/#standard-usage","text":"This struct should be created manually and used as a param to finite_render_create_viewport_state","title":"Standard Usage"}]}